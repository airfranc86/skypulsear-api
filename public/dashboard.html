<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
    <meta name="theme-color" content="#001B3C">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SkyPulse Panel - Riesgo Meteorológico en Tiempo Real</title>
    <link rel="icon" type="image/png" href="assets/images/logos/Logo.png">
    <link rel="apple-touch-icon" href="assets/images/logos/Logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --windy-deep-blue: #001B3C;
            --windy-cyan: #00D1FF;
            --windy-green-blue: #00FFBD;
            --windy-yellow: #FFE600;
            --windy-orange: #FF7A00;
            --windy-red: #D60000;

            /* Alert Levels */
            --alert-0: #10B981;
            --alert-1: #3B82F6;
            --alert-2: #F59E0B;
            --alert-3: #F97316;
            --alert-4: #DC2626;

            /* Neutrals */
            --gray-50: #F9FAFB;
            --gray-100: #F3F4F6;
            --gray-200: #E5E7EB;
            --gray-300: #D1D5DB;
            --gray-400: #9CA3AF;
            --gray-500: #6B7280;
            --gray-600: #4B5563;
            --gray-700: #374151;
            --gray-800: #1F2937;
            --gray-900: #111827;

            /* Spacing */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;

            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 9999px;

            /* Light Mode Colors */
            --light-bg: #F9FAFB;
            --light-surface: #FFFFFF;
            --light-text: #111827;
            --light-text-secondary: #4B5563;
            --light-border: #E5E7EB;

            /* View Transitions */
            --expo-out: cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(145deg, #0a1628 0%, var(--windy-deep-blue) 40%, #0d2847 100%);
            min-height: 100vh;
            min-height: 100dvh;
            color: #fff;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-size-adjust: 100%;
            -webkit-text-size-adjust: 100%;
            transition: background 0.3s ease, color 0.3s ease;
        }

        body.light {
            background: linear-gradient(145deg, #F3F4F6 0%, #E5E7EB 40%, #F9FAFB 100%);
            color: var(--light-text);
        }

        /* ============ HEADER ============ */
        .header {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: var(--space-4) var(--space-6);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        body.light .header {
            background: rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: var(--space-6);
            right: var(--space-6);
            z-index: 1000;
            width: 48px;
            height: 48px;
            border-radius: var(--radius-full);
            background: rgba(0, 209, 255, 0.1);
            border: 1px solid rgba(0, 209, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @media (max-width: 768px) {
            .theme-toggle {
                bottom: var(--space-4);
                right: var(--space-4);
                width: 44px;
                height: 44px;
            }

            .theme-toggle svg {
                width: 20px;
                height: 20px;
            }
        }

        body.light .theme-toggle {
            background: rgba(0, 27, 60, 0.05);
            border-color: rgba(0, 27, 60, 0.1);
        }

        .theme-toggle:hover {
            background: rgba(0, 209, 255, 0.15);
            border-color: rgba(0, 209, 255, 0.3);
            transform: scale(1.05);
        }

        body.light .theme-toggle:hover {
            background: rgba(0, 27, 60, 0.1);
            border-color: rgba(0, 27, 60, 0.2);
        }

        .theme-toggle svg {
            width: 24px;
            height: 24px;
            stroke: var(--windy-cyan);
            stroke-width: 1.5;
            transition: transform 0.3s ease;
        }

        body.light .theme-toggle svg {
            stroke: var(--windy-deep-blue);
        }

        .theme-toggle svg.sun {
            display: block;
        }

        .theme-toggle svg.moon {
            display: none;
        }

        body.light .theme-toggle svg.sun {
            display: none;
        }

        body.light .theme-toggle svg.moon {
            display: block;
        }

        /* View Transitions para theme toggle */
        ::view-transition-group(root) {
            animation-timing-function: var(--expo-out);
        }

        ::view-transition-new(root) {
            mask: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><defs><filter id="blur"><feGaussianBlur stdDeviation="2"/></filter></defs><circle cx="40" cy="40" r="18" fill="white" filter="url(%23blur)"/></svg>') bottom right / 0 no-repeat;
            mask-origin: content-box;
            animation: scale 1s;
            animation-fill-mode: both;
            transform-origin: bottom right;
        }

        ::view-transition-old(root),
        .dark::view-transition-old(root) {
            animation: scale 1s;
            animation-fill-mode: both;
            transform-origin: bottom right;
            z-index: -1;
        }

        @keyframes scale {
            to {
                mask-size: 350vmax;
            }
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-3);
            flex-wrap: wrap;
        }

        .header-location {
            position: relative;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: rgba(0, 209, 255, 0.1);
            border: 1px solid rgba(0, 209, 255, 0.2);
            border-radius: var(--radius-md);
            font-size: 0.75rem;
            color: var(--windy-cyan);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            user-select: none;
        }

        .header-location:hover {
            background: rgba(0, 209, 255, 0.15);
            border-color: rgba(0, 209, 255, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 209, 255, 0.2);
        }

        .header-location.active {
            background: rgba(0, 209, 255, 0.2);
            border-color: var(--windy-cyan);
        }

        .header-location svg {
            width: 14px;
            height: 14px;
            stroke: var(--windy-cyan);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .header-location.active svg.chevron {
            transform: rotate(180deg);
        }

        .header-location-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .header-location-city {
            font-weight: 600;
            color: #fff;
            transition: color 0.3s ease;
        }

        body.light .header-location-city {
            color: var(--light-text);
        }

        .header-location-coords {
            font-size: 0.65rem;
            color: var(--gray-400);
            font-family: 'SF Mono', 'Fira Code', monospace;
            transition: color 0.3s ease;
        }

        body.light .header-location-coords {
            color: var(--light-text);
        }

        /* Dropdown de ubicaciones */
        .location-dropdown {
            position: absolute;
            top: calc(100% + var(--space-2));
            left: 0;
            right: 0;
            background: rgba(0, 27, 60, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 209, 255, 0.3);
            border-radius: var(--radius-md);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            opacity: 0;
            visibility: hidden;
        }

        body.light .location-dropdown {
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid var(--light-border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }

        .location-dropdown.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .location-option {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .location-option:last-child {
            border-bottom: none;
        }

        .location-option:hover {
            background: rgba(0, 209, 255, 0.1);
        }

        body.light .location-option:hover {
            background: rgba(0, 27, 60, 0.1);
        }

        .location-option.active {
            background: rgba(0, 209, 255, 0.15);
            border-left: 3px solid var(--windy-cyan);
        }

        body.light .location-option.active {
            background: rgba(0, 27, 60, 0.15);
            border-left: 3px solid var(--windy-deep-blue);
        }

        .location-option-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
        }

        .location-option-city {
            font-weight: 600;
            color: #fff;
            font-size: 0.8rem;
        }

        body.light .location-option-city {
            color: var(--light-text);
        }

        .location-option-region {
            font-size: 0.7rem;
            color: var(--gray-400);
        }

        body.light .location-option-region {
            color: var(--light-text);
        }

        .location-option-coords {
            font-size: 0.65rem;
            color: var(--gray-500);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        body.light .location-option-coords {
            color: var(--light-text);
        }

        .location-option-check {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .location-option.active .location-option-check {
            opacity: 1;
        }

        .location-option-check svg {
            width: 16px;
            height: 16px;
            stroke: var(--windy-cyan);
            stroke-width: 2.5;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            flex-wrap: wrap;
        }

        .time-display {
            text-align: right;
        }

        .time-display .label {
            font-size: 0.7rem;
            color: var(--gray-400);
        }

        body.light .time-display .label {
            color: var(--light-text);
        }

        .time-display .time {
            font-size: 0.75rem;
            color: var(--gray-500);
        }

        body.light .time-display .time {
            color: var(--light-text);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .logo-img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(0, 209, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 209, 255, 0.3);
        }

        @media (min-width: 768px) {
            .logo-img {
                width: 48px;
                height: 48px;
            }

            .logo {
                gap: var(--space-3);
            }
        }

        .logo-text h1 {
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, var(--windy-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.light .logo-text h1 {
            background: linear-gradient(135deg, var(--windy-deep-blue), var(--windy-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @media (min-width: 768px) {
            .logo-text h1 {
                font-size: 1.25rem;
            }
        }

        .logo-text span {
            font-size: 0.6rem;
            color: var(--windy-cyan);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-weight: 500;
        }

        body.light .logo-text span {
            color: var(--windy-deep-blue);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            flex-wrap: wrap;
        }

        @media (max-width: 600px) {
            .header-content {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-2);
            }

            .header-location {
                width: 100%;
                justify-content: center;
            }

            .header-right {
                width: 100%;
                justify-content: space-between;
            }

            .nav-link {
                padding: var(--space-2) var(--space-3);
                font-size: 0.75rem;
            }

            .time-display .label {
                font-size: 0.6rem;
            }

            .time-display .time {
                font-size: 0.65rem;
            }
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            min-height: 44px;
            padding: var(--space-2) var(--space-4);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            color: var(--gray-300);
            font-size: 0.85rem;
            text-decoration: none;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        body.light .nav-link {
            background: rgba(0, 27, 60, 0.05);
            border-color: rgba(0, 27, 60, 0.1);
            color: var(--windy-deep-blue);
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        body.light .nav-link:hover {
            background: rgba(0, 27, 60, 0.1);
            border-color: rgba(0, 27, 60, 0.2);
        }

        .nav-link:focus {
            outline: 2px solid var(--windy-cyan);
            outline-offset: 2px;
        }

        .time-display {
            text-align: right;
        }

        .time-display .label {
            font-size: 0.7rem;
            color: var(--gray-400);
        }

        body.light .time-display .label {
            color: var(--light-text);
        }

        .time-display .time {
            font-size: 0.75rem;
            color: var(--gray-500);
        }

        body.light .time-display .time {
            color: var(--light-text);
        }

        .icon-sm {
            width: 16px;
            height: 16px;
        }

        /* ============ MAIN LAYOUT - MOBILE FIRST ============ */
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
        }

        @media (min-width: 1024px) {
            .main-container {
                padding: var(--space-6);
                display: flex;
                flex-direction: column;
                gap: var(--space-5);
            }

            .main-container>.alert-banner {
                width: 100%;
            }

            .main-container>.main-grid {
                display: grid;
                grid-template-columns: 1fr 320px;
                gap: var(--space-5);
            }
        }

        /* ============ SIDEBAR (MAPA + TIMELINE) ============ */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
            order: 3;
            width: 100%;
        }

        @media (min-width: 1024px) {
            .sidebar {
                order: 3;
                position: sticky;
                top: 80px;
                height: fit-content;
                width: auto;
            }
        }

        /* ============ WINDY MAP EMBED ============ */
        .windy-map-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .windy-map-header {
            padding: var(--space-3) var(--space-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        body.light .windy-map-header {
            border-bottom: 1px solid var(--light-border);
        }

        .windy-map-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--gray-300);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        body.light .windy-map-title {
            color: var(--light-text);
        }

        .windy-layer-toggle {
            display: flex;
            gap: var(--space-1);
        }

        .layer-btn {
            min-width: 44px;
            min-height: 44px;
            padding: var(--space-2);
            font-size: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            color: var(--gray-400);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.light .layer-btn {
            background: rgba(0, 27, 60, 0.05);
            border-color: rgba(0, 27, 60, 0.1);
            color: var(--light-text);
        }

        .layer-btn:focus {
            outline: 2px solid var(--windy-cyan);
            outline-offset: 2px;
        }

        .layer-btn.active {
            background: rgba(0, 209, 255, 0.2);
            border-color: rgba(0, 209, 255, 0.4);
            color: var(--windy-cyan);
        }

        body.light .layer-btn.active {
            background: rgba(0, 27, 60, 0.15);
            border-color: rgba(0, 27, 60, 0.3);
            color: var(--windy-deep-blue);
        }

        .layer-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        body.light .layer-btn:hover {
            background: rgba(0, 27, 60, 0.1);
        }

        .windy-map-container {
            width: 100%;
            height: 180px;
            background: var(--windy-deep-blue);
        }

        @media (min-width: 1024px) {
            .windy-map-container {
                height: 220px;
            }
        }

        .windy-map-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ============ TIMELINE SLIDER ============ */
        .timeline-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0.02) 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            position: relative;
            overflow: hidden;
        }

        body.light .timeline-card {
            background: var(--light-surface);
            border: 1px solid var(--light-border);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .timeline-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--windy-cyan), var(--windy-green-blue), transparent);
            opacity: 0.5;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
        }

        .timeline-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        body.light .timeline-title {
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .timeline-title svg {
            opacity: 0.7;
        }

        .timeline-current {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--windy-cyan);
            background: rgba(0, 209, 255, 0.1);
            padding: 4px 12px;
            border-radius: var(--radius-full);
            border: 1px solid rgba(0, 209, 255, 0.2);
        }

        /* Slider Container */
        .timeline-slider-container {
            position: relative;
            padding: var(--space-2) 0;
        }

        .timeline-slider-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .timeline-slider-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--windy-cyan), var(--windy-green-blue));
            border-radius: var(--radius-full);
            transition: width 0.15s ease;
        }

        .timeline-slider {
            width: 100%;
            height: 24px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            cursor: pointer;
            touch-action: pan-x;
            position: relative;
            z-index: 2;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--windy-cyan);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 12px rgba(0, 209, 255, 0.5), 0 0 0 4px rgba(0, 209, 255, 0.15);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--windy-cyan);
            border-radius: 50%;
            border: none;
            cursor: grab;
            box-shadow: 0 2px 12px rgba(0, 209, 255, 0.5), 0 0 0 4px rgba(0, 209, 255, 0.15);
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(0, 209, 255, 0.6), 0 0 0 6px rgba(0, 209, 255, 0.2);
        }

        .timeline-slider::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .timeline-slider:focus {
            outline: none;
        }

        .timeline-slider:focus::-webkit-slider-thumb {
            box-shadow: 0 2px 12px rgba(0, 209, 255, 0.5), 0 0 0 6px rgba(0, 209, 255, 0.25);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: var(--space-1);
            font-size: 0.55rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        body.light .timeline-labels {
            color: var(--light-text);
        }

        .timeline-labels span {
            transition: color 0.2s ease;
        }

        .timeline-labels span.active {
            color: var(--windy-cyan);
            font-weight: 600;
        }

        /* Forecast Items */
        .timeline-forecast {
            display: flex;
            gap: var(--space-2);
            margin-top: var(--space-4);
            overflow-x: auto;
            scroll-behavior: smooth;
            padding: var(--space-2) 0;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--windy-cyan) rgba(255, 255, 255, 0.05);
        }

        .timeline-forecast::-webkit-scrollbar {
            height: 3px;
        }

        .timeline-forecast::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 2px;
        }

        .timeline-forecast::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, var(--windy-cyan), var(--windy-green-blue));
            border-radius: 2px;
        }

        .forecast-item {
            text-align: center;
            padding: var(--space-3) var(--space-2);
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            transition: all 0.25s ease;
            min-width: 60px;
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        body.light .forecast-item {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--light-border);
        }

        .forecast-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        body.light .forecast-item:hover {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 27, 60, 0.2);
        }

        .forecast-item:active {
            transform: scale(0.97) translateY(0);
        }

        .forecast-item.active {
            background: linear-gradient(135deg, rgba(0, 209, 255, 0.15) 0%, rgba(0, 209, 255, 0.08) 100%);
            border-color: rgba(0, 209, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 209, 255, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        body.light .forecast-item.active {
            background: linear-gradient(135deg, rgba(0, 27, 60, 0.1) 0%, rgba(0, 27, 60, 0.05) 100%);
            border-color: rgba(0, 27, 60, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        body.light .forecast-item.active::before {
            background: var(--windy-deep-blue);
        }

        .forecast-item.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--windy-cyan);
            border-radius: 0 0 2px 2px;
        }

        .forecast-time {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--gray-400);
            margin-bottom: var(--space-1);
            transition: color 0.2s ease;
        }

        body.light .forecast-time {
            color: var(--light-text);
        }

        .forecast-icon {
            font-size: 1.25rem;
            margin-bottom: var(--space-1);
        }

        .forecast-temp {
            font-size: 0.85rem;
            font-weight: 600;
            color: #fff;
        }

        body.light .forecast-temp {
            color: var(--light-text);
        }

        .forecast-wind {
            font-size: 0.6rem;
            color: var(--gray-400);
        }

        body.light .forecast-wind {
            color: var(--light-text);
        }

        /* ============ MAIN CONTENT AREA ============ */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
            order: 2;
            width: 100%;
        }

        /* ============ ALERT BANNER ============ */
        .alert-banner {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            display: flex;
            flex-wrap: wrap;
            flex-direction: column;
            align-items: flex-start;
            gap: var(--space-3);
            animation: slideDown 0.5s ease-out;
            order: 1;
        }

        .alert-banner>.alert-scale {
            flex-basis: 100%;
            order: 10;
        }

        /* ============ DATA SOURCE WARNING BANNER ============ */
        .data-source-warning {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(245, 158, 11, 0.05));
            border: 1px solid rgba(245, 158, 11, 0.4);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin-bottom: var(--space-4);
            display: flex;
            align-items: flex-start;
            gap: var(--space-3);
            animation: slideDown 0.5s ease-out;
            order: 0;
        }

        .data-source-warning .warning-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .data-source-warning .warning-content {
            flex: 1;
        }

        .data-source-warning .warning-content strong {
            display: block;
            color: var(--windy-yellow);
            font-weight: 600;
            margin-bottom: var(--space-1);
            font-size: 0.95rem;
        }

        .data-source-warning .warning-content p {
            color: var(--gray-300);
            font-size: 0.875rem;
            line-height: 1.5;
            margin: 0;
        }

        body.light .data-source-warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.03));
            border-color: rgba(245, 158, 11, 0.3);
        }

        body.light .data-source-warning .warning-content p {
            color: var(--gray-600);
        }

        .data-source-warning .warning-close {
            background: transparent;
            border: none;
            color: var(--gray-400);
            font-size: 1.5rem;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .data-source-warning .warning-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--gray-200);
        }

        body.light .data-source-warning .warning-close {
            color: var(--gray-500);
        }

        body.light .data-source-warning .warning-close:hover {
            background: rgba(0, 0, 0, 0.05);
            color: var(--gray-700);
        }

        @media (max-width: 768px) {
            .data-source-warning {
                padding: var(--space-3);
                flex-direction: column;
                gap: var(--space-2);
            }

            .data-source-warning .warning-close {
                align-self: flex-end;
            }
        }

        /* ============ ALERT SCALE BAR ============ */
        .alert-scale {
            width: 100%;
            margin-top: var(--space-2);
            padding-top: var(--space-3);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        body.light .alert-scale {
            border-top: 1px solid var(--light-border);
        }

        @media (min-width: 768px) {
            .alert-scale {
                width: auto;
                min-width: 200px;
                margin-top: 0;
                padding-top: 0;
                border-top: none;
                border-left: 1px solid rgba(255, 255, 255, 0.08);
                padding-left: var(--space-4);
                margin-left: auto;
            }

            body.light .alert-scale {
                border-left: 1px solid var(--light-border);
            }
        }

        .alert-scale-bar {
            display: flex;
            height: 6px;
            border-radius: var(--radius-full);
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            gap: 2px;
        }

        body.light .alert-scale-bar {
            background: rgba(0, 0, 0, 0.05);
        }

        .alert-scale-segment {
            flex: 1;
            border-radius: 2px;
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .alert-scale-segment.seg-0 {
            background: var(--alert-0);
        }

        .alert-scale-segment.seg-1 {
            background: var(--alert-1);
        }

        .alert-scale-segment.seg-2 {
            background: var(--alert-2);
        }

        .alert-scale-segment.seg-3 {
            background: var(--alert-3);
        }

        .alert-scale-segment.seg-4 {
            background: var(--alert-4);
        }

        .alert-scale-segment.inactive {
            opacity: 0.15;
            filter: grayscale(0.5);
        }

        .alert-scale-segment.active {
            opacity: 1;
            filter: none;
        }

        .alert-scale-segment.current {
            animation: segmentPulse 2s ease-in-out infinite;
        }

        @keyframes segmentPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .alert-scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.55rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            gap: var(--space-1);
            width: 100%;
        }

        body.light .alert-scale-labels {
            color: var(--light-text);
        }

        .alert-scale-labels span {
            flex: 1;
            text-align: center;
            transition: color 0.3s ease;
            padding: 0 var(--space-1);
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        @media (min-width: 768px) {
            .alert-scale-labels {
                gap: 0;
                font-size: 0.65rem;
                padding: 0;
                justify-content: space-between;
            }

            .alert-scale-labels span {
                padding: 0;
                flex: 1;
                text-align: center;
            }
        }

        .alert-scale-labels span.active {
            color: var(--gray-200);
            font-weight: 600;
        }

        body.light .alert-scale-labels span.active {
            color: var(--windy-deep-blue);
        }

        @media (min-width: 768px) {
            .alert-banner {
                flex-direction: row;
                flex-wrap: nowrap;
                align-items: center;
                padding: var(--space-4) var(--space-6);
                gap: var(--space-4);
                max-height: 120px;
            }

            .alert-content {
                max-width: 100%;
                min-width: 200px;
            }

            .alert-banner>.alert-scale {
                flex-basis: auto;
                order: unset;
                min-width: 400px;
                max-width: 450px;
                width: 100%;
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-banner.level-0 {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        body.light .alert-banner.level-0 {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.03));
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .alert-banner.level-1 {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        body.light .alert-banner.level-1 {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.03));
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .alert-banner.level-2 {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(245, 158, 11, 0.05));
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        body.light .alert-banner.level-2 {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.03));
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .alert-banner.level-3 {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.2), rgba(249, 115, 22, 0.05));
            border: 1px solid rgba(249, 115, 22, 0.4);
        }

        body.light .alert-banner.level-3 {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.1), rgba(249, 115, 22, 0.03));
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .alert-banner.level-4 {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.25), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(220, 38, 38, 0.5);
            animation: pulse-alert 2s infinite;
        }

        body.light .alert-banner.level-4 {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.15), rgba(220, 38, 38, 0.05));
            border: 1px solid rgba(220, 38, 38, 0.4);
        }

        @keyframes pulse-alert {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4);
            }

            50% {
                box-shadow: 0 0 20px 5px rgba(220, 38, 38, 0.2);
            }
        }

        .alert-icon {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .alert-icon svg {
            width: 28px;
            height: 28px;
        }

        body.light .alert-banner .alert-icon svg {
            stroke: currentColor;
        }

        .alert-banner.level-0 .alert-icon {
            background: rgba(16, 185, 129, 0.2);
        }

        .alert-banner.level-0 .alert-icon svg {
            stroke: var(--alert-0);
        }

        .alert-banner.level-1 .alert-icon {
            background: rgba(59, 130, 246, 0.2);
        }

        .alert-banner.level-1 .alert-icon svg {
            stroke: var(--alert-1);
        }

        .alert-banner.level-2 .alert-icon {
            background: rgba(245, 158, 11, 0.2);
        }

        .alert-banner.level-2 .alert-icon svg {
            stroke: var(--alert-2);
        }

        .alert-banner.level-3 .alert-icon {
            background: rgba(249, 115, 22, 0.2);
        }

        .alert-banner.level-3 .alert-icon svg {
            stroke: var(--alert-3);
        }

        .alert-banner.level-4 .alert-icon {
            background: rgba(220, 38, 38, 0.2);
        }

        .alert-banner.level-4 .alert-icon svg {
            stroke: var(--alert-4);
        }

        .alert-content {
            flex: 1;
            min-width: 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .alert-level {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: var(--space-1);
        }

        .alert-banner.level-0 .alert-level {
            color: var(--alert-0);
        }

        .alert-banner.level-1 .alert-level {
            color: var(--alert-1);
        }

        .alert-banner.level-2 .alert-level {
            color: var(--alert-2);
        }

        .alert-banner.level-3 .alert-level {
            color: var(--alert-3);
        }

        .alert-banner.level-4 .alert-level {
            color: var(--alert-4);
        }

        .alert-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: var(--space-1);
            overflow-wrap: break-word;
            word-wrap: break-word;
            color: #fff;
        }

        body.light .alert-title {
            color: var(--light-text);
        }

        .alert-description {
            font-size: 0.85rem;
            color: var(--gray-300);
            line-height: 1.5;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        body.light .alert-description {
            color: var(--light-text);
        }

        .alert-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: var(--space-2);
            flex-shrink: 0;
        }

        .alert-time-window {
            font-size: 0.75rem;
            color: var(--gray-400);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        body.light .alert-time-window {
            color: var(--light-text);
        }

        /* ============ CARDS BASE ============ */
        .card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-lg);
            padding: var(--space-5);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        body.light .card {
            background: var(--light-surface);
            border: 1px solid var(--light-border);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card:hover {
            border-color: rgba(0, 209, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
        }

        body.light .card:hover {
            border-color: rgba(0, 27, 60, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
        }

        .card-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--gray-300);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        body.light .card-title {
            color: var(--light-text);
        }

        /* ============ ÍNDICE DE RIESGO CARD ============ */
        .risk-score-card {
            text-align: center;
            position: relative;
            overflow: visible;
        }

        .risk-score-card::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -60%);
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(0, 209, 255, 0.06) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }

        .risk-gauge {
            position: relative;
            width: 100%;
            max-width: 170px;
            aspect-ratio: 1;
            margin: var(--space-4) auto var(--space-4);
            z-index: 1;
        }

        @media (min-width: 768px) {
            .risk-gauge {
                max-width: 190px;
            }
        }

        .risk-gauge svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            overflow: visible;
        }

        .risk-gauge-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.06);
            stroke-width: 8;
        }

        body.light .risk-gauge-bg {
            stroke: rgba(0, 0, 0, 0.06);
        }

        .risk-gauge-fill {
            fill: none;
            stroke-width: 8;
            stroke-linecap: round;
            filter: drop-shadow(0 0 6px currentColor);
            transition: stroke-dashoffset 1s ease-out, stroke 0.5s ease;
        }

        .risk-score-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 100%;
        }

        .risk-score-number {
            font-size: clamp(2rem, 10vw, 3rem);
            font-weight: 800;
            line-height: 1;
            background: linear-gradient(135deg, #fff 20%, var(--windy-cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(0, 209, 255, 0.3);
        }

        body.light .risk-score-number {
            background: linear-gradient(135deg, var(--windy-deep-blue) 20%, var(--windy-cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @media (min-width: 768px) {
            .risk-score-number {
                font-size: 3rem;
            }
        }

        .risk-score-label {
            font-size: 0.65rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-top: 2px;
        }

        body.light .risk-score-label {
            color: var(--light-text);
        }

        .risk-category {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius-full);
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border: 1px solid transparent;
            animation: categoryPulse 3s ease-in-out infinite;
        }

        @keyframes categoryPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }
        }

        .risk-category::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
        }

        .risk-category.very-low {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.3);
            color: #10B981;
        }

        .risk-category.low {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3B82F6;
        }

        .risk-category.moderate {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.3);
            color: #F59E0B;
        }

        .risk-category.high {
            background: rgba(249, 115, 22, 0.15);
            border-color: rgba(249, 115, 22, 0.3);
            color: #F97316;
        }

        .risk-category.very-high {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
            color: #EF4444;
        }

        .risk-category.extreme {
            background: rgba(220, 38, 38, 0.2);
            border-color: rgba(220, 38, 38, 0.4);
            color: #DC2626;
            animation: categoryPulse 1.5s ease-in-out infinite;
        }

        .risk-factors {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        body.light .risk-factors {
            border-top: 1px solid var(--light-border);
        }

        .risk-factor {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2) var(--space-3);
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-md);
            transition: background 0.2s ease;
        }

        .risk-factor:hover {
            background: rgba(255, 255, 255, 0.04);
        }

        body.light .risk-factor {
            background: rgba(0, 27, 60, 0.02);
        }

        body.light .risk-factor:hover {
            background: rgba(0, 27, 60, 0.05);
        }

        .risk-factor-name {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--gray-400);
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 80px;
        }

        body.light .risk-factor-name {
            color: var(--light-text);
        }

        .risk-factor-name svg {
            opacity: 0.7;
        }

        .risk-factor-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
        }

        body.light .risk-factor-bar {
            background: rgba(0, 0, 0, 0.06);
        }

        .risk-factor-fill {
            height: 100%;
            border-radius: var(--radius-full);
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 10px currentColor;
        }

        .risk-factor-value {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--gray-300);
            min-width: 32px;
            text-align: right;
        }

        body.light .risk-factor-value {
            color: var(--light-text);
        }

        /* ============ PROFILE SELECTOR ============ */
        .profile-selector {
            margin-bottom: var(--space-4);
        }

        .profile-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-2);
        }

        @media (min-width: 768px) {
            .profile-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .profile-btn {
            min-height: 48px;
            padding: var(--space-2) var(--space-1);
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            color: var(--gray-300);
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            -webkit-tap-highlight-color: transparent;
        }

        body.light .profile-btn {
            background: rgba(0, 27, 60, 0.02);
            border: 1px solid var(--light-border);
            color: var(--light-text);
        }

        .profile-btn:focus {
            outline: 2px solid var(--windy-cyan);
            outline-offset: 2px;
        }

        .profile-btn:active {
            transform: scale(0.95);
        }

        @media (min-width: 768px) {
            .profile-btn {
                min-height: 56px;
                padding: var(--space-3);
                font-size: 0.75rem;
                gap: var(--space-1);
            }
        }

        .profile-btn:hover {
            background: rgba(0, 209, 255, 0.1);
            border-color: rgba(0, 209, 255, 0.3);
            color: var(--windy-cyan);
        }

        body.light .profile-btn:hover {
            background: rgba(0, 27, 60, 0.1);
            border-color: rgba(0, 27, 60, 0.2);
            color: var(--windy-deep-blue);
        }

        .profile-btn.active {
            background: rgba(0, 209, 255, 0.15);
            border-color: var(--windy-cyan);
            color: var(--windy-cyan);
        }

        body.light .profile-btn.active {
            background: rgba(0, 27, 60, 0.15);
            border-color: var(--windy-deep-blue);
            color: var(--windy-deep-blue);
        }

        .profile-btn .icon {
            font-size: 1rem;
        }


        .profile-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            transition: all 0.2s ease;
        }

        .profile-btn.active svg {
            stroke: var(--windy-cyan);
        }

        body.light .profile-btn.active svg {
            stroke: var(--windy-deep-blue);
        }

        @media (min-width: 768px) {
            .profile-btn .icon {
                font-size: 1.25rem;
            }

            .profile-btn svg {
                width: 24px;
                height: 24px;
            }
        }

        /* ============ WEATHER METRICS ============ */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-3);
        }

        @media (min-width: 640px) {
            .metrics-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .metrics-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        body.light .metric-card {
            background: var(--light-surface);
            border: 1px solid var(--light-border);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .metric-card:hover {
            border-color: rgba(0, 209, 255, 0.2);
            transform: translateY(-2px);
        }

        body.light .metric-card:hover {
            border-color: rgba(0, 27, 60, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .metric-card.metric-warning-hot {
            border-color: rgba(239, 68, 68, 0.4);
            background: rgba(239, 68, 68, 0.08);
        }

        .metric-card.metric-warning-hot .metric-icon {
            color: #EF4444;
        }

        .metric-card.metric-warning-hot .metric-value {
            color: #EF4444;
        }

        .metric-card.metric-warning-cold {
            border-color: rgba(59, 130, 246, 0.4);
            background: rgba(59, 130, 246, 0.08);
        }

        .metric-card.metric-warning-cold .metric-icon {
            color: #3B82F6;
        }

        .metric-card.metric-warning-cold .metric-value {
            color: #3B82F6;
        }

        .metric-icon.wind-direction svg {
            stroke: var(--wind-color, var(--gray-400));
            transition: transform 0.5s ease;
        }

        .metric-icon {
            font-size: 1.5rem;
            margin-bottom: var(--space-2);
            color: var(--windy-cyan);
        }

        body.light .metric-icon {
            color: var(--windy-deep-blue);
        }

        .metric-icon svg {
            width: 28px;
            height: 28px;
            stroke: var(--windy-cyan);
        }

        body.light .metric-icon svg {
            stroke: var(--windy-deep-blue);
        }

        .metric-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #fff;
            line-height: 1;
        }

        body.light .metric-value {
            color: var(--light-text);
        }

        .metric-unit {
            font-size: 0.8rem;
            color: var(--gray-400);
            margin-left: var(--space-1);
        }

        body.light .metric-unit {
            color: var(--light-text);
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: var(--space-2);
        }

        body.light .metric-label {
            color: var(--light-text);
        }

        /* ============ METRIC TOOLTIP (Contextual Overlay) ============ */
        .metric-tooltip {
            position: absolute;
            z-index: 1000;
            background: rgba(0, 27, 60, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            min-width: 280px;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .metric-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .metric-tooltip-header {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-3);
            padding-bottom: var(--space-3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-tooltip-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            background: rgba(0, 209, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--windy-cyan);
            flex-shrink: 0;
        }

        .metric-tooltip-icon svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }

        .metric-tooltip-title {
            flex: 1;
        }

        .metric-tooltip-title h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: var(--space-1);
        }

        body.light .metric-tooltip-title h4 {
            color: var(--light-text);
        }

        .metric-tooltip-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--windy-cyan);
            line-height: 1;
        }

        .metric-tooltip-body {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .metric-tooltip-item {
            display: flex;
            align-items: flex-start;
            gap: var(--space-2);
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .metric-tooltip-item-icon {
            width: 18px;
            height: 18px;
            margin-top: 2px;
            flex-shrink: 0;
            color: var(--windy-cyan);
        }

        .metric-tooltip-item-icon svg {
            width: 100%;
            height: 100%;
            stroke: currentColor;
        }

        .metric-tooltip-item-content {
            flex: 1;
        }

        .metric-tooltip-item-label {
            color: var(--gray-400);
            font-weight: 500;
            margin-bottom: var(--space-1);
        }

        body.light .metric-tooltip-item-label {
            color: var(--light-text);
        }

        .metric-tooltip-item-value {
            color: #fff;
        }

        body.light .metric-tooltip-item-value {
            color: var(--light-text);
        }

        .metric-tooltip-trend {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: var(--space-2);
        }

        .metric-tooltip-trend.up {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .metric-tooltip-trend.down {
            background: rgba(59, 130, 246, 0.2);
            color: #3B82F6;
        }

        .metric-tooltip-trend.neutral {
            background: rgba(156, 163, 175, 0.2);
            color: var(--gray-400);
        }

        body.light .metric-tooltip-trend.neutral {
            color: var(--light-text);
        }

        .metric-tooltip-insight {
            margin-top: var(--space-2);
            padding: var(--space-3);
            background: rgba(0, 209, 255, 0.1);
            border-left: 3px solid var(--windy-cyan);
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            color: var(--gray-300);
            line-height: 1.5;
        }

        body.light .metric-tooltip-insight {
            background: rgba(0, 27, 60, 0.05);
            border-left-color: var(--windy-deep-blue);
            color: var(--light-text);
        }

        /* Posicionamiento contextual */
        .metric-tooltip.top {
            bottom: calc(100% + var(--space-3));
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
        }

        .metric-tooltip.top.visible {
            transform: translateX(-50%) translateY(0);
        }

        .metric-tooltip.bottom {
            top: calc(100% + var(--space-3));
            left: 50%;
            transform: translateX(-50%) translateY(10px);
        }

        .metric-tooltip.bottom.visible {
            transform: translateX(-50%) translateY(0);
        }

        .metric-tooltip.right {
            left: calc(100% + var(--space-3));
            top: 50%;
            transform: translateY(-50%) translateX(10px);
        }

        .metric-tooltip.right.visible {
            transform: translateY(-50%) translateX(0);
        }

        .metric-tooltip.left {
            right: calc(100% + var(--space-3));
            top: 50%;
            transform: translateY(-50%) translateX(-10px);
        }

        .metric-tooltip.left.visible {
            transform: translateY(-50%) translateX(0);
        }

        @media (max-width: 768px) {
            .metric-tooltip {
                min-width: calc(100vw - 32px);
                max-width: calc(100vw - 32px);
                width: calc(100vw - 32px);
                left: 16px !important;
                right: 16px !important;
                transform: none !important;
                position: fixed !important;
                top: auto !important;
                bottom: 16px !important;
                margin: 0 !important;
                max-height: 50vh;
                overflow-y: auto;
                z-index: 10000;
            }

            .metric-tooltip.top,
            .metric-tooltip.bottom,
            .metric-tooltip.left,
            .metric-tooltip.right {
                transform: none !important;
                left: 16px !important;
                right: 16px !important;
                top: auto !important;
                bottom: 16px !important;
            }

            .metric-tooltip-header {
                padding: var(--space-2);
            }

            .metric-tooltip-icon {
                width: 32px;
                height: 32px;
            }

            .metric-tooltip-icon svg {
                width: 20px;
                height: 20px;
            }

            .metric-tooltip-title h4 {
                font-size: 0.85rem;
            }

            .metric-tooltip-value {
                font-size: 1.25rem;
            }

            .metric-tooltip-body {
                padding: var(--space-2) 0;
            }

            .metric-tooltip-item {
                font-size: 0.85rem;
            }

            .metric-tooltip-insight {
                font-size: 0.8rem;
                padding: var(--space-2);
            }
        }

        /* ============ SOLAR INFO CARD ============ */
        .solar-card {
            background: linear-gradient(135deg, rgba(255, 184, 0, 0.08) 0%, rgba(255, 140, 0, 0.05) 100%);
            border: 1px solid rgba(255, 184, 0, 0.2);
        }

        body.light .solar-card {
            background: linear-gradient(135deg, rgba(255, 184, 0, 0.05) 0%, rgba(255, 140, 0, 0.02) 100%);
            border: 1px solid rgba(255, 184, 0, 0.15);
        }

        .solar-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-3);
        }

        @media (min-width: 768px) {
            .solar-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .solar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3);
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-md);
            transition: all 0.2s ease;
        }

        body.light .solar-item {
            background: rgba(0, 27, 60, 0.02);
        }

        .solar-item:hover {
            background: rgba(255, 255, 255, 0.04);
            transform: translateY(-2px);
        }

        body.light .solar-item:hover {
            background: rgba(0, 27, 60, 0.05);
        }

        .solar-icon {
            width: 32px;
            height: 32px;
            color: #FFB800;
        }

        body.light .solar-icon {
            color: #F59E0B;
        }

        .solar-icon svg {
            width: 100%;
            height: 100%;
            stroke: currentColor;
        }

        .solar-value {
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            text-align: center;
        }

        body.light .solar-value {
            color: var(--light-text);
        }

        .solar-label {
            font-size: 0.7rem;
            color: var(--gray-400);
            text-align: center;
            text-transform: uppercase;
        }

        body.light .solar-label {
            color: var(--light-text);
        }

        .uv-badge {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            font-weight: 600;
        }

        .uv-badge.low {
            background: rgba(16, 185, 129, 0.2);
            color: #10B981;
        }

        body.light .uv-badge.low {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }

        .uv-badge.moderate {
            background: rgba(250, 204, 21, 0.2);
            color: #FACC15;
        }

        body.light .uv-badge.moderate {
            background: rgba(250, 204, 21, 0.1);
            color: #EAB308;
        }

        .uv-badge.high {
            background: rgba(245, 158, 11, 0.2);
            color: #F59E0B;
        }

        body.light .uv-badge.high {
            background: rgba(245, 158, 11, 0.1);
            color: #D97706;
        }

        .uv-badge.very-high {
            background: rgba(249, 115, 22, 0.2);
            color: #F97316;
        }

        body.light .uv-badge.very-high {
            background: rgba(249, 115, 22, 0.1);
            color: #EA580C;
        }

        .uv-badge.extreme {
            background: rgba(220, 38, 38, 0.2);
            color: #DC2626;
        }

        body.light .uv-badge.extreme {
            background: rgba(220, 38, 38, 0.1);
            color: #B91C1C;
        }

        /* ============ ALERT STACK (Floating Cards) ============ */
        .alert-stack-container {
            position: fixed;
            top: var(--space-6);
            right: var(--space-6);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            max-width: 380px;
            width: calc(100% - var(--space-8));
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .alert-stack-container {
                top: auto;
                bottom: var(--space-4);
                right: var(--space-4);
                left: var(--space-4);
                max-width: none;
                width: auto;
            }
        }

        .alert-floating-card {
            background: rgba(0, 27, 60, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }

        .alert-floating-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--alert-color, var(--alert-3));
        }

        .alert-floating-card.level-3 {
            --alert-color: var(--alert-3);
            border-left: 3px solid var(--alert-3);
        }

        .alert-floating-card.level-4 {
            --alert-color: var(--alert-4);
            border-left: 3px solid var(--alert-4);
            animation: slideInRight 0.3s ease-out, pulse-alert 2s infinite;
        }

        .alert-floating-card.fade-out {
            animation: fadeOut 0.2s ease-in forwards;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }

            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        .alert-floating-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: var(--space-3);
            margin-bottom: var(--space-3);
        }

        .alert-floating-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
        }

        .alert-floating-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--alert-color, var(--alert-3));
        }

        .alert-floating-content {
            flex: 1;
            min-width: 0;
        }

        .alert-floating-level {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--alert-color, var(--alert-3));
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-1);
        }

        .alert-floating-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: var(--space-1);
            line-height: 1.3;
        }

        body.light .alert-floating-title {
            color: var(--light-text);
        }

        .alert-floating-description {
            font-size: 0.8rem;
            color: var(--gray-400);
            line-height: 1.4;
            margin-bottom: var(--space-2);
        }

        body.light .alert-floating-description {
            color: var(--light-text);
        }

        .alert-floating-meta {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: 0.7rem;
            color: var(--gray-500);
            margin-top: var(--space-2);
            padding-top: var(--space-2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.light .alert-floating-meta {
            color: var(--light-text);
            border-top: 1px solid var(--light-border);
        }

        .alert-floating-meta svg {
            width: 14px;
            height: 14px;
            stroke: currentColor;
        }

        .alert-floating-close {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            width: 24px;
            height: 24px;
            border-radius: var(--radius-sm);
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--gray-400);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .alert-floating-close:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        body.light .alert-floating-close {
            background: rgba(0, 27, 60, 0.1);
            color: var(--light-text);
        }

        body.light .alert-floating-close:hover {
            background: rgba(0, 27, 60, 0.2);
            color: var(--light-text);
        }

        .alert-floating-close svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
        }

        .alert-floating-actions {
            display: flex;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        .alert-floating-btn {
            flex: 1;
            padding: var(--space-2) var(--space-3);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-md);
            color: #fff;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        body.light .alert-floating-btn {
            background: rgba(0, 27, 60, 0.1);
            border-color: rgba(0, 27, 60, 0.2);
            color: var(--light-text);
        }

        .alert-floating-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        body.light .alert-floating-btn:hover {
            background: rgba(0, 27, 60, 0.2);
            border-color: rgba(0, 27, 60, 0.3);
        }

        .alert-floating-btn.primary {
            background: var(--alert-color, var(--alert-3));
            border-color: var(--alert-color, var(--alert-3));
        }

        .alert-floating-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .alert-floating-card {
                padding: var(--space-3);
            }

            .alert-floating-title {
                font-size: 0.85rem;
            }

            .alert-floating-description {
                font-size: 0.75rem;
            }
        }

        /* ============ FORECAST TIMELINE ============ */
        .forecast-timeline {
            display: flex;
            gap: var(--space-2);
            overflow-x: auto;
            padding: var(--space-2) 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 209, 255, 0.3) transparent;
        }

        .forecast-hour {
            flex-shrink: 0;
            width: 70px;
            padding: var(--space-3);
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-md);
            text-align: center;
            transition: all 0.2s ease;
        }

        body.light .forecast-hour {
            background: rgba(0, 27, 60, 0.02);
            border: 1px solid var(--light-border);
        }

        .forecast-hour:hover {
            border-color: rgba(0, 209, 255, 0.3);
            background: rgba(0, 209, 255, 0.05);
        }

        body.light .forecast-hour:hover {
            border-color: rgba(0, 27, 60, 0.2);
            background: rgba(0, 27, 60, 0.05);
        }

        .forecast-hour.current {
            border-color: var(--windy-cyan);
            background: rgba(0, 209, 255, 0.1);
        }

        body.light .forecast-hour.current {
            border-color: var(--windy-deep-blue);
            background: rgba(0, 27, 60, 0.1);
        }

        .forecast-time {
            font-size: 0.7rem;
            color: var(--gray-400);
            margin-bottom: var(--space-2);
        }

        body.light .forecast-time {
            color: var(--light-text);
        }

        .forecast-icon {
            font-size: 1.25rem;
            margin-bottom: var(--space-2);
        }

        body.light .forecast-icon {
            color: var(--windy-deep-blue);
        }

        .forecast-temp {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
        }

        body.light .forecast-temp {
            color: var(--light-text);
        }

        .forecast-precip {
            font-size: 0.65rem;
            color: var(--windy-cyan);
            margin-top: var(--space-1);
        }

        body.light .forecast-precip {
            color: var(--windy-deep-blue);
        }

        /* ============ RECOMMENDATION CARD ============ */
        .recommendation-card {
            background: linear-gradient(135deg, rgba(0, 209, 255, 0.1), rgba(0, 255, 189, 0.05));
            border: 1px solid rgba(0, 209, 255, 0.2);
        }

        body.light .recommendation-card {
            background: linear-gradient(135deg, rgba(0, 27, 60, 0.05), rgba(0, 27, 60, 0.02));
            border: 1px solid rgba(0, 27, 60, 0.15);
        }

        .recommendation-text {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--gray-200);
        }

        body.light .recommendation-text {
            color: var(--light-text);
        }

        .recommendation-action {
            margin-top: var(--space-4);
            padding: var(--space-3) var(--space-4);
            background: rgba(0, 209, 255, 0.15);
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            color: var(--windy-cyan);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        body.light .recommendation-action {
            background: rgba(0, 27, 60, 0.1);
            color: var(--windy-deep-blue);
        }

        /* ============ SOURCE BADGE ============ */
        .source-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: var(--space-1) var(--space-3);
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.25);
            border-radius: var(--radius-full);
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--alert-0);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .source-badge-warning {
            background: rgba(245, 158, 11, 0.15) !important;
            border-color: rgba(245, 158, 11, 0.4) !important;
            color: var(--windy-yellow) !important;
        }

        body.light .source-badge {
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.2);
            color: #059669;
        }

        body.light .source-badge-warning {
            background: rgba(245, 158, 11, 0.12) !important;
            border-color: rgba(245, 158, 11, 0.3) !important;
            color: #D97706 !important;
        }

        .source-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: livePulse 1.5s ease-out infinite;
        }

        @keyframes livePulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* ============ FOOTER PROFESIONAL ============ */
        .footer {
            width: 100%;
            padding: var(--space-4) var(--space-6);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            margin-top: var(--space-4);
            background: rgba(0, 0, 0, 0.2);
            order: 999;
        }

        body.light .footer {
            background: rgba(255, 255, 255, 0.6);
            border-top: 1px solid var(--light-border);
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-5);
        }

        .footer-brand {
            display: flex;
            align-items: center;
            gap: var(--space-4);
        }

        .footer-logo {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px solid rgba(0, 209, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 209, 255, 0.2);
            object-fit: cover;
            transition: all 0.3s ease;
        }

        .footer-logo:hover {
            border-color: var(--windy-cyan);
            box-shadow: 0 4px 30px rgba(0, 209, 255, 0.4);
            transform: scale(1.05);
        }

        .footer-brand-text {
            text-align: left;
        }

        .footer-brand-name {
            font-size: 1.1rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, var(--windy-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.light .footer-brand-name {
            background: linear-gradient(135deg, var(--windy-deep-blue), var(--windy-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .footer-brand-tagline {
            font-size: 0.7rem;
            color: var(--gray-500);
            letter-spacing: 0.05em;
        }

        body.light .footer-brand-tagline {
            color: var(--light-text);
        }

        .footer-links {
            display: flex;
            gap: var(--space-6);
            flex-wrap: wrap;
            justify-content: center;
        }

        .footer-link {
            font-size: 0.8rem;
            color: var(--gray-400);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        body.light .footer-link {
            color: var(--light-text);
        }

        .footer-link:hover {
            color: var(--windy-cyan);
        }

        body.light .footer-link:hover {
            color: var(--windy-deep-blue);
        }

        .footer-divider {
            width: 100%;
            max-width: 400px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }

        body.light .footer-divider {
            background: linear-gradient(90deg, transparent, var(--light-border), transparent);
        }

        .footer-sources {
            font-size: 0.7rem;
            color: var(--gray-500);
            text-align: center;
        }

        body.light .footer-sources {
            color: var(--light-text);
        }

        .footer-sources a {
            color: var(--windy-cyan);
            text-decoration: none;
        }

        body.light .footer-sources a {
            color: var(--windy-deep-blue);
        }

        .disclaimer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            color: var(--windy-yellow);
            font-size: 0.7rem;
            padding: var(--space-3) var(--space-4);
            background: rgba(255, 230, 0, 0.05);
            border-radius: var(--radius-md);
            max-width: 500px;
        }

        body.light .disclaimer {
            color: #B45309;
            background: rgba(255, 230, 0, 0.2);
            border: 1px solid rgba(255, 230, 0, 0.3);
        }


        .footer-copyright {
            font-size: 0.7rem;
            color: var(--gray-600);
        }

        body.light .footer-copyright {
            color: var(--light-text);
        }

        .footer-research-badge {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: rgba(0, 209, 255, 0.1);
            border: 1px solid rgba(0, 209, 255, 0.3);
            border-radius: var(--radius-full);
            color: var(--windy-cyan);
            text-decoration: none;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin-top: var(--space-2);
        }

        body.light .footer-research-badge {
            background: rgba(0, 27, 60, 0.1);
            border: 1px solid rgba(0, 27, 60, 0.2);
            color: var(--windy-deep-blue);
        }

        .footer-research-badge:hover {
            background: rgba(0, 209, 255, 0.15);
            border-color: var(--windy-cyan);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 209, 255, 0.2);
        }

        body.light .footer-research-badge:hover {
            background: rgba(0, 27, 60, 0.15);
            border-color: var(--windy-deep-blue);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .footer-research-badge svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            stroke-width: 1.5;
        }

        /* ============ MODERN LOADER (ScrollXUI Style) ============ */
        .modern-loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            padding: var(--space-8);
            gap: var(--space-6);
        }

        .loader-terminal {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
            border: 1px solid rgba(0, 209, 255, 0.2);
            border-radius: 12px;
            padding: 0;
            width: 100%;
            max-width: 480px;
            box-shadow:
                0 0 40px rgba(0, 209, 255, 0.1),
                0 20px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .loader-terminal-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .loader-terminal-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .loader-terminal-dot.red {
            background: #ff5f56;
        }

        .loader-terminal-dot.yellow {
            background: #ffbd2e;
        }

        .loader-terminal-dot.green {
            background: #27c93f;
        }

        .loader-terminal-title {
            flex: 1;
            text-align: center;
            font-size: 0.75rem;
            color: var(--gray-500);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .loader-terminal-body {
            padding: 20px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.8rem;
            line-height: 1.8;
            min-height: 180px;
        }

        .loader-code-line {
            display: flex;
            gap: 12px;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInLine 0.4s ease forwards;
        }

        .loader-code-line.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .loader-line-number {
            color: var(--gray-600);
            user-select: none;
            min-width: 20px;
            text-align: right;
        }

        .loader-code-content {
            flex: 1;
        }

        .loader-keyword {
            color: #c792ea;
        }

        .loader-function {
            color: #82aaff;
        }

        .loader-string {
            color: #c3e88d;
        }

        .loader-variable {
            color: #f78c6c;
        }

        .loader-comment {
            color: #546e7a;
            font-style: italic;
        }

        .loader-operator {
            color: #89ddff;
        }

        .loader-bracket {
            color: #ffd700;
        }

        .loader-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: var(--windy-cyan);
            margin-left: 2px;
            animation: blink 1s step-end infinite;
            vertical-align: middle;
        }

        .loader-status {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(0, 209, 255, 0.05);
            border-top: 1px solid rgba(0, 209, 255, 0.1);
        }

        .loader-status-dot {
            width: 8px;
            height: 8px;
            background: var(--windy-cyan);
            border-radius: 50%;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }

        .loader-status-text {
            font-size: 0.75rem;
            color: var(--gray-400);
            flex: 1;
        }

        .loader-typing-text {
            overflow: hidden;
            white-space: nowrap;
            border-right: 2px solid var(--windy-cyan);
            animation: typing 2s steps(40) forwards, blink-caret 0.75s step-end infinite;
        }

        .loader-progress {
            width: 100%;
            max-width: 480px;
            height: 3px;
            background: rgba(0, 209, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loader-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--windy-cyan), var(--windy-green-blue));
            width: 0%;
            animation: progress 0.95s ease-out forwards;
            border-radius: 2px;
        }

        @keyframes fadeInLine {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        @keyframes blink-caret {

            0%,
            100% {
                border-color: var(--windy-cyan);
            }

            50% {
                border-color: transparent;
            }
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(0, 209, 255, 0.4);
            }

            50% {
                opacity: 0.6;
                box-shadow: 0 0 0 6px rgba(0, 209, 255, 0);
            }
        }

        @keyframes progress {
            0% {
                width: 0%;
            }

            100% {
                width: 100%;
            }
        }

        @keyframes typing {
            from {
                width: 0;
            }

            to {
                width: 100%;
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-6px);
            }
        }

        /* ============ RESPONSIVE ============ */
        /* Main Grid wrapper */
        .main-grid {
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
        }

        /* ============ TABLET (768px - 1023px) ============ */
        @media (min-width: 768px) and (max-width: 1023px) {
            .main-container {
                padding: var(--space-5);
            }

            .main-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: var(--space-5);
            }

            .alert-banner {
                flex-direction: row;
                flex-wrap: wrap;
                padding: var(--space-4) var(--space-5);
                max-height: none;
            }

            .alert-content {
                flex: 1 1 60%;
                min-width: 300px;
            }

            .alert-meta {
                flex: 0 0 auto;
            }

            .alert-banner>.alert-scale {
                flex: 1 1 100%;
                margin-top: var(--space-3);
                padding-top: var(--space-3);
                border-top: 1px solid rgba(255, 255, 255, 0.08);
                border-left: none;
                padding-left: 0;
            }

            .metrics-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .profile-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .sidebar {
                position: relative;
                top: unset;
            }

            .windy-map-container {
                height: 250px;
            }

            .card {
                padding: var(--space-5);
            }
        }

        /* ============ MOBILE Y TABLET PEQUEÑA (max-width: 1023px) ============ */
        @media (max-width: 1023px) {
            .main-container {
                display: flex !important;
                flex-direction: column !important;
            }

            .main-grid {
                display: flex;
                flex-direction: column;
                gap: var(--space-4);
            }

            .alert-banner {
                order: 1;
            }

            .main-grid {
                order: 2;
            }

            .main-content {
                order: 1;
            }

            .sidebar {
                order: 2;
                position: relative !important;
                top: unset !important;
            }

            .footer {
                order: 999;
            }
        }

        /* ============ SOLO MOBILE (max-width: 767px) ============ */
        @media (max-width: 767px) {
            .windy-map-container {
                height: 200px;
            }
        }

        @media (max-width: 768px) {
            .profile-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .alert-banner {
                flex-direction: column;
                align-items: flex-start;
                padding: var(--space-3);
            }

            .alert-banner .alert-content {
                width: 100%;
            }

            .card {
                padding: var(--space-4);
            }

            .risk-gauge {
                max-width: 140px;
            }

            .risk-score-number {
                font-size: 1.75rem;
            }

            .risk-factors {
                flex-direction: column;
                gap: var(--space-2);
            }

            .risk-factor-bar {
                width: 80px;
            }

            .recommendations-list {
                font-size: 0.8rem;
            }

            .windy-map-container {
                height: 180px;
            }

            .map-layer-btn {
                padding: var(--space-2);
                font-size: 0.75rem;
            }

            .timeline-slider {
                margin: var(--space-2) 0;
            }

            .hour-item {
                min-width: 55px;
                padding: var(--space-2);
            }

            .hour-temp {
                font-size: 1rem;
            }

            .hour-wind {
                font-size: 0.7rem;
            }

            .header-location {
                width: 100%;
                justify-content: center;
            }

            .location-dropdown {
                left: 50%;
                transform: translateX(-50%);
                min-width: 280px;
                max-width: calc(100vw - 32px);
            }

            .location-dropdown.show {
                transform: translateX(-50%) translateY(0);
            }

            .theme-toggle {
                top: var(--space-4);
                right: var(--space-4);
                width: 40px;
                height: 40px;
            }

            .theme-toggle svg {
                width: 20px;
                height: 20px;
            }
        }

        @media (max-width: 480px) {
            .main-container {
                padding: var(--space-3);
                padding-bottom: env(safe-area-inset-bottom, var(--space-3));
                gap: var(--space-3);
            }

            .header {
                padding: var(--space-3) var(--space-4);
                padding-top: max(var(--space-3), env(safe-area-inset-top));
            }

            .profile-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: var(--space-2);
            }

            .profile-btn {
                min-height: 52px;
                padding: var(--space-2);
                font-size: 0.65rem;
            }

            .profile-btn .icon {
                font-size: 1.1rem;
            }

            .metric-card {
                padding: var(--space-3);
            }

            .metric-value {
                font-size: 1.35rem;
            }

            .metric-label {
                font-size: 0.7rem;
            }

            .timeline-hours {
                gap: var(--space-2);
            }

            .hour-item {
                min-width: 52px;
                padding: var(--space-2);
            }

            .hour-label {
                font-size: 0.7rem;
            }

            .hour-temp {
                font-size: 1rem;
            }

            .card-header h3 {
                font-size: 0.85rem;
            }

            .footer-content {
                padding: var(--space-4);
                padding-bottom: max(var(--space-4), env(safe-area-inset-bottom));
            }

            .footer-links {
                flex-direction: row;
                flex-wrap: wrap;
                gap: var(--space-3);
            }

            .footer-link {
                min-height: 44px;
                display: flex;
                align-items: center;
                padding: var(--space-2) var(--space-3);
            }

            .footer-brand-name {
                font-size: 1rem;
            }

            .footer-research-badge {
                font-size: 0.7rem;
                padding: var(--space-2) var(--space-3);
            }

            .footer-research-badge svg {
                width: 14px;
                height: 14px;
            }

            .risk-gauge {
                max-width: 130px;
            }

            .risk-score-number {
                font-size: 1.5rem;
            }

            .alert-level {
                font-size: 0.7rem;
            }

            .alert-title {
                font-size: 0.95rem;
            }

            .forecast-item {
                min-width: 64px;
                padding: var(--space-2);
            }

            .forecast-time {
                font-size: 0.7rem;
            }

            .forecast-temp {
                font-size: 0.9rem;
            }

            .windy-map-container {
                height: 200px;
            }
        }

        /* Safe areas para iPhone con notch */
        @supports (padding: env(safe-area-inset-top)) {
            .header {
                padding-left: max(var(--space-4), env(safe-area-inset-left));
                padding-right: max(var(--space-4), env(safe-area-inset-right));
            }

            .main-container {
                padding-left: max(var(--space-3), env(safe-area-inset-left));
                padding-right: max(var(--space-3), env(safe-area-inset-right));
            }

            .footer {
                padding-bottom: max(var(--space-8), env(safe-area-inset-bottom));
            }
        }
    </style>
</head>

<body>
    <button class="theme-toggle" id="themeToggle" aria-label="Cambiar tema">
        <svg class="sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="5" />
            <line x1="12" y1="1" x2="12" y2="3" />
            <line x1="12" y1="21" x2="12" y2="23" />
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
            <line x1="1" y1="12" x2="3" y2="12" />
            <line x1="21" y1="12" x2="23" y2="12" />
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
        </svg>
        <svg class="moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
        </svg>
    </button>

    <header class="header">
        <div class="header-content">
            <div class="logo">
                <img src="assets/images/logos/Logo.png" alt="SkyPulse" class="logo-img">
                <div class="logo-text">
                    <h1>SkyPulse</h1>
                    <span>Panel de Riesgo Meteorológico</span>
                </div>
            </div>
            <div class="header-location" id="header-location" title="Cambiar ubicación de monitoreo">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" />
                    <circle cx="12" cy="10" r="3" />
                </svg>
                <div class="header-location-text">
                    <span class="header-location-city" id="location-city">Córdoba, Argentina</span>
                    <span class="header-location-coords" id="location-coords">-31.42°N, -64.19°W</span>
                </div>
                <svg class="chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="width: 12px; height: 12px; margin-left: 4px;">
                    <polyline points="6 9 12 15 18 9" />
                </svg>
                <div class="location-dropdown" id="location-dropdown">
                    <!-- Se llena dinámicamente con JavaScript -->
                </div>
            </div>
            <div class="header-right">
                <a href="aviacion-demo.html" class="nav-link">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" width="16" height="16" stroke="currentColor"
                        stroke-width="2" fill="none">
                        <path
                            d="M17.8 19.2 16 11l3.5-3.5C21 6 21.5 4 21 3c-1-.5-3 0-4.5 1.5L13 8 4.8 6.2c-.5-.1-.9.1-1.1.5l-.3.5c-.2.5-.1 1 .3 1.3L9 12l-2 3H4l-1 1 3 2 2 3 1-1v-3l3-2 3.5 5.3c.3.4.8.5 1.3.3l.5-.2c.4-.3.6-.7.5-1.2z" />
                    </svg>
                    Aviación
                </a>
                <div class="time-display">
                    <div class="label">Última actualización</div>
                    <div class="time" id="current-time">Cargando...</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Alert Stack Container (Fixed Position) -->
    <div class="alert-stack-container" id="alert-stack"></div>

    <main class="main-container" id="app">
        <div class="modern-loader" style="grid-column: 1 / -1;">
            <div class="loader-terminal">
                <div class="loader-terminal-header">
                    <div class="loader-terminal-dot red"></div>
                    <div class="loader-terminal-dot yellow"></div>
                    <div class="loader-terminal-dot green"></div>
                    <span class="loader-terminal-title">skypulse — weather-api</span>
                </div>
                <div class="loader-terminal-body" id="loader-code">
                    <!-- Código dinámico -->
                </div>
                <div class="loader-status">
                    <div class="loader-status-dot"></div>
                    <span class="loader-status-text" id="loader-message">Inicializando módulos...</span>
                </div>
            </div>
            <div class="loader-progress">
                <div class="loader-progress-bar"></div>
            </div>
        </div>
    </main>

    <!-- Cliente API SkyPulse (mantenido para compatibilidad) -->
    <!-- Anime.js para animaciones avanzadas -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
    <!-- Utilidades de animación SkyPulse -->
    <script src="js/anime-utils.js"></script>
    <script src="js/api-client.js"></script>

    <!-- Nuevos módulos Frontend-Only -->
    <script src="open-meteo-client.js"></script>
    <script src="meteosource-client.js"></script>
    <script src="alert-engine.js"></script>

    <script>
        // ============ CONFIGURACIÓN ============
        const CONFIG = {
            location: {
                name: 'Córdoba',
                region: 'Córdoba',
                lat: -31.4201,
                lon: -64.1888
            },
            locations: [
                {
                    name: 'Córdoba',
                    region: 'Córdoba',
                    lat: -31.4201,
                    lon: -64.1888,
                    coords: '-31.42°N, -64.19°W'
                },
                {
                    name: 'Resistencia',
                    region: 'Chaco',
                    lat: -27.4606,
                    lon: -58.9839,
                    coords: '-27.46°N, -58.98°W'
                }
            ],
            refreshInterval: 300000, // 5 minutos
            // ============ CONFIGURACIÓN BACKEND ============
            // URL del backend (Render) - Habilitar cuando backend esté activo
            // Para habilitar: descomentar la línea siguiente
            // backendUrl: 'https://skypulsear-api.onrender.com',
            backendUrl: 'https://skypulsear-api.onrender.com',
            apiKey: "demo-key",
            // API Keys para fuentes meteorológicas
            // Open-Meteo: No requiere API key (gratuito, sin límites)
            // Windy: Requerida para fallback (opcional)
            // Meteosource: Requerida para alertas (opcional, puede usar Open-Meteo)
            windyApiKey: null, // ⚠️ Opcional: Para fallback si Open-Meteo falla
            meteosourceApiKey: null // ⚠️ Opcional: Para alertas (puede usar Open-Meteo)
        };

        // ============ INICIALIZACIÓN FRONTEND-ONLY ============
        // Open-Meteo como fuente principal (gratuito, sin API key)
        // Windy como fallback (opcional, requiere API key)
        // Meteosource para alertas (opcional, puede usar Open-Meteo)

        // Intentar obtener API keys desde múltiples fuentes
        let windyApiKey = CONFIG.windyApiKey;
        let meteosourceApiKey = CONFIG.meteosourceApiKey;

        // Windy API Key
        if (!windyApiKey && typeof window !== 'undefined' && window.WINDY_API_KEY) {
            windyApiKey = window.WINDY_API_KEY;
            console.log('[SkyPulse] Windy API key obtenida desde window.WINDY_API_KEY');
        }

        // Meteosource API Key
        if (!meteosourceApiKey && typeof window !== 'undefined' && window.METEOSOURCE_API_KEY) {
            meteosourceApiKey = window.METEOSOURCE_API_KEY;
            console.log('[SkyPulse] Meteosource API key obtenida desde window.METEOSOURCE_API_KEY');
        }

        // Inicializar cliente Open-Meteo (principal) con fallback a Windy
        let openMeteoClient = null;
        let meteosourceClient = null;
        let alertEngine = null;
        let alertRules = null;

        // Función para inicializar clientes (sincrónica para evitar race conditions)
        const initializeClients = () => {
            try {
                // Inicializar Open-Meteo (principal) con fallback a Windy
                openMeteoClient = new OpenMeteoClient(windyApiKey);
                console.log('[SkyPulse] ✅ Cliente Open-Meteo inicializado' + (windyApiKey ? ' (con fallback Windy)' : ' (sin fallback)'));
            } catch (error) {
                console.error('[SkyPulse] Error inicializando cliente Open-Meteo:', error);
            }

            // Inicializar Meteosource (opcional, para alertas)
            if (meteosourceApiKey) {
                try {
                    meteosourceClient = new MeteosourceClient(meteosourceApiKey);
                    console.log('[SkyPulse] ✅ Cliente Meteosource inicializado (para alertas)');
                } catch (error) {
                    console.error('[SkyPulse] Error inicializando cliente Meteosource:', error);
                }
            } else {
                console.log('[SkyPulse] ⚠️ Meteosource no configurado, usando Open-Meteo para alertas');
            }
        };

        // Inicializar clientes inmediatamente (sincrónico)
        initializeClients();

        // Cargar reglas de alertas de forma asíncrona
        (async () => {
            try {
                const rulesResponse = await fetch('alert-rules.json');
                alertRules = await rulesResponse.json();
                alertEngine = new AlertEngine(alertRules);
                console.log('[SkyPulse] Motor de alertas inicializado');
            } catch (error) {
                console.error('[SkyPulse] Error cargando reglas de alertas:', error);
            }
        })();

        // ============ CLIENTE API BACKEND ============
        // Habilitar cuando backend esté activo
        let api = null;
        if (CONFIG.backendUrl) {
            try {
                api = new SkyPulseAPI(CONFIG.backendUrl, CONFIG.apiKey);
                console.log('[SkyPulse] ✅ Cliente API backend inicializado:', CONFIG.backendUrl);
            } catch (error) {
                console.warn('[SkyPulse] ⚠️ Error inicializando cliente API backend:', error);
            }
        } else {
            console.log('[SkyPulse] ⚠️ Backend URL no configurado, usando cálculo local');
        }

        // ============ CACHE SYSTEM (TTL 30 min) con localStorage ============
        const CACHE_TTL = 30 * 60 * 1000; // 30 minutos en ms
        const CACHE_KEY = 'skypulse_weather_cache';
        const dashboardCache = {
            data: null,
            timestamp: null,
            locationKey: null // Clave para validar que el cache corresponde a la ubicación actual
        };

        // Cargar cache desde localStorage al inicio
        try {
            const storedCache = localStorage.getItem(CACHE_KEY);
            if (storedCache) {
                const parsed = JSON.parse(storedCache);
                dashboardCache.data = parsed.data;
                dashboardCache.timestamp = parsed.timestamp;
                dashboardCache.locationKey = parsed.locationKey;
                console.log('[Cache] Cache cargado desde localStorage');
            }
        } catch (e) {
            console.warn('[Cache] Error cargando cache desde localStorage:', e);
        }

        const getFromCache = () => {
            // Primero verificar cache en memoria
            if (dashboardCache.data) {
                // Verificar que el cache corresponde a la ubicación actual
                if (dashboardCache.locationKey !== `${CONFIG.location.lat}-${CONFIG.location.lon}`) {
                    console.log('[Cache] Ubicación cambió, invalidando cache');
                    dashboardCache.data = null;
                    dashboardCache.timestamp = null;
                    dashboardCache.locationKey = null;
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }
                const now = Date.now();
                if (now - dashboardCache.timestamp > CACHE_TTL) {
                    console.log('[Cache] Cache expirado');
                    dashboardCache.data = null;
                    dashboardCache.timestamp = null;
                    dashboardCache.locationKey = null;
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }
                return dashboardCache.data;
            }

            // Si no hay en memoria, intentar desde localStorage
            try {
                const storedCache = localStorage.getItem(CACHE_KEY);
                if (storedCache) {
                    const parsed = JSON.parse(storedCache);
                    const locationKey = `${CONFIG.location.lat}-${CONFIG.location.lon}`;

                    if (parsed.locationKey === locationKey) {
                        const now = Date.now();
                        if (now - parsed.timestamp <= CACHE_TTL) {
                            // Restaurar en memoria
                            dashboardCache.data = parsed.data;
                            dashboardCache.timestamp = parsed.timestamp;
                            dashboardCache.locationKey = parsed.locationKey;
                            console.log('[Cache] Cache restaurado desde localStorage');
                            return parsed.data;
                        } else {
                            localStorage.removeItem(CACHE_KEY);
                        }
                    }
                }
            } catch (e) {
                console.warn('[Cache] Error leyendo localStorage:', e);
            }

            return null;
        };

        const setToCache = (data) => {
            dashboardCache.data = data;
            dashboardCache.timestamp = Date.now();
            dashboardCache.locationKey = `${CONFIG.location.lat}-${CONFIG.location.lon}`;

            // Guardar también en localStorage
            try {
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    data: data,
                    timestamp: dashboardCache.timestamp,
                    locationKey: dashboardCache.locationKey
                }));
                console.log('[Cache] Cache guardado en localStorage');
            } catch (e) {
                console.warn('[Cache] Error guardando en localStorage:', e);
            }
        };

        const clearCache = () => {
            dashboardCache.data = null;
            dashboardCache.timestamp = null;
            dashboardCache.locationKey = null;
        };

        const getCacheAge = () => {
            if (!dashboardCache.timestamp) return null;
            return Math.floor((Date.now() - dashboardCache.timestamp) / 60000);
        };

        // ============ ICONOS SVG PROFESIONALES ============
        const PROFILE_ICONS = {
            pilot: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M17.8 19.2 16 11l3.5-3.5C21 6 21.5 4 21 3c-1-.5-3 0-4.5 1.5L13 8 4.8 6.2c-.5-.1-.9.1-1.1.5l-.3.5c-.2.5-.1 1 .3 1.3L9 12l-2 3H4l-1 1 3 2 2 3 1-1v-3l3-2 3.5 5.3c.3.4.8.5 1.3.3l.5-.2c.4-.3.6-.7.5-1.2z"/></svg>',
            trucker: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="3" width="15" height="13" rx="2"/><path d="M16 8h4l3 5v5h-7V8z"/><circle cx="5.5" cy="18.5" r="2.5"/><circle cx="18.5" cy="18.5" r="2.5"/></svg>',
            farmer: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 2a3 3 0 0 0-3 3c0 1.5 1 2.5 1 4H8c-1.5 0-3 1-3 3v2h14v-2c0-2-1.5-3-3-3h-2c0-1.5 1-2.5 1-4a3 3 0 0 0-3-3z"/><path d="M5 14v8h14v-8"/><path d="M9 18h6"/></svg>',
            outdoor_sports: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="17" cy="4" r="2"/><path d="m15 21-3-3-3 3"/><path d="m21 15-3-3-4 1-3-4-3 1"/><path d="m3 21 3-9 4 1"/></svg>',
            outdoor_event: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 21h18"/><path d="M5 21V7l7-4 7 4v14"/><path d="M9 21v-6h6v6"/><path d="M9 3v4"/><path d="M15 3v4"/></svg>',
            construction: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 20h20"/><path d="M5 20v-6l7-7 7 7v6"/><path d="M9 20v-4h6v4"/><rect x="6" y="2" width="12" height="4" rx="1"/></svg>',
            tourism: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>',
            general: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>'
        };

        // ============ PERFILES DE USUARIO ============
        const PROFILES = {
            general: { name: 'General', icon: PROFILE_ICONS.general, weights: { temp: 0.25, wind: 0.25, precip: 0.25, pattern: 0.25 } },
            pilot: { name: 'Aviación', icon: PROFILE_ICONS.pilot, weights: { temp: 0.1, wind: 0.4, precip: 0.25, pattern: 0.25 }, link: 'aviacion-demo.html' },
            trucker: { name: 'Camionero', icon: PROFILE_ICONS.trucker, weights: { temp: 0.15, wind: 0.3, precip: 0.35, pattern: 0.2 } },
            farmer: { name: 'Agricultor', icon: PROFILE_ICONS.farmer, weights: { temp: 0.3, wind: 0.15, precip: 0.3, pattern: 0.25 } },
            outdoor_sports: { name: 'Deporte', icon: PROFILE_ICONS.outdoor_sports, weights: { temp: 0.3, wind: 0.25, precip: 0.3, pattern: 0.15 } },
            outdoor_event: { name: 'Evento', icon: PROFILE_ICONS.outdoor_event, weights: { temp: 0.2, wind: 0.25, precip: 0.35, pattern: 0.2 } },
            construction: { name: 'Construcción', icon: PROFILE_ICONS.construction, weights: { temp: 0.2, wind: 0.35, precip: 0.25, pattern: 0.2 } },
            tourism: { name: 'Turismo', icon: PROFILE_ICONS.tourism, weights: { temp: 0.15, wind: 0.15, precip: 0.25, pattern: 0.45 } }
        };

        let currentProfile = 'general';
        let weatherData = null;

        // ============ UTILIDADES ============

        // ============ HELPER FUNCTIONS - SEGURIDAD ============
        /**
         * Escapa HTML para prevenir XSS
         * @param {string} text - Texto a escapar
         * @returns {string} Texto escapado
         */
        const escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        /**
         * Crea un elemento de forma segura
         * @param {string} tag - Nombre del tag
         * @param {Object} attributes - Atributos del elemento
         * @param {string|Node|Array} content - Contenido (texto, nodo o array de nodos)
         * @returns {HTMLElement} Elemento creado
         */
        const createSafeElement = (tag, attributes = {}, content = null) => {
            const element = document.createElement(tag);

            // Agregar atributos
            for (const [key, value] of Object.entries(attributes)) {
                if (key === 'className') {
                    element.className = value;
                } else if (key === 'dataset') {
                    for (const [dataKey, dataValue] of Object.entries(value)) {
                        element.dataset[dataKey] = dataValue;
                    }
                } else if (key.startsWith('on')) {
                    // No permitir event handlers inline
                    console.warn(`Event handler inline detectado: ${key}. Usar addEventListener en su lugar.`);
                } else {
                    element.setAttribute(key, value);
                }
            }

            // Agregar contenido
            if (content !== null) {
                if (typeof content === 'string') {
                    element.textContent = content;
                } else if (content instanceof Node) {
                    element.appendChild(content);
                } else if (Array.isArray(content)) {
                    content.forEach(item => {
                        if (item instanceof Node) {
                            element.appendChild(item);
                        } else if (typeof item === 'string') {
                            element.appendChild(document.createTextNode(item));
                        }
                    });
                }
            }

            return element;
        };

        /**
         * Crea SVG de forma segura desde string
         * @param {string} svgString - String del SVG
         * @returns {DocumentFragment} Fragmento con el SVG
         */
        const createSafeSVG = (svgString) => {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;
            const fragment = document.createDocumentFragment();
            fragment.appendChild(svgElement);
            return fragment;
        };
        const formatTime = (date) => date.toLocaleTimeString('es-AR', {
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });

        const updateClock = () => {
            const now = new Date();
            document.getElementById('current-time').textContent = now.toLocaleString('es-AR', {
                day: 'numeric', month: 'short', year: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        };

        // ============ UTILIDADES SOLARES ============
        const formatSolarTime = (isoString) => {
            if (!isoString) return '--:--';
            const date = new Date(isoString);
            return date.toLocaleTimeString('es-AR', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
        };

        const calculateDayDuration = (sunrise, sunset) => {
            if (!sunrise || !sunset) return '--:--';
            const start = new Date(sunrise);
            const end = new Date(sunset);
            const diff = end - start;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        };

        const getUVCategory = (uvIndex) => {
            if (!uvIndex && uvIndex !== 0) return { label: 'N/A', class: 'low' };
            if (uvIndex >= 11) return { label: 'Extremo', class: 'extreme' };
            if (uvIndex >= 8) return { label: 'Muy Alto', class: 'very-high' };
            if (uvIndex >= 6) return { label: 'Alto', class: 'high' };
            if (uvIndex >= 3) return { label: 'Moderado', class: 'moderate' };
            return { label: 'Bajo', class: 'low' };
        };

        // ============ FETCH DATOS METEOROLÓGICOS ============
        // ============ FRONTEND-ONLY: Meteosource + AlertEngine ============

        /**
         * Obtiene datos meteorológicos actuales desde Open-Meteo (frontend-only).
         * Backend pausado temporalmente.
         */
        const fetchCurrentWeather = async () => {
            // Esta función ya no se usa directamente, se obtiene desde Open-Meteo en fetchWeatherData
            // Mantenida para compatibilidad
            return null;
        };

        /**
         * Obtiene pronóstico futuro desde Open-Meteo (frontend-only).
         * Backend pausado - migrando a WRF-SMN desde AWS S3.
         */
        const fetchForecast = async (hours = 24) => {
            // Esta función ya no se usa directamente, se obtiene desde Open-Meteo en fetchWeatherData
            // Mantenida para compatibilidad
            // FUTURO: Usar WRF-SMN desde AWS S3 cuando esté implementado
            return { forecast: [], hours: hours, sources: ['open_meteo'] };
        };

        /**
         * Calcula risk score (frontend-only, calculado localmente).
         * Backend pausado - toda la lógica está en calculateRisks().
         * 
         * NOTA: Esta función es solo para compatibilidad. El cálculo real se hace en calculateRisks().
         */
        const fetchRiskScore = async (profile, hoursAhead = 6) => {
            // Risk score se calcula localmente en calculateRisks() (línea ~4185)
            // Retornar estructura básica para compatibilidad
            return {
                score: 0, // Se calculará después con calculateRisks()
                level: 'normal',
                apparent_temperature: null,
                details: {}
            };
        };

        /**
         * Obtiene alertas usando AlertEngine con datos de Meteosource (frontend-only).
         * Backend pausado temporalmente.
         */
        const fetchAlerts = async (hours = 24) => {
            // Retornar alerta normal por defecto (sin errores)
            const defaultAlert = {
                alerts: [{
                    level: 0,
                    level_name: 'Normal',
                    phenomenon: 'condiciones estables',
                    description: 'Sin fenómenos meteorológicos significativos.',
                    time_window: 'Próximas 24-72 horas',
                    recommendation: 'Sin acción requerida.'
                }],
                max_level: 0,
                max_level_name: 'Normal'
            };

            // Si no tenemos AlertEngine, retornar alerta normal
            if (!alertEngine || !alertRules) {
                console.log('[AlertEngine] Motor no inicializado, usando alerta por defecto');
                return defaultAlert;
            }

            const { lat, lon } = CONFIG.location;

            try {
                // Obtener pronóstico horario (prioridad: Meteosource > Open-Meteo)
                let hourlyData;
                try {
                    // Intentar Meteosource primero (si está disponible)
                    if (meteosourceClient) {
                        hourlyData = await Promise.race([
                            meteosourceClient.getHourlyForecast(lat, lon, hours),
                            new Promise((_, reject) =>
                                setTimeout(() => reject(new Error('Timeout')), 10000)
                            )
                        ]);
                        console.log('[AlertEngine] Datos obtenidos desde Meteosource');
                    }
                    // Fallback a Open-Meteo
                    else if (openMeteoClient) {
                        hourlyData = await Promise.race([
                            openMeteoClient.getHourlyForecast(lat, lon, hours, 'ecmwf_ifs04'),
                            new Promise((_, reject) =>
                                setTimeout(() => reject(new Error('Timeout')), 10000)
                            )
                        ]);
                        console.log('[AlertEngine] Datos obtenidos desde Open-Meteo');
                    } else {
                        console.warn('[AlertEngine] No hay cliente disponible');
                        return defaultAlert;
                    }
                } catch (fetchError) {
                    console.warn('[AlertEngine] Error obteniendo datos:', fetchError.message);
                    return defaultAlert;
                }

                if (!hourlyData || hourlyData.length === 0) {
                    console.warn('[AlertEngine] No se obtuvieron datos de pronóstico');
                    return defaultAlert;
                }

                // Evaluar alertas con el motor
                const alerts = alertEngine.evaluateForecast(hourlyData, hours);

                if (!alerts || alerts.length === 0) {
                    return defaultAlert;
                }

                // Convertir a formato compatible con código existente
                const maxLevel = alertEngine.getMaxLevel(alerts);
                const maxLevelName = (alertRules.alert_levels && alertRules.alert_levels[maxLevel.toString()])
                    ? alertRules.alert_levels[maxLevel.toString()].name
                    : 'Normal';

                return {
                    alerts: alerts.map(alert => ({
                        level: alert.level || 0,
                        level_name: alert.levelName || 'Normal',
                        phenomenon: alert.phenomenon || 'condiciones estables',
                        description: alert.description || 'Sin fenómenos meteorológicos significativos.',
                        time_window: alert.timeWindow || 'Próximas 24-72 horas',
                        recommendation: alert.recommendation || 'Sin acción requerida.'
                    })),
                    max_level: maxLevel || 0,
                    max_level_name: maxLevelName
                };
            } catch (error) {
                console.error('[AlertEngine] Error generando alertas:', error);
                // Retornar alerta normal si falla (no lanzar error)
                return defaultAlert;
            }
        };

        /**
         * Obtiene todos los datos necesarios desde Open-Meteo (frontend-only).
         * Backend pausado - migrando a WRF-SMN desde AWS S3.
         * 
         * Estado actual:
         * - Datos meteorológicos: Open-Meteo (gratuito) con fallback a Windy
         * - Alertas: AlertEngine con Open-Meteo o Meteosource (si está configurado)
         * - Risk scoring: calculateRisks() en frontend (completamente funcional)
         * 
         * NOTA: Open-Meteo no es ideal para Córdoba, Argentina, pero es la solución
         * temporal hasta configurar NetCDF para WRF-SMN.
         * 
         * Próximo paso: Integrar WRF-SMN desde AWS S3 para mejor precisión en tormentas
         */
        const fetchWeatherData = async (forceRefresh = false) => {
            // Verificar cache primero
            if (!forceRefresh) {
                const cached = getFromCache();
                if (cached) {
                    const age = getCacheAge();
                    console.log(`[Cache] Usando datos cacheados (${age} min)`);
                    return cached;
                }
            }

            // Función helper para crear datos de ejemplo
            const createExampleData = () => {
                const { lat, lon } = CONFIG.location;
                const now = new Date();
                return {
                    current: {
                        temperature_2m: 22,
                        apparent_temperature: 23,
                        relative_humidity_2m: 65,
                        wind_speed_10m: 15,
                        wind_direction_10m: 180,
                        wind_gusts_10m: 20,
                        precipitation: 0,
                        weather_code: 0,
                        cloud_cover: 30,
                        surface_pressure: 1013,
                        uv_index: 5,
                        time: now.toISOString()
                    },
                    hourly: {
                        time: Array.from({ length: 24 }, (_, i) => {
                            const date = new Date(now);
                            date.setHours(now.getHours() + i);
                            return date.toISOString();
                        }),
                        temperature_2m: Array(24).fill(22),
                        apparent_temperature: Array(24).fill(23),
                        precipitation_probability: Array(24).fill(0),
                        precipitation: Array(24).fill(0),
                        weather_code: Array(24).fill(0),
                        wind_speed_10m: Array(24).fill(15)
                    },
                    daily: {
                        sunrise: [new Date(now.setHours(6, 0, 0, 0)).toISOString()],
                        sunset: [new Date(now.setHours(20, 0, 0, 0)).toISOString()],
                        uv_index_max: [5]
                    },
                    frontend: {
                        riskScore: {
                            score: 0,
                            level: 'normal',
                            apparent_temperature: 23,
                            details: {}
                        },
                        alerts: {
                            alerts: [{
                                level: 0,
                                level_name: 'Normal',
                                phenomenon: 'Sin conexión',
                                description: 'No se pudo conectar con la API. Mostrando datos de ejemplo.',
                                time_window: 'Modo offline',
                                recommendation: 'Verifica tu conexión a internet y recarga la página.'
                            }],
                            max_level: 0,
                            max_level_name: 'Normal'
                        },
                        source: 'offline_example'
                    }
                };
            };

            const { lat, lon } = CONFIG.location;

            // ============ PRIORIDAD 1: BACKEND API ============
            // Intentar obtener datos del backend primero (si está configurado)
            if (api && CONFIG.backendUrl) {
                try {
                    console.log(`[Backend] Intentando obtener datos meteorológicos para (${lat}, ${lon})...`);

                    // Obtener datos actuales y pronóstico desde el backend
                    const [currentWeather, forecast] = await Promise.all([
                        api.getCurrentWeather(lat, lon).catch((err) => {
                            console.warn('[Backend] Error obteniendo datos actuales:', err.message);
                            throw err;
                        }),
                        api.getForecast(lat, lon, 48).catch((err) => {
                            console.warn('[Backend] Error obteniendo pronóstico:', err.message);
                            throw err;
                        })
                    ]);

                    console.log('[Backend] ✅ Datos obtenidos correctamente desde el backend:', {
                        current: currentWeather.temperature,
                        forecast: forecast.forecast?.length || 0
                    });

                    // Convertir respuesta del backend al formato del frontend
                    const backendData = {
                        current: {
                            temperature_2m: currentWeather.temperature,
                            apparent_temperature: currentWeather.temperature, // Backend no tiene apparent_temperature separado
                            relative_humidity_2m: currentWeather.humidity,
                            wind_speed_10m: currentWeather.wind_speed,
                            wind_direction_10m: currentWeather.wind_direction,
                            wind_gusts_10m: currentWeather.wind_speed * 1.2, // Aproximación
                            precipitation: currentWeather.precipitation || 0,
                            weather_code: currentWeather.weather_code || 0,
                            cloud_cover: currentWeather.cloud_cover,
                            surface_pressure: currentWeather.pressure ? currentWeather.pressure * 100 : 1013, // Convertir hPa a Pa
                            uv_index: 5, // No disponible en backend actual
                            time: currentWeather.timestamp
                        },
                        hourly: {
                            time: forecast.forecast?.map(f => f.timestamp) || [],
                            temperature_2m: forecast.forecast?.map(f => f.temperature) || [],
                            apparent_temperature: forecast.forecast?.map(f => f.temperature) || [], // Aproximación
                            precipitation_probability: forecast.forecast?.map(() => 0) || [], // No disponible
                            precipitation: forecast.forecast?.map(f => f.precipitation || 0) || [],
                            weather_code: forecast.forecast?.map(() => 0) || [], // No disponible
                            wind_speed_10m: forecast.forecast?.map(f => f.wind_speed) || []
                        },
                        daily: {
                            sunrise: [],
                            sunset: [],
                            uv_index_max: []
                        }
                    };

                    // Procesar alertas desde el backend
                    const alerts = await api.getAlerts(lat, lon, 24).catch(() => ({
                        alerts: [{ level: 0, level_name: 'Normal', phenomenon: 'condiciones estables', description: 'Sin fenómenos meteorológicos significativos.', time_window: 'Próximas 24-72 horas', recommendation: 'Sin acción requerida.' }],
                        max_level: 0,
                        max_level_name: 'Normal'
                    }));

                    const data = {
                        current: backendData.current,
                        hourly: backendData.hourly,
                        daily: backendData.daily,
                        frontend: {
                            riskScore: { score: 0, level: 'normal', apparent_temperature: backendData.current.apparent_temperature, details: {} },
                            alerts: alerts,
                            source: 'backend'
                        }
                    };

                    setToCache(data);
                    return data;

                } catch (backendError) {
                    const errorMsg = backendError.message || String(backendError);

                    // Si el error es 503 (Service Unavailable), significa que el backend no tiene fuentes configuradas
                    if (errorMsg.includes('503') || errorMsg.includes('Service Unavailable')) {
                        console.warn('[Backend] ⚠️ Backend no tiene fuentes de datos configuradas (503)');
                        console.warn('[Backend] El backend necesita API keys configuradas (WINDY_POINT_FORECAST_API_KEY, etc.)');
                        console.warn('[Backend] Usando Open-Meteo como fallback...');
                    } else {
                        console.warn('[Backend] ⚠️ Error obteniendo datos del backend, usando fallback a Open-Meteo:', backendError);
                    }
                    // Continuar con Open-Meteo como fallback
                }
            }

            // ============ PRIORIDAD 2: OPEN-METEO (FALLBACK) ============
            // Intentar usar OpenMeteoClient (con fallback a Windy automático)
            if (!openMeteoClient) {
                console.error('[Open-Meteo] ❌ Cliente no inicializado, intentando reinicializar...');
                // Intentar reinicializar
                try {
                    openMeteoClient = new OpenMeteoClient(windyApiKey);
                    console.log('[Open-Meteo] ✅ Cliente reinicializado');
                } catch (initError) {
                    console.error('[Open-Meteo] ❌ Error al reinicializar cliente:', initError);
                    console.warn('[Open-Meteo] Usando datos de ejemplo como último recurso');
                    return createExampleData();
                }
            }

            try {
                console.log(`[Open-Meteo] Obteniendo datos para (${lat}, ${lon})...`);

                // Obtener datos actuales y pronóstico desde Open-Meteo (con fallback a Windy)
                const [currentData, hourlyForecast] = await Promise.all([
                    openMeteoClient.getCurrentWeather(lat, lon, 'ecmwf_ifs04').catch((err) => {
                        console.warn('[Open-Meteo] ECMWF falló, intentando GFS:', err.message);
                        return openMeteoClient.getCurrentWeather(lat, lon, 'gfs_seamless');
                    }),
                    openMeteoClient.getHourlyForecast(lat, lon, 48, 'ecmwf_ifs04').catch((err) => {
                        console.warn('[Open-Meteo] ECMWF forecast falló, intentando GFS:', err.message);
                        return openMeteoClient.getHourlyForecast(lat, lon, 48, 'gfs_seamless');
                    })
                ]);

                console.log('[Open-Meteo] ✅ Datos obtenidos correctamente:', {
                    current: currentData.temperature,
                    hourly: hourlyForecast.length
                });

                // Convertir a formato compatible con código existente
                const openMeteoData = {
                    current: {
                        temperature_2m: currentData.temperature,
                        apparent_temperature: currentData.temperature, // Aproximación
                        relative_humidity_2m: currentData.humidity,
                        wind_speed_10m: currentData.wind_speed,
                        wind_direction_10m: currentData.wind_direction,
                        wind_gusts_10m: currentData.wind_speed * 1.2, // Aproximación
                        precipitation: currentData.precipitation,
                        weather_code: currentData.weather_code,
                        cloud_cover: currentData.cloud_cover,
                        surface_pressure: currentData.pressure ? currentData.pressure * 100 : 1013, // Convertir hPa a Pa
                        uv_index: 5, // No disponible en Open-Meteo current
                        time: currentData.timestamp
                    },
                    hourly: {
                        time: hourlyForecast.map(item => item.date),
                        temperature_2m: hourlyForecast.map(item => item.temperature),
                        apparent_temperature: hourlyForecast.map(item => item.temperature), // Aproximación
                        precipitation_probability: hourlyForecast.map(() => 0), // No disponible
                        precipitation: hourlyForecast.map(item => item.precipitation_mm || 0),
                        weather_code: hourlyForecast.map(item => item.weather_code),
                        wind_speed_10m: hourlyForecast.map(item => item.wind_speed)
                    },
                    daily: {
                        // Obtener datos diarios desde Open-Meteo
                        sunrise: [], // Se obtendrá en próxima versión
                        sunset: [],
                        uv_index_max: []
                    }
                };

                // Procesar alertas (usar Open-Meteo si Meteosource no está disponible)
                const alerts = await fetchAlerts(24).catch(() => ({
                    alerts: [{ level: 0, level_name: 'Normal', phenomenon: 'condiciones estables', description: 'Sin fenómenos meteorológicos significativos.', time_window: 'Próximas 24-72 horas', recommendation: 'Sin acción requerida.' }],
                    max_level: 0,
                    max_level_name: 'Normal'
                }));

                const data = {
                    current: openMeteoData.current,
                    hourly: openMeteoData.hourly,
                    daily: openMeteoData.daily,
                    frontend: {
                        riskScore: { score: 0, level: 'normal', apparent_temperature: openMeteoData.current.apparent_temperature, details: {} },
                        alerts: alerts,
                        source: currentData.source || 'open-meteo' // Fallback cuando backend no está disponible
                    }
                };

                setToCache(data);
                return data;

            } catch (error) {
                // Cualquier error - usar fallback INMEDIATAMENTE
                console.error('[Open-Meteo] ❌ Error obteniendo datos:', error);
                console.error('[Open-Meteo] Stack:', error.stack);

                const cached = getFromCache();
                if (cached) {
                    console.log('[Open-Meteo] ⚠️ Usando cache como fallback');
                    return cached;
                }

                // Último recurso: datos de ejemplo
                console.warn('[Open-Meteo] ⚠️ Usando datos de ejemplo como último recurso');
                console.warn('[Open-Meteo] Esto indica un problema de conexión o configuración');
                return createExampleData();
            }
        };

        /**
         * Fallback a Open-Meteo (YA NO SE USA - Open-Meteo es la fuente principal ahora).
         * Backend pausado temporalmente.
         */
        // const fetchWeatherDataFallback = async () => {
        //     // Esta función ya no se usa, Open-Meteo es la fuente principal
        //     // Mantenida comentada para referencia
        // };

        // ============ CÁLCULO DE RIESGOS ============
        /**
         * Calcula el riesgo de patrones meteorológicos.
         * Por ahora retorna 0 (sin detección compleja de patrones en frontend).
         * El backend tiene PatternDetector completo, frontend solo fallback básico.
         */
        const calculatePatternRisk = (data, profile) => {
            // TODO: Implementar detección básica de patrones si es necesario
            // Por ahora, retornar 0 para coincidir con estructura del backend
            return 0;
        };

        const calculateRisks = (data, profile) => {
            const current = data.current;
            const hourly = data.hourly;
            const weights = PROFILES[profile].weights;

            // Riesgo por temperatura (usa sensación térmica si es mayor)
            const realTemp = current.temperature_2m;
            const feelsLike = current.apparent_temperature || realTemp;
            const temp = Math.max(realTemp, feelsLike); // Usar la más alta para calor
            const coldTemp = Math.min(realTemp, feelsLike); // Usar la más baja para frío

            let tempRisk = 0;
            // Calor extremo (basado en sensación térmica)
            if (temp >= 40) tempRisk = 100;
            else if (temp >= 38) tempRisk = 85 + (temp - 38) * 7.5; // 85-100%
            else if (temp >= 35) tempRisk = 60 + (temp - 35) * 8.3; // 60-85%
            else if (temp >= 32) tempRisk = 35 + (temp - 32) * 8.3; // 35-60%
            else if (temp >= 28) tempRisk = 10 + (temp - 28) * 6.25; // 10-35%
            // Frío (basado en sensación térmica)
            else if (coldTemp <= -5) tempRisk = 100;
            else if (coldTemp <= 0) tempRisk = 70 + (0 - coldTemp) * 6; // 70-100%
            else if (coldTemp <= 5) tempRisk = 40 + (5 - coldTemp) * 6; // 40-70%
            else if (coldTemp <= 10) tempRisk = 15 + (10 - coldTemp) * 5; // 15-40%

            // Riesgo por viento
            const wind = current.wind_speed_10m;
            let windRisk = 0;
            if (wind > 60) windRisk = 100;
            else if (wind > 40) windRisk = 60 + (wind - 40) * 2;
            else if (wind > 25) windRisk = 20 + (wind - 25) * 2.67;
            else if (wind > 15) windRisk = (wind - 15) * 2;

            // Riesgo por precipitación
            // Considerar precipitación actual y pronosticada en las próximas 6 horas
            const precip = current.precipitation || 0;
            const precipProb = (hourly && hourly.precipitation_probability && Array.isArray(hourly.precipitation_probability)) ?
                Math.max(...hourly.precipitation_probability.slice(0, 6)) : 0;

            // Precipitación pronosticada en las próximas 6 horas
            const futurePrecip = (hourly && hourly.precipitation && Array.isArray(hourly.precipitation)) ?
                Math.max(...hourly.precipitation.slice(0, 6)) : 0;

            // Weather codes que indican lluvia (61-67: lluvia, 80-82: chubascos, 95-99: tormentas)
            const futureWeatherCodes = (hourly && hourly.weather_code && Array.isArray(hourly.weather_code)) ?
                hourly.weather_code.slice(0, 6) : [];
            const hasRainInNextHours = futureWeatherCodes.some(code =>
                code != null && ((code >= 61 && code <= 67) || (code >= 80 && code <= 82) || (code >= 95 && code <= 99))
            );

            // Calcular riesgo basado en múltiples factores
            let precipRisk = 0;

            // Si hay lluvia actual
            if (precip > 0) {
                precipRisk = Math.min(100, precip * 20); // 1mm = 20%, 5mm = 100%
            }

            // Si hay lluvia pronosticada en las próximas horas
            if (futurePrecip > 0) {
                const futureRisk = Math.min(100, futurePrecip * 15); // 1mm = 15%, ~6.7mm = 100%
                precipRisk = Math.max(precipRisk, futureRisk);
            }

            // Si el weather_code indica lluvia en las próximas horas
            if (hasRainInNextHours) {
                // Asegurar mínimo riesgo si hay lluvia pronosticada
                const codeRisk = Math.max(30, precipProb * 0.5); // Mínimo 30% si hay lluvia pronosticada
                precipRisk = Math.max(precipRisk, codeRisk);
            }

            // Considerar probabilidad de precipitación
            if (precipProb > 0) {
                const probRisk = precipProb * 0.8; // Probabilidad directa
                precipRisk = Math.max(precipRisk, probRisk);
            }

            precipRisk = Math.min(100, precipRisk);

            // Riesgo por tormenta eléctrica (weather_code 95-99)
            // Considerar weather codes actuales Y futuros (próximas 6 horas)
            const currentWeatherCode = current.weather_code || 0;

            // Combinar todos los weather codes a evaluar (evitar redeclarar futureWeatherCodes)
            const allWeatherCodes = [currentWeatherCode, ...futureWeatherCodes].filter(code => code != null);

            let stormRisk = 0;
            // Buscar el máximo riesgo de tormenta en los próximos 6 horas
            for (const code of allWeatherCodes) {
                if (code >= 99) {
                    stormRisk = 100; // Tormenta severa con granizo - máximo riesgo
                    break; // No hay nada más alto
                } else if (code >= 96 && stormRisk < 90) {
                    stormRisk = 90; // Tormenta con granizo
                } else if (code >= 95 && stormRisk < 80) {
                    stormRisk = 80; // Tormenta eléctrica
                } else if (code >= 80 && stormRisk < 40) {
                    stormRisk = 40; // Chubascos fuertes
                } else if (code >= 61 && code <= 67 && stormRisk < 15) {
                    stormRisk = 15; // Lluvia (61-67: lluvia según WMO)
                }
            }

            // Riesgo por granizo (weather_code 96-99 + condiciones propicias)
            let hailRisk = 0;
            // Buscar el máximo riesgo de granizo en los próximos 6 horas
            for (const code of allWeatherCodes) {
                if (code >= 99) {
                    hailRisk = 100; // Granizo severo - máximo riesgo
                    break; // No hay nada más alto
                } else if (code >= 96 && hailRisk < 85) {
                    hailRisk = 85; // Granizo confirmado
                } else if (code === 77 && hailRisk < 40) {
                    hailRisk = 40; // Granizo ligero (77: nieve granulada/granizo)
                }
            }

            // Condiciones propicias para granizo: calor + tormenta pronosticada
            if (hailRisk === 0) {
                const hasStormInFuture = futureWeatherCodes.some(code => code != null && code >= 95);
                if (hasStormInFuture) {
                    if (temp >= 30) hailRisk = 50; // Alta probabilidad
                    else if (temp >= 28) hailRisk = 25; // Probabilidad moderada
                }
            }

            // Score combinado: promedio ponderado (normalizado a 100%)
            // Calcular pattern_risk básico (sin detección compleja de patrones)
            const patternRisk = calculatePatternRisk(data, profile);

            // Pesos fijos para storm/hail (como backend: 0.2 cada uno)
            const stormWeight = 0.2;
            const hailWeight = 0.2;

            const weightedScore =
                tempRisk * weights.temp +
                windRisk * weights.wind +
                precipRisk * weights.precip +
                patternRisk * weights.pattern +  // ✅ Agregar pattern_risk
                stormRisk * stormWeight +       // ✅ Peso fijo 0.2
                hailRisk * hailWeight;          // ✅ Peso fijo 0.2

            // Máximo riesgo individual (cualquier factor crítico eleva el índice)
            const maxRisk = Math.max(tempRisk, windRisk, precipRisk, stormRisk, hailRisk, patternRisk);

            // Combinar: 60% promedio ponderado + 40% máximo individual
            // Esto asegura que una ola de calor sola suba el índice
            const combinedScore = (weightedScore * 0.6) + (maxRisk * 0.4);

            // Convertir de 0-100 a 0-5 (con 1 decimal)
            const score = Math.min(5, Math.round((combinedScore / 100) * 5 * 10) / 10);
            // Asegurar que el score sea un número con 1 decimal
            const formattedScore = parseFloat(score.toFixed(1));

            // Debug: Log de cálculo para diagnóstico
            console.log('[RiskScore] Cálculo detallado:', {
                tempRisk,
                windRisk,
                precipRisk,
                stormRisk,
                hailRisk,
                patternRisk,
                weightedScore: weightedScore.toFixed(2),
                maxRisk,
                combinedScore: combinedScore.toFixed(2),
                score: formattedScore
            });

            return {
                score: formattedScore, // Score formateado con 1 decimal
                tempRisk: Math.round(tempRisk),
                windRisk: Math.round(windRisk),
                precipRisk: Math.round(precipRisk),
                stormRisk: Math.round(stormRisk),
                hailRisk: Math.round(hailRisk),
                patternRisk: Math.round(patternRisk), // ✅ Agregar patternRisk
                maxRisk: Math.round(maxRisk)
            };
        };

        const getCategory = (score) => {
            // Escala 0-5 consistente con niveles de alerta
            if (score >= 4) return { name: 'Crítico', class: 'extreme', color: '#DC2626', level: 4 };
            if (score >= 3) return { name: 'Alerta', class: 'very-high', color: '#F97316', level: 3 };
            if (score >= 2) return { name: 'Precaución', class: 'moderate', color: '#F59E0B', level: 2 };
            if (score >= 1) return { name: 'Atención', class: 'low', color: '#3B82F6', level: 1 };
            return { name: 'Normal', class: 'very-low', color: '#10B981', level: 0 };
        };

        // ============ ICONOS DE ALERTA SVG ============
        const ALERT_ICONS = {
            // Nivel 0 - Normal (checkmark)
            0: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
            // Nivel 1 - Atención (info)
            1: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>',
            // Nivel 2 - Precaución (warning triangle)
            2: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
            // Nivel 3 - Alerta (alert octagon)
            3: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>',
            // Nivel 4 - Crítico (shield alert)
            4: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'
        };

        // ============ ALERTAS ============
        /**
         * Genera alerta basada en el risk score para mantener consistencia.
         * 
         * IMPORTANTE: El alert banner usa el mismo score que el risk score card
         * para evitar inconsistencias (ej: score 1.4 = ATENCIÓN, pero alerta nivel 3).
         * 
         * Las alertas del backend (con anticipación) se muestran en el alert stack,
         * no en el alert banner principal.
         */
        const generateAlert = (risks, data) => {
            // SIEMPRE usar el score para el alert banner principal
            // Esto garantiza consistencia con el risk score card
            const score = risks.score;

            let level, levelName, title, description, timeWindow;

            // Escala 0-5 - USAR SOLO EL SCORE
            // Esto garantiza que alert-banner y risk-score-card usen el mismo nivel
            if (score >= 4) {
                level = 4;
                levelName = 'Crítico';
                title = 'Condición peligrosa confirmada';
                description = 'Evitar actividades al aire libre. Buscar refugio seguro.';
                timeWindow = 'Próximas 0-3 horas';
            } else if (score >= 3) {
                level = 3;
                levelName = 'Alerta';
                title = 'Riesgo alto detectado';
                description = 'Se recomienda modificar o evitar actividades sensibles al clima.';
                timeWindow = 'Próximas 3-12 horas';
            } else if (score >= 2) {
                level = 2;
                levelName = 'Precaución';
                title = 'Riesgo moderado';
                description = 'Posibles interrupciones según actividad. Evaluar planes.';
                timeWindow = 'Próximas 12-24 horas';
            } else if (score >= 1) {
                level = 1;
                levelName = 'Atención';
                title = 'Escenario en evolución';
                description = 'Condiciones a monitorear. Sin acción requerida por ahora.';
                timeWindow = 'Próximas 24-48 horas';
            } else {
                level = 0;
                levelName = 'Normal';
                title = 'Condiciones estables';
                description = 'Sin impacto operativo esperado.';
                timeWindow = 'Próximas 24-72 horas';
            }

            return { level, levelName, icon: ALERT_ICONS[level], title, description, timeWindow };
        };

        // ============ ALERT STACK MANAGEMENT ============
        const alertStack = {
            cards: [],
            maxVisible: 5,

            add(alert, risks, data) {
                // Solo agregar alertas nivel 3-4 al stack
                if (alert.level < 3) return;

                const cardId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const card = {
                    id: cardId,
                    alert,
                    risks,
                    data,
                    timestamp: Date.now()
                };

                this.cards.push(card);
                this.render();

                // Auto-dismiss según nivel
                if (alert.level === 3) {
                    const timeoutId = setTimeout(() => this.remove(cardId), 15000); // 15s para nivel 3
                    timers.alertTimeouts.set(cardId, timeoutId);
                }
                // Nivel 4 no se auto-dismiss (manual)
            },

            remove(cardId) {
                const card = document.getElementById(cardId);
                if (card) {
                    // Limpiar timeout si existe
                    if (timers.alertTimeouts.has(cardId)) {
                        clearTimeout(timers.alertTimeouts.get(cardId));
                        timers.alertTimeouts.delete(cardId);
                    }

                    // Usar animación de anime.js
                    if (window.AnimeUtils && window.AnimeUtils.animateAlertOut) {
                        window.AnimeUtils.animateAlertOut(card, () => {
                            this.cards = this.cards.filter(c => c.id !== cardId);
                            this.render();
                        });
                    } else {
                        // Fallback al método anterior
                        card.classList.add('fade-out');
                        setTimeout(() => {
                            this.cards = this.cards.filter(c => c.id !== cardId);
                            this.render();
                        }, 200);
                    }
                }
            },

            render() {
                const container = document.getElementById('alert-stack');
                if (!container) return;

                // Limitar a maxVisible
                const visibleCards = this.cards.slice(-this.maxVisible);

                // Limpiar contenedor de forma segura
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }

                if (visibleCards.length === 0) {
                    return;
                }

                // Crear elementos de forma segura
                visibleCards.forEach(card => {
                    const { alert, risks } = card;
                    const impactText = alert.level === 4
                        ? 'Impacto crítico inminente'
                        : 'Alta probabilidad de impacto';

                    // Crear card principal
                    const cardElement = createSafeElement('div', {
                        className: `alert-floating-card level-${alert.level}`,
                        id: card.id
                    });

                    // Botón cerrar
                    const closeBtn = createSafeElement('button', {
                        className: 'alert-floating-close',
                        'aria-label': 'Cerrar alerta'
                    });
                    closeBtn.addEventListener('click', () => this.remove(card.id));

                    // SVG de cerrar
                    const closeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    closeSvg.setAttribute('viewBox', '0 0 24 24');
                    closeSvg.setAttribute('fill', 'none');
                    closeSvg.setAttribute('stroke', 'currentColor');
                    closeSvg.setAttribute('stroke-width', '2');
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', '18');
                    line1.setAttribute('y1', '6');
                    line1.setAttribute('x2', '6');
                    line1.setAttribute('y2', '18');
                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', '6');
                    line2.setAttribute('y1', '6');
                    line2.setAttribute('x2', '18');
                    line2.setAttribute('y2', '18');
                    closeSvg.appendChild(line1);
                    closeSvg.appendChild(line2);
                    closeBtn.appendChild(closeSvg);
                    cardElement.appendChild(closeBtn);

                    // Header
                    const header = createSafeElement('div', { className: 'alert-floating-header' });
                    const iconDiv = createSafeElement('div', { className: 'alert-floating-icon' });
                    // Icono como HTML (ya viene sanitizado del backend)
                    const iconParser = new DOMParser();
                    const iconDoc = iconParser.parseFromString(alert.icon, 'text/html');
                    if (iconDoc.body.firstChild) {
                        iconDiv.appendChild(iconDoc.body.firstChild);
                    }
                    header.appendChild(iconDiv);

                    const contentDiv = createSafeElement('div', { className: 'alert-floating-content' });
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-level' }, `Nivel ${alert.level} • ${escapeHtml(alert.levelName)}`));
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-title' }, escapeHtml(alert.title)));
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-description' }, escapeHtml(alert.description)));
                    header.appendChild(contentDiv);
                    cardElement.appendChild(header);

                    // Meta
                    const meta = createSafeElement('div', { className: 'alert-floating-meta' });
                    const timeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    timeSvg.setAttribute('viewBox', '0 0 24 24');
                    timeSvg.setAttribute('fill', 'none');
                    timeSvg.setAttribute('stroke', 'currentColor');
                    timeSvg.setAttribute('stroke-width', '2');
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', '12');
                    circle.setAttribute('cy', '12');
                    circle.setAttribute('r', '10');
                    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    polyline.setAttribute('points', '12 6 12 12 16 14');
                    timeSvg.appendChild(circle);
                    timeSvg.appendChild(polyline);
                    meta.appendChild(timeSvg);
                    meta.appendChild(createSafeElement('span', {}, escapeHtml(alert.timeWindow)));
                    const impactSpan = createSafeElement('span', { style: 'margin-left: auto; color: var(--alert-color);' }, escapeHtml(impactText));
                    meta.appendChild(impactSpan);
                    cardElement.appendChild(meta);

                    // Actions
                    const actions = createSafeElement('div', { className: 'alert-floating-actions' });
                    const detailsBtn = createSafeElement('button', { className: 'alert-floating-btn' }, 'Ver detalles');
                    detailsBtn.addEventListener('click', () => this.expandDetails(card.id));
                    actions.appendChild(detailsBtn);

                    if (alert.level === 4) {
                        const acknowledgeBtn = createSafeElement('button', { className: 'alert-floating-btn primary' }, 'Entendido');
                        acknowledgeBtn.addEventListener('click', () => this.acknowledge(card.id));
                        actions.appendChild(acknowledgeBtn);
                    }
                    cardElement.appendChild(actions);

                    container.appendChild(cardElement);

                    // Animar entrada de la alerta
                    if (window.AnimeUtils && window.AnimeUtils.animateAlertIn) {
                        const cardIndex = visibleCards.findIndex(c => c.id === card.id);
                        window.AnimeUtils.animateAlertIn(cardElement, cardIndex);
                    }
                });
            },

            expandDetails(cardId) {
                const card = this.cards.find(c => c.id === cardId);
                if (!card) return;

                // Por ahora solo log, en Fase 2 se puede expandir con más info
                console.log('Expandir detalles de alerta:', card);
                // TODO: Implementar modal o expansión de detalles
            },

            acknowledge(cardId) {
                // Marcar como leída pero mantener visible
                console.log('Alerta reconocida:', cardId);
                // TODO: Guardar en localStorage para no mostrar de nuevo
            }
        };

        // ============ METRIC TOOLTIP SYSTEM (Fase 2) ============
        const metricTooltip = {
            currentTooltip: null,
            hideTimeout: null,

            show(metricCard, metricType, data, risks) {
                // Ocultar tooltip anterior
                this.hide();

                // Crear tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'metric-tooltip';
                tooltip.id = 'metric-tooltip';

                // Generar contenido según tipo de métrica
                const content = this.generateContent(metricType, data, risks);
                if (content) {
                    tooltip.appendChild(content);
                }

                // Agregar al DOM temporalmente para medir
                document.body.appendChild(tooltip);

                // Obtener dimensiones del tooltip
                const tooltipRect = tooltip.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;

                // Determinar posición considerando viewport y tamaño del tooltip
                const rect = metricCard.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const isMobile = viewportWidth < 768;

                // Espacio mínimo requerido (más pequeño en móvil)
                const minSpace = isMobile ? 16 : 24;
                const tooltipMargin = isMobile ? 12 : 16;

                let position = 'top';

                // En móvil, preferir bottom o top según espacio disponible
                if (isMobile) {
                    const spaceAbove = rect.top;
                    const spaceBelow = viewportHeight - rect.bottom;

                    if (spaceBelow >= tooltipHeight + tooltipMargin) {
                        position = 'bottom';
                    } else if (spaceAbove >= tooltipHeight + tooltipMargin) {
                        position = 'top';
                    } else {
                        // Si no cabe arriba ni abajo, usar bottom y ajustar después
                        position = 'bottom';
                    }
                } else {
                    // Desktop: lógica original mejorada
                    if (rect.top < 200) {
                        position = 'bottom';
                    } else if (rect.right > viewportWidth - (tooltipWidth + tooltipMargin)) {
                        position = 'left';
                    } else if (rect.left < (tooltipWidth + tooltipMargin)) {
                        position = 'right';
                    } else {
                        position = 'top';
                    }
                }

                tooltip.classList.add(position);

                // Posicionar con ajuste dinámico
                this.positionTooltip(tooltip, metricCard, position, isMobile);

                // Mostrar con animación usando anime.js
                if (window.AnimeUtils && window.AnimeUtils.animateTooltipIn) {
                    window.AnimeUtils.animateTooltipIn(tooltip, position);
                } else {
                    // Fallback al método anterior
                    setTimeout(() => tooltip.classList.add('visible'), 10);
                }

                // Event listeners para mantener tooltip visible cuando el mouse está sobre él
                tooltip.addEventListener('mouseenter', () => {
                    // Cancelar timeout de auto-close cuando el mouse entra al tooltip
                    if (this.hideTimeout) {
                        clearTimeout(this.hideTimeout);
                        this.hideTimeout = null;
                    }
                });

                tooltip.addEventListener('mouseleave', () => {
                    // Ocultar inmediatamente cuando el mouse sale del tooltip
                    this.hide();
                });

                this.currentTooltip = tooltip;

                // Auto-close después de 5s si no hay hover (solo si el mouse no está sobre la card ni el tooltip)
                // Este timeout se cancela cuando el mouse sale de la card o del tooltip
                this.hideTimeout = setTimeout(() => {
                    // Verificar que el tooltip aún existe antes de ocultarlo
                    if (this.currentTooltip && document.body.contains(this.currentTooltip)) {
                        this.hide();
                    }
                }, 5000);
            },

            generateContent(metricType, data, risks) {
                const current = data.current;
                const hourly = data.hourly || [];
                const now = new Date();

                let icon, title, value, comparison, trend, range, insight;

                switch (metricType) {
                    case 'temperature':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>';
                        title = 'Temperatura';
                        value = `${current.temperature_2m}°C`;

                        // Simplificado: solo estado y recomendación
                        if (current.temperature_2m > 30) {
                            comparison = 'Temperatura elevada';
                            insight = 'Hidratación recomendada.';
                        } else if (current.temperature_2m < 15) {
                            comparison = 'Temperatura fresca';
                            insight = 'Abrigo recomendado.';
                        } else {
                            comparison = 'Temperatura agradable';
                            insight = 'Ideal para actividades al aire libre.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'apparent_temperature':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg>';
                        title = 'Sensación Térmica';
                        value = `${current.apparent_temperature}°C`;
                        const tempDiff = current.apparent_temperature - current.temperature_2m;
                        if (Math.abs(tempDiff) > 2) {
                            comparison = tempDiff > 0 ? `+${tempDiff.toFixed(1)}°C vs real` : `${tempDiff.toFixed(1)}°C vs real`;
                            insight = tempDiff > 2 ? 'Más cálida por viento/humedad' : 'Más fría por viento';
                        } else {
                            comparison = 'Similar a temperatura real';
                            insight = 'Sin efecto significativo del viento/humedad';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'wind':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2M9.6 4.6A2.5 2.5 0 1 1 11 8H2M12.6 19.4A2.5 2.5 0 1 0 14 16H2"/></svg>';
                        title = 'Viento';
                        value = `${Math.round(current.wind_speed_10m)} km/h`;
                        const windDir = getWindDirection(current.wind_direction_10m);
                        comparison = `Del ${windDir}`;
                        if (current.wind_speed_10m > 30) {
                            insight = 'Viento fuerte. Precaución en actividades al aire libre.';
                        } else if (current.wind_speed_10m < 10) {
                            insight = 'Viento favorable para vuelo VFR.';
                        } else {
                            insight = 'Condiciones de viento normales.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'humidity':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"/></svg>';
                        title = 'Humedad Relativa';
                        value = `${current.relative_humidity_2m}%`;
                        // Simplificado: solo mostrar estado y recomendación
                        if (current.relative_humidity_2m > 80) {
                            comparison = 'Alta humedad';
                            insight = 'Sensación de bochorno posible.';
                        } else if (current.relative_humidity_2m < 30) {
                            comparison = 'Baja humedad';
                            insight = 'Hidratación importante.';
                        } else {
                            comparison = 'Humedad normal';
                            insight = 'Rango confortable (40-60%).';
                        }
                        trend = 'neutral'; // Eliminamos la flecha confusa
                        range = null; // Eliminamos sección redundante
                        break;

                    case 'cloud_cover':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>';
                        title = 'Nubosidad';
                        value = `${current.cloud_cover}%`;
                        if (current.cloud_cover > 75) {
                            comparison = 'Cielo nublado';
                            insight = 'Posible lluvia.';
                        } else if (current.cloud_cover < 25) {
                            comparison = 'Cielo despejado';
                            insight = 'Buenas condiciones.';
                        } else {
                            comparison = 'Cielo parcialmente nublado';
                            insight = 'Nubosidad variable.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    default:
                        return null;
                }

                // Versión simplificada: solo header, estado y recomendación
                const fragment = document.createDocumentFragment();

                // Header
                const header = createSafeElement('div', { className: 'metric-tooltip-header' });
                const iconDiv = createSafeElement('div', { className: 'metric-tooltip-icon' });
                // Icono como HTML (parsear si es string)
                if (typeof icon === 'string') {
                    const iconParser = new DOMParser();
                    const iconDoc = iconParser.parseFromString(icon, 'text/html');
                    if (iconDoc.body.firstChild) {
                        iconDiv.appendChild(iconDoc.body.firstChild);
                    }
                } else {
                    iconDiv.appendChild(icon);
                }
                header.appendChild(iconDiv);

                const titleDiv = createSafeElement('div', { className: 'metric-tooltip-title' });
                titleDiv.appendChild(createSafeElement('h4', {}, escapeHtml(title)));
                titleDiv.appendChild(createSafeElement('div', { className: 'metric-tooltip-value' }, escapeHtml(value)));
                header.appendChild(titleDiv);
                fragment.appendChild(header);

                // Body
                const body = createSafeElement('div', { className: 'metric-tooltip-body' });
                const item = createSafeElement('div', { className: 'metric-tooltip-item' });
                const itemContent = createSafeElement('div', { className: 'metric-tooltip-item-content' });
                itemContent.appendChild(createSafeElement('div', { className: 'metric-tooltip-item-label' }, 'Estado'));
                itemContent.appendChild(createSafeElement('div', { className: 'metric-tooltip-item-value' }, escapeHtml(comparison)));
                item.appendChild(itemContent);
                body.appendChild(item);

                const insightDiv = createSafeElement('div', { className: 'metric-tooltip-insight' }, escapeHtml(insight));
                body.appendChild(insightDiv);
                fragment.appendChild(body);

                return fragment;
            },

            positionTooltip(tooltip, metricCard, position, isMobile = false) {
                // En móvil, usar posición fija en la parte inferior
                if (isMobile) {
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = '16px';
                    tooltip.style.right = '16px';
                    tooltip.style.top = 'auto';
                    tooltip.style.bottom = '16px';
                    tooltip.style.transform = 'none';
                    tooltip.style.margin = '0';
                    tooltip.style.width = 'calc(100vw - 32px)';
                    tooltip.style.maxWidth = 'calc(100vw - 32px)';
                    return;
                }

                const cardRect = metricCard.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                const scrollY = window.scrollY;
                const scrollX = window.scrollX;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Calcular posición base
                let left, top, transform;
                const spacing = 16;

                switch (position) {
                    case 'top':
                        left = cardRect.left + scrollX + (cardRect.width / 2);
                        top = cardRect.top + scrollY - spacing;
                        transform = 'translateX(-50%) translateY(-100%)';
                        break;
                    case 'bottom':
                        left = cardRect.left + scrollX + (cardRect.width / 2);
                        top = cardRect.bottom + scrollY + spacing;
                        transform = 'translateX(-50%) translateY(0)';
                        break;
                    case 'right':
                        left = cardRect.right + scrollX + spacing;
                        top = cardRect.top + scrollY + (cardRect.height / 2);
                        transform = 'translateY(-50%) translateX(0)';
                        break;
                    case 'left':
                        left = cardRect.left + scrollX - spacing;
                        top = cardRect.top + scrollY + (cardRect.height / 2);
                        transform = 'translateX(-100%) translateY(-50%)';
                        break;
                }

                // Ajustar si se sale del viewport (especialmente en móvil)
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;
                const margin = isMobile ? 8 : 16;

                // Ajuste horizontal
                if (position === 'top' || position === 'bottom') {
                    const leftOffset = left - scrollX;
                    if (leftOffset - (tooltipWidth / 2) < margin) {
                        // Se sale por la izquierda
                        left = scrollX + margin + (tooltipWidth / 2);
                        transform = transform.replace('translateX(-50%)', 'translateX(-50%)');
                    } else if (leftOffset + (tooltipWidth / 2) > viewportWidth - margin) {
                        // Se sale por la derecha
                        left = scrollX + viewportWidth - margin - (tooltipWidth / 2);
                        transform = transform.replace('translateX(-50%)', 'translateX(-50%)');
                    }
                } else if (position === 'right') {
                    const rightEdge = left - scrollX + tooltipWidth;
                    if (rightEdge > viewportWidth - margin) {
                        // Cambiar a left si no cabe a la derecha
                        left = cardRect.left + scrollX - spacing;
                        transform = 'translateX(-100%) translateY(-50%)';
                    }
                } else if (position === 'left') {
                    const leftEdge = left - scrollX - tooltipWidth;
                    if (leftEdge < margin) {
                        // Cambiar a right si no cabe a la izquierda
                        left = cardRect.right + scrollX + spacing;
                        transform = 'translateY(-50%) translateX(0)';
                    }
                }

                // Ajuste vertical
                if (position === 'top') {
                    const topEdge = top - scrollY - tooltipHeight;
                    if (topEdge < margin) {
                        // Cambiar a bottom si no cabe arriba
                        top = cardRect.bottom + scrollY + spacing;
                        transform = 'translateX(-50%) translateY(0)';
                    }
                } else if (position === 'bottom') {
                    const bottomEdge = top - scrollY + tooltipHeight;
                    if (bottomEdge > viewportHeight - margin) {
                        // Ajustar hacia arriba
                        top = cardRect.top + scrollY - spacing;
                        transform = 'translateX(-50%) translateY(-100%)';
                    }
                }

                tooltip.style.position = 'absolute';
                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
                tooltip.style.transform = transform;
                tooltip.style.margin = '0';
            },

            hide() {
                // Cancelar cualquier timeout pendiente
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = null;
                }

                if (!this.currentTooltip) return;

                const tooltip = this.currentTooltip;
                // Limpiar referencia inmediatamente para evitar múltiples llamadas
                this.currentTooltip = null;

                // Remover clase visible inmediatamente
                tooltip.classList.remove('visible');

                // Usar animación de anime.js
                if (window.AnimeUtils && window.AnimeUtils.animateTooltipOut) {
                    const animation = window.AnimeUtils.animateTooltipOut(tooltip);
                    // Si la animación no se inició, eliminar directamente
                    if (!animation) {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }
                } else {
                    // Fallback al método anterior
                    setTimeout(() => {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }, 200);
                }
            }
        };

        // ============ RECOMENDACIONES ============
        const getRecommendation = (profile, category, risks) => {
            const profileData = PROFILES[profile];

            if (category.class === 'very-low') {
                return `Condiciones favorables para ${profileData.name.toLowerCase()}. Disfrute su actividad.`;
            }

            if (category.class === 'low') {
                return `Condiciones aceptables. Monitoree actualizaciones meteorológicas.`;
            }

            let factors = [];
            if (risks.tempRisk > 30) factors.push('temperatura');
            if (risks.windRisk > 30) factors.push('viento');
            if (risks.precipRisk > 30) factors.push('precipitación');
            if (risks.stormRisk > 30) factors.push('tormentas eléctricas');
            if (risks.hailRisk > 30) factors.push('granizo');

            const factorsText = factors.length > 0 ? factors.join(', ') : 'condiciones meteorológicas';

            const specifics = {
                pilot: 'Verificar METAR/TAF. Descargas en 10km = alerta roja.',
                farmer: 'Evaluar tareas a campo.',
                outdoor_sports: 'Considerar rutas alternativas o postergar actividad.',
                outdoor: 'Tener plan B disponible.',
                trucker: 'Evaluar postergar viaje o ruta alternativa.',
                construction: 'Suspender trabajos en altura.',
                tourism: 'Riesgo de descargas eléctricas. Buscar refugio seguro.',
                general: 'Evaluar necesidad de salir.'
            };

            if (category.class === 'extreme' || category.class === 'very-high') {
                return `Riesgo ${category.name.toLowerCase()}. Evitar actividad al aire libre. Priorizar seguridad.`;
            }

            return `Precaución por ${factorsText}. ${specifics[profile] || specifics.general}`;
        };

        // ============ WEATHER ICON ============
        const getWeatherIcon = (code) => {
            if (code >= 95) return '⛈️';
            if (code >= 80) return '🌧️';
            if (code >= 71) return '🌨️';
            if (code >= 61) return '🌧️';
            if (code >= 51) return '🌦️';
            if (code >= 45) return '🌫️';
            if (code >= 3) return '☁️';
            if (code >= 2) return '⛅';
            if (code >= 1) return '🌤️';
            return '☀️';
        };

        // ============ FORMAT SOURCE NAMES ============
        /**
         * Formatea nombres de fuentes meteorológicas para mostrar al usuario.
         * Convierte códigos técnicos a nombres legibles.
         */
        const formatSourceNames = (sources) => {
            if (!sources || sources.length === 0) return 'Open-Meteo';

            const sourceMap = {
                'meteosource': 'Meteosource',
                'meteosource_wrf': 'Meteosource WRF',
                'windy_ecmwf': 'Windy ECMWF',
                'windy_gfs': 'Windy GFS',
                'windy_icon': 'Windy ICON',
                'wrf_smn': 'WRF-SMN',
                'local_stations': 'Estaciones Locales',
                'fused': 'Fusión Multi-Modelo',
                'open_meteo': 'Open-Meteo'
            };

            const formatted = sources.map(s => sourceMap[s.toLowerCase()] || s).filter(Boolean);

            if (formatted.length === 0) return 'Open-Meteo';
            if (formatted.length === 1) return formatted[0];
            if (formatted.length <= 3) return formatted.join(' + ');
            return `${formatted.slice(0, 2).join(' + ')} + ${formatted.length - 2} más`;
        };

        // ============ OBTENER RISK SCORE DEL BACKEND ============
        /**
         * Intenta obtener el risk score del backend.
         * Retorna null si el backend no está disponible o falla.
         */
        const fetchRiskScoreFromBackend = async (profile, hoursAhead = 6) => {
            try {
                if (!api) {
                    console.log('[Backend] API client no inicializado, usando fallback local');
                    return null;
                }

                const { lat, lon } = CONFIG.location;
                console.log(`[Backend] Obteniendo risk score para ${profile} en (${lat}, ${lon})`);

                const response = await api.calculateRiskScore(lat, lon, profile, hoursAhead);

                // Mapear respuesta del backend al formato del frontend
                // Backend retorna scores en escala 0-5, frontend espera 0-100 para barras
                return {
                    score: response.score,  // Ya viene en escala 0-5
                    tempRisk: Math.round((response.temperature_risk || 0) * 20),  // Backend: 0-5, Frontend: 0-100
                    windRisk: Math.round((response.wind_risk || 0) * 20),
                    precipRisk: Math.round((response.precipitation_risk || 0) * 20),
                    stormRisk: Math.round((response.storm_risk || 0) * 20),
                    hailRisk: Math.round((response.hail_risk || 0) * 20),
                    patternRisk: Math.round((response.pattern_risk || 0) * 20),  // ✅ Incluir pattern_risk
                    maxRisk: Math.max(
                        (response.temperature_risk || 0) * 20,
                        (response.wind_risk || 0) * 20,
                        (response.precipitation_risk || 0) * 20,
                        (response.storm_risk || 0) * 20,
                        (response.hail_risk || 0) * 20,
                        (response.pattern_risk || 0) * 20
                    )
                };
            } catch (error) {
                console.warn('[Backend] Error obteniendo risk score, usando fallback local:', error);
                return null; // Retornar null para usar fallback
            }
        };

        // ============ RENDER DASHBOARD ============
        const renderDashboard = async (data) => {
            try {
                // Validar datos mínimos requeridos
                if (!data || !data.current) {
                    throw new Error('Datos incompletos: falta data.current');
                }
                if (!data.hourly) {
                    console.warn('[Render] data.hourly no disponible, usando array vacío');
                    data.hourly = { time: [], temperature_2m: [], precipitation: [], weather_code: [], wind_speed_10m: [], precipitation_probability: [] };
                }

                weatherData = data;

                // ============ OBTENER RISK SCORE (BACKEND O FRONTEND) ============
                // Intentar obtener score del backend primero, fallback a cálculo local
                let risks, category, alert;

                // Intentar usar score del backend si está disponible
                if (api && CONFIG.backendUrl) {
                    const backendRiskScore = await fetchRiskScoreFromBackend(currentProfile, 6);
                    if (backendRiskScore) {
                        risks = backendRiskScore;
                        console.log('[Backend] ✅ Risk score obtenido del backend:', risks.score);
                    } else {
                        // Fallback a cálculo local
                        risks = calculateRisks(data, currentProfile);
                        console.log('[Frontend] ⚠️ Risk score calculado localmente (fallback):', risks.score);
                    }
                } else {
                    // Backend no configurado, usar cálculo local
                    risks = calculateRisks(data, currentProfile);

                    // Verificar si estamos usando datos de ejemplo
                    if (data.frontend && data.frontend.source === 'offline_example') {
                        console.warn('[Frontend] ⚠️ ATENCIÓN: Usando datos de ejemplo. Score puede no ser preciso.');
                    }

                    console.log('[Frontend] Risk score calculado localmente:', {
                        score: risks.score,
                        source: data.frontend?.source || 'unknown',
                        temp: data.current?.temperature_2m,
                        wind: data.current?.wind_speed_10m,
                        precip: data.current?.precipitation
                    });
                }

                category = getCategory(risks.score);
                alert = generateAlert(risks, data);

                const recommendation = getRecommendation(currentProfile, category, risks);
                const current = data.current;
                const hourly = data.hourly || [];

                // ============ FRONTEND-ONLY: Agregar alertas desde AlertEngine ============
                // Usar alertas del frontend (AlertEngine con Meteosource) si están disponibles
                if (data.frontend && data.frontend.alerts && data.frontend.alerts.alerts && data.frontend.alerts.alerts.length > 0) {
                    const frontendAlerts = data.frontend.alerts.alerts;
                    // Agregar solo alertas de nivel 3-4 al stack
                    const highLevelAlerts = frontendAlerts.filter(a => a.level >= 3);
                    highLevelAlerts.forEach(frontendAlert => {
                        const alertForStack = {
                            level: frontendAlert.level,
                            levelName: frontendAlert.level_name,
                            icon: ALERT_ICONS[frontendAlert.level],
                            title: frontendAlert.phenomenon || `Alerta nivel ${frontendAlert.level}`,
                            description: frontendAlert.description,
                            timeWindow: frontendAlert.time_window
                        };
                        alertStack.add(alertForStack, risks, data);
                    });
                    console.log(`[Frontend] ${highLevelAlerts.length} alertas de nivel alto agregadas al stack`);
                } else if (alert.level >= 3) {
                    // Si no hay alertas del backend, usar la alerta principal
                    alertStack.add(alert, risks, data);
                }

                const circumference = 2 * Math.PI * 85;
                const offset = circumference - (risks.score / 5) * circumference;

                // Timeline hour index
                let timelineHour = 0;

                // ============ BANNER DE ADVERTENCIA (si usa datos de ejemplo) ============
                const isUsingExampleData = data.frontend && data.frontend.source === 'offline_example';
                const dataSourceWarning = isUsingExampleData ? `
                        <div class="data-source-warning" role="alert" aria-live="polite">
                            <div class="warning-icon">⚠️</div>
                            <div class="warning-content">
                                <strong>Modo Offline</strong>
                                <p>No se pudo conectar con la API meteorológica. Se están mostrando datos de ejemplo. El score de riesgo puede no ser preciso.</p>
                            </div>
                            <button class="warning-close" onclick="this.parentElement.remove()" aria-label="Cerrar advertencia">×</button>
                        </div>
                    ` : '';

                const app = document.getElementById('app');
                app.innerHTML = `
                ${dataSourceWarning}
                <!-- Alert Banner -->
                <div class="alert-banner level-${alert.level}">
                    <div class="alert-icon">${alert.icon}</div>
                    <div class="alert-content">
                        <div class="alert-level">Nivel ${alert.level} • ${alert.levelName}</div>
                        <div class="alert-title">${alert.title}</div>
                        <div class="alert-description">${alert.description}</div>
                    </div>
                    <div class="alert-meta">
                        <div class="alert-time-window"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>${alert.timeWindow}</div>
                    </div>
                    <div class="alert-scale">
                        <div class="alert-scale-bar">
                            <div class="alert-scale-segment seg-0 ${0 <= alert.level ? 'active' : 'inactive'} ${0 === alert.level ? 'current' : ''}"></div>
                            <div class="alert-scale-segment seg-1 ${1 <= alert.level ? 'active' : 'inactive'} ${1 === alert.level ? 'current' : ''}"></div>
                            <div class="alert-scale-segment seg-2 ${2 <= alert.level ? 'active' : 'inactive'} ${2 === alert.level ? 'current' : ''}"></div>
                            <div class="alert-scale-segment seg-3 ${3 <= alert.level ? 'active' : 'inactive'} ${3 === alert.level ? 'current' : ''}"></div>
                            <div class="alert-scale-segment seg-4 ${4 <= alert.level ? 'active' : 'inactive'} ${4 === alert.level ? 'current' : ''}"></div>
                        </div>
                        <div class="alert-scale-labels">
                            <span class="${alert.level === 0 ? 'active' : ''}">Normal</span>
                            <span class="${alert.level === 1 ? 'active' : ''}">Atención</span>
                            <span class="${alert.level === 2 ? 'active' : ''}">Precaución</span>
                            <span class="${alert.level === 3 ? 'active' : ''}">Alerta</span>
                            <span class="${alert.level === 4 ? 'active' : ''}">Crítico</span>
                        </div>
                    </div>
                </div>

                <!-- Main Grid (Content + Sidebar) -->
                <div class="main-grid">
                <!-- Main Content -->
                <div class="main-content">
                    <!-- Weather Metrics (Compact for mobile) -->
                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Condiciones Actuales</span>
                            <span class="source-badge ${isUsingExampleData ? 'source-badge-warning' : ''}" title="${isUsingExampleData ? 'Datos de ejemplo - No hay conexión con la API' : 'Datos en tiempo real'}">
                                ${isUsingExampleData ? '⚠️ Ejemplo' : 'Live'}
                            </span>
                        </div>
                        <div class="metrics-grid">
                            <div class="metric-card" data-metric="temperature">
                                <div class="metric-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg></div>
                                <div class="metric-value">${current.temperature_2m}<span class="metric-unit">°C</span></div>
                                <div class="metric-label">Temperatura</div>
                            </div>
                            <div class="metric-card ${current.apparent_temperature >= current.temperature_2m + 2 ? 'metric-warning-hot' : ''} ${current.apparent_temperature <= current.temperature_2m - 2 ? 'metric-warning-cold' : ''}" data-metric="apparent_temperature">
                                <div class="metric-icon">
                                    ${current.apparent_temperature > current.temperature_2m ?
                        '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>' :
                        '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>'
                    }
                                </div>
                                <div class="metric-value">${current.apparent_temperature}<span class="metric-unit">°C</span></div>
                                <div class="metric-label">Sensación</div>
                            </div>
                            <div class="metric-card" data-metric="wind">
                                <div class="metric-icon wind-direction" style="--wind-color: ${getWindColor(current.wind_direction_10m)}">
                                    <!-- Flecha de viento removida temporalmente -->
                                </div>
                                <div class="metric-value">${Math.round(current.wind_speed_10m)}<span class="metric-unit">km/h</span></div>
                                <div class="metric-label">del ${getWindDirection(current.wind_direction_10m)}</div>
                            </div>
                            <div class="metric-card" data-metric="humidity">
                                <div class="metric-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"/></svg></div>
                                <div class="metric-value">${current.relative_humidity_2m}<span class="metric-unit">%</span></div>
                                <div class="metric-label">Humedad</div>
                            </div>
                            <div class="metric-card" data-metric="cloud_cover">
                                <div class="metric-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg></div>
                                <div class="metric-value">${current.cloud_cover}<span class="metric-unit">%</span></div>
                                <div class="metric-label">Nubosidad</div>
                            </div>
                        </div>
                    </div>

                    <!-- Información Solar -->
                    ${data.daily ? `
                    <div class="card solar-card">
                        <div class="card-header">
                            <span class="card-title">Información Solar</span>
                        </div>
                        <div class="solar-grid">
                            <div class="solar-item">
                                <div class="solar-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="4"/>
                                        <path d="M12 2v2"/>
                                        <path d="M12 20v2"/>
                                        <path d="m4.93 4.93 1.41 1.41"/>
                                        <path d="m17.66 17.66 1.41 1.41"/>
                                        <path d="M2 12h2"/>
                                        <path d="M20 12h2"/>
                                        <path d="m6.34 17.66-1.41 1.41"/>
                                        <path d="m19.07 4.93-1.41 1.41"/>
                                    </svg>
                                </div>
                                <div class="solar-value">${formatSolarTime(data.daily.sunrise?.[0])}</div>
                                <div class="solar-label">Amanecer</div>
                            </div>
                            <div class="solar-item">
                                <div class="solar-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>
                                        <path d="M20 3v4"/>
                                        <path d="M22 5h-4"/>
                                        <path d="M17 21a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/>
                                        <path d="M19 21v-4"/>
                                        <path d="M21 19h-4"/>
                                    </svg>
                                </div>
                                <div class="solar-value">${formatSolarTime(data.daily.sunset?.[0])}</div>
                                <div class="solar-label">Atardecer</div>
                            </div>
                            <div class="solar-item">
                                <div class="solar-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="5"/>
                                        <line x1="12" y1="1" x2="12" y2="3"/>
                                        <line x1="12" y1="21" x2="12" y2="23"/>
                                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                                        <line x1="1" y1="12" x2="3" y2="12"/>
                                        <line x1="21" y1="12" x2="23" y2="12"/>
                                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                                    </svg>
                                </div>
                                <div class="solar-value">${calculateDayDuration(data.daily.sunrise?.[0], data.daily.sunset?.[0])}</div>
                                <div class="solar-label">Duración del Día</div>
                            </div>
                            <div class="solar-item">
                                <div class="solar-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="4"/>
                                        <path d="M12 2v2"/>
                                        <path d="M12 20v2"/>
                                        <path d="m4.93 4.93 1.41 1.41"/>
                                        <path d="m17.66 17.66 1.41 1.41"/>
                                        <path d="M2 12h2"/>
                                        <path d="M20 12h2"/>
                                        <path d="m6.34 17.66-1.41 1.41"/>
                                        <path d="m19.07 4.93-1.41 1.41"/>
                                        <path d="M12 6v2"/>
                                        <path d="M12 16v2"/>
                                    </svg>
                                </div>
                                <div class="solar-value">
                                    ${data.current.uv_index !== undefined ?
                            `${Math.round(data.current.uv_index)} <span class="uv-badge ${getUVCategory(data.current.uv_index).class}">${getUVCategory(data.current.uv_index).label}</span>` :
                            (data.daily.uv_index_max?.[0] !== undefined ?
                                `${Math.round(data.daily.uv_index_max[0])} <span class="uv-badge ${getUVCategory(data.daily.uv_index_max[0]).class}">${getUVCategory(data.daily.uv_index_max[0]).label}</span>` :
                                '--')
                        }
                                </div>
                                <div class="solar-label">Índice UV</div>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Profile Selector (Compact) -->
                    <div class="card profile-selector">
                        <div class="card-header">
                            <span class="card-title">Tu Perfil</span>
                        </div>
                        <div class="profile-grid">
                            ${Object.entries(PROFILES).map(([key, profile]) => `
                                <button class="profile-btn ${currentProfile === key ? 'active' : ''} ${profile.link ? 'has-link' : ''}" 
                                        onclick="${profile.link ? `window.location.href='${profile.link}'` : `selectProfile('${key}')`}"
                                        aria-label="${profile.link ? 'Ir a ' + profile.name : 'Seleccionar perfil ' + profile.name}"
                                        aria-pressed="${currentProfile === key}">
                                    <span class="icon" aria-hidden="true">${profile.icon}</span>
                                    <span>${profile.name}</span>
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Índice de Riesgo -->
                    <div class="card risk-score-card">
                        <div class="card-header">
                            <span class="card-title">Índice de Riesgo</span>
                        </div>
                        <div class="risk-gauge">
                            <svg viewBox="0 0 200 200" aria-label="Índice de riesgo ${risks.score.toFixed(1)} de 5">
                                <circle class="risk-gauge-bg" cx="100" cy="100" r="85"></circle>
                                <circle class="risk-gauge-fill" cx="100" cy="100" r="85"
                                    stroke="${category.color}"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${offset}">
                                </circle>
                            </svg>
                            <div class="risk-score-value">
                                <div class="risk-score-number">${risks.score.toFixed(1)}</div>
                                <div class="risk-score-label">de 5</div>
                            </div>
                        </div>
                        <div class="risk-category ${category.class}">${category.name}</div>
                        
                        <div class="risk-factors">
                            <div class="risk-factor">
                                <span class="risk-factor-name"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg> Temp</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${risks.tempRisk}%; background: ${getRiskColor(risks.tempRisk)};"></div>
                                </div>
                                <span class="risk-factor-value">${risks.tempRisk}%</span>
                            </div>
                            <div class="risk-factor">
                                <span class="risk-factor-name"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg> Viento</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${risks.windRisk}%; background: ${getRiskColor(risks.windRisk)};"></div>
                                </div>
                                <span class="risk-factor-value">${risks.windRisk}%</span>
                            </div>
                            <div class="risk-factor">
                                <span class="risk-factor-name"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M16 14v6"/><path d="M8 14v6"/><path d="M12 16v6"/></svg> Lluvia</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${risks.precipRisk}%; background: ${getRiskColor(risks.precipRisk)};"></div>
                                </div>
                                <span class="risk-factor-value">${risks.precipRisk}%</span>
                            </div>
                            <div class="risk-factor">
                                <span class="risk-factor-name"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg> Rayos</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${risks.stormRisk}%; background: ${getRiskColor(risks.stormRisk)};"></div>
                                </div>
                                <span class="risk-factor-value">${risks.stormRisk}%</span>
                            </div>
                            <div class="risk-factor">
                                <span class="risk-factor-name"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="5" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/><circle cx="12" cy="19" r="1"/></svg> Granizo</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${risks.hailRisk}%; background: ${getRiskColor(risks.hailRisk)};"></div>
                                </div>
                                <span class="risk-factor-value">${risks.hailRisk}%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Recommendation -->
                    <div class="card recommendation-card">
                        <div class="card-header">
                            <span class="card-title">Recomendación</span>
                        </div>
                        <p class="recommendation-text">${recommendation}</p>
                    </div>
                </div>

                <!-- Sidebar: Map + Timeline -->
                <div class="sidebar">
                    <!-- Windy Map Embed -->
                    <div class="windy-map-card">
                        <div class="windy-map-header">
                            <span class="windy-map-title"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg> Mapa en Vivo</span>
                            <div class="windy-layer-toggle">
                                <button class="layer-btn active" onclick="changeWindyLayer('wind')" title="Viento" aria-label="Ver capa de viento"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg></button>
                                <button class="layer-btn" onclick="changeWindyLayer('rain')" title="Lluvia" aria-label="Ver capa de lluvia"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M16 14v6"/><path d="M8 14v6"/><path d="M12 16v6"/></svg></button>
                                <button class="layer-btn" onclick="changeWindyLayer('temp')" title="Temperatura" aria-label="Ver capa de temperatura"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg></button>
                            </div>
                        </div>
                        <div class="windy-map-container">
                            <iframe id="windy-iframe"
                                src="https://embed.windy.com/embed2.html?lat=${CONFIG.location.lat.toFixed(1)}&lon=${CONFIG.location.lon.toFixed(1)}&detailLat=${CONFIG.location.lat.toFixed(1)}&detailLon=${CONFIG.location.lon.toFixed(1)}&zoom=5&level=surface&overlay=wind&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C"
                                allowfullscreen>
                            </iframe>
                        </div>
                    </div>

                    <!-- Timeline Slider -->
                    <div class="timeline-card">
                        <div class="timeline-header">
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <span class="timeline-title"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg> Timeline</span>
                                <span style="font-size: 0.65rem; color: var(--gray-400); font-weight: 400; line-height: 1.2;">
                                    Pronóstico meteorológico por hora
                                    ${(() => {
                        let sources = [];
                        // Frontend-only: usar fuente desde data.frontend
                        if (data.frontend && data.frontend.source) {
                            sources = [data.frontend.source];
                        } else {
                            sources = ['open_meteo']; // Fuente por defecto
                        }
                        const sourceText = sources.length > 0 ? formatSourceNames(sources) : 'Open-Meteo';
                        return `• Modelo: ${sourceText}`;
                    })()}
                                </span >
                            </div >
            <span class="timeline-current" id="timeline-hour">Ahora</span>
                        </div >
                        <div class="timeline-slider-container">
                            <div class="timeline-slider-track">
                                <div class="timeline-slider-progress" id="timeline-progress" style="width: 0%"></div>
                        </div>
                        <input type="range" class="timeline-slider" id="timeline-slider" 
                               min="0" max="23" value="0" 
                                   aria-label="Seleccionar hora del pronóstico"
                                   aria-valuemin="0" aria-valuemax="23" aria-valuenow="0"
                               oninput="updateTimeline(this.value)">
                        </div>
                        <div class="timeline-labels">
                            ${(() => {
                        // Función para formatear hora en formato hh hs
                        const formatTimelineLabel = (timeString) => {
                            if (!timeString) return '-- hs';
                            try {
                                const date = new Date(timeString);
                                const hour = date.toLocaleTimeString('es-AR', {
                                    hour: '2-digit',
                                    hour12: false
                                });
                                return hour + ' hs';
                            } catch {
                                return '-- hs';
                            }
                        };

                        // Calcular horas para las etiquetas
                        if (!hourly || !hourly.time || !Array.isArray(hourly.time) || hourly.time.length === 0) {
                            return '<span>Ahora</span><span>-- hs</span><span>-- hs</span><span>-- hs</span>';
                        }

                        const now = new Date();
                        const currentTime = now.getTime();
                        // Buscar la primera hora que sea >= a la hora actual (puede ser del día siguiente)
                        const startIndex = hourly.time.findIndex(t => {
                            if (!t) return false;
                            try {
                                const date = new Date(t);
                                return date.getTime() >= currentTime;
                            } catch {
                                return false;
                            }
                        });
                        const safeStartIndex = startIndex >= 0 ? startIndex : 0;

                        // Obtener horas para +6hs, +12hs, +24hs
                        const hour6 = safeStartIndex + 6 < hourly.time.length ? hourly.time[safeStartIndex + 6] : null;
                        const hour12 = safeStartIndex + 12 < hourly.time.length ? hourly.time[safeStartIndex + 12] : null;
                        const hour24 = safeStartIndex + 23 < hourly.time.length ? hourly.time[safeStartIndex + 23] : null;

                        return `
                        <span>Ahora</span>
                        <span>${hour6 ? formatTimelineLabel(hour6) : '--:--'}</span>
                        <span>${hour12 ? formatTimelineLabel(hour12) : '--:--'}</span>
                        <span>${hour24 ? formatTimelineLabel(hour24) : '--:--'}</span>
                    `;
                    })()}
                        </div>
                        <div class="timeline-forecast" id="timeline-forecast">
                            ${(() => {
                        // Validar que hourly existe y tiene datos
                        if (!hourly || !hourly.time || !Array.isArray(hourly.time) || hourly.time.length === 0) {
                            return '<div style="padding: 1rem; text-align: center; color: var(--gray-400);">No hay datos disponibles</div>';
                        }

                        // Encontrar índice de la hora actual
                        const now = new Date();
                        const currentTime = now.getTime();
                        // Buscar la primera hora que sea >= a la hora actual (puede ser del día siguiente)
                        const startIndex = hourly.time.findIndex(t => {
                            if (!t) return false;
                            try {
                                const date = new Date(t);
                                return date.getTime() >= currentTime;
                            } catch {
                                return false;
                            }
                        });
                        const safeStartIndex = startIndex >= 0 ? startIndex : 0;

                        return Array.from({ length: 24 }, (_, i) => {
                            const idx = safeStartIndex + i;
                            if (idx >= hourly.time.length || !hourly.time[idx]) return '';

                            // Validar que los datos existen antes de acceder
                            const temp = hourly.temperature_2m && hourly.temperature_2m[idx] !== undefined
                                ? hourly.temperature_2m[idx]
                                : null;
                            const wind = hourly.wind_speed_10m && hourly.wind_speed_10m[idx] !== undefined
                                ? hourly.wind_speed_10m[idx]
                                : null;
                            const weatherCode = hourly.weather_code && hourly.weather_code[idx] !== undefined
                                ? hourly.weather_code[idx]
                                : 0;

                            if (temp === null && wind === null) return '';

                            // Formatear hora real en formato hh hs
                            const formatTimelineTime = (timeString) => {
                                if (!timeString) return '-- hs';
                                try {
                                    const date = new Date(timeString);
                                    const hour = date.toLocaleTimeString('es-AR', {
                                        hour: '2-digit',
                                        hour12: false
                                    });
                                    return hour + ' hs';
                                } catch {
                                    return '-- hs';
                                }
                            };

                            const timeString = hourly.time[idx];
                            const formattedTime = i === 0 ? 'Ahora' : formatTimelineTime(timeString);

                            return `
                                        <div class="forecast-item ${i === 0 ? 'active' : ''}" data-hour="${i}" title="${(() => {
                                    let sources = [];
                                    // Frontend-only: usar fuente desde data.frontend
                                    if (data.frontend && data.frontend.source) {
                                        sources = [data.frontend.source];
                                    } else {
                                        sources = ['open_meteo']; // Fuente por defecto
                                    }
                                    const sourceText = sources.length > 0 ? formatSourceNames(sources) : 'Open-Meteo';
                                    const timeLabel = i === 0 ? 'Condiciones actuales' : formatTimelineTime(timeString);
                                    return `Pronóstico meteorológico: ${timeLabel} • Modelo: ${sourceText}`;
                                })()}">
                                            <div class="forecast-time">${formattedTime}</div>
                                            <div class="forecast-icon">${getWeatherIcon(weatherCode)}</div>
                                            <div class="forecast-temp">${temp !== null ? Math.round(temp) : '--'}°</div>
                                            <div class="forecast-wind">${wind !== null ? Math.round(wind) : '--'} km/h</div>
                                        </div>
        `;
                        }).join('');
                    })()}
                        </div>
                    </div>

                </div>
                </div> <!-- End main-grid -->

                <!-- Footer Profesional -->
                <footer class="footer">
                    <div class="footer-content">
                        <div class="footer-brand">
                            <img src="assets/images/logos/Logo.png" alt="SkyPulse" class="footer-logo">
                            <div class="footer-brand-text">
                                <div class="footer-brand-name">SkyPulse</div>
                                <div class="footer-brand-tagline">El clima traducido a riesgo real</div>
                            </div>
                        </div>
                        
                        <div class="footer-links">
                            <a href="dashboard.html" class="footer-link">Panel</a>
                            <a href="aviacion-demo.html" class="footer-link">Aviación</a>
                        </div>
                        
                        <div class="footer-divider"></div>
                        
                        <div class="footer-sources">
                            Datos de <a href="https://open-meteo.com" target="_blank">Open-Meteo</a> • 
                            <a href="https://aviationweather.gov" target="_blank">Aviation Weather Center</a> • 
                            <a href="https://www.smn.gob.ar" target="_blank">SMN Argentina</a>
                        </div>
                        
                        <div class="disclaimer">
                            ⚠️ Interpretación operativa. Para decisiones críticas, consulte fuentes oficiales.
                        </div>
                        
                        <a href="investigacion-tecnica.html" class="footer-research-badge" target="_blank">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                                <polyline points="14 2 14 8 20 8" />
                                <line x1="16" y1="13" x2="8" y2="13" />
                                <line x1="16" y1="17" x2="8" y2="17" />
                                <polyline points="10 9 9 9 8 9" />
                            </svg>
                            Investigación Técnica y Datos Oficiales
                        </a>
                        
                        <div class="footer-copyright">
                            © 2025 SkyPulse. Todos los derechos reservados.
                        </div>
                    </div>
                </footer>
            `;

                // Inicializar event listeners para metric tooltips (Fase 2)
                initializeMetricTooltips(data, risks);

                // Animar risk gauge y barras de factores
                if (window.AnimeUtils && window.AnimeUtils.animateRiskGauge) {
                    const riskFactors = [
                        { name: 'temp', value: risks.tempRisk },
                        { name: 'wind', value: risks.windRisk },
                        { name: 'precip', value: risks.precipRisk },
                        { name: 'storm', value: risks.stormRisk },
                        { name: 'hail', value: risks.hailRisk }
                    ];

                    // Convertir score de 0-5 a 0-100 para el gauge (el número se mostrará correctamente en la función)
                    const riskScorePercent = (risks.score / 5) * 100;

                    // Esperar un frame para que el DOM esté listo
                    requestAnimationFrame(() => {
                        window.AnimeUtils.animateRiskGauge(riskScorePercent, riskFactors, {
                            gaugeSelector: '.risk-gauge-fill',
                            numberSelector: '.risk-score-number',
                            barSelector: '.risk-factor-fill',
                            // Pasar el score original (0-5) para mostrarlo correctamente
                            originalScore: risks.score
                        });
                    });
                }
            } catch (renderError) {
                console.error('[RenderDashboard] Error renderizando:', renderError);
                console.error('[RenderDashboard] Stack:', renderError.stack);
                const app = document.getElementById('app');
                if (app) {
                    // Limpiar contenido anterior
                    while (app.firstChild) {
                        app.removeChild(app.firstChild);
                    }

                    const errorCard = createSafeElement('div', {
                        className: 'card',
                        style: 'grid-column: 1 / -1; text-align: center; padding: 3rem;'
                    });
                    errorCard.appendChild(createSafeElement('div', { style: 'font-size: 3rem; margin-bottom: 1rem;' }, '⚠️'));
                    errorCard.appendChild(createSafeElement('h2', { style: 'margin-bottom: 0.5rem;' }, 'Error al Renderizar'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-400);' }, `Error: ${escapeHtml(renderError.message || 'Error desconocido')}`));

                    const reloadBtn = createSafeElement('button', {
                        style: 'margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--windy-cyan); border: none; border-radius: 8px; color: #000; font-weight: 600; cursor: pointer;'
                    }, 'Recargar');
                    reloadBtn.addEventListener('click', () => location.reload());
                    errorCard.appendChild(reloadBtn);

                    app.appendChild(errorCard);
                }
                throw renderError; // Re-lanzar para que init() lo capture
            }
        };

        // ============ INITIALIZE METRIC TOOLTIPS ============
        const initializeMetricTooltips = (data, risks) => {
            const metricCards = document.querySelectorAll('.metric-card[data-metric]');

            metricCards.forEach(card => {
                const metricType = card.getAttribute('data-metric');

                // Event listeners para hover
                card.addEventListener('mouseenter', (e) => {
                    // Cancelar cualquier timeout de ocultación pendiente
                    if (metricTooltip.hideTimeout) {
                        clearTimeout(metricTooltip.hideTimeout);
                        metricTooltip.hideTimeout = null;
                    }
                    metricTooltip.show(card, metricType, data, risks);
                });

                card.addEventListener('mouseleave', (e) => {
                    // Ocultar tooltip cuando el mouse sale de la card
                    // Usar un pequeño delay para permitir que el mouse pase al tooltip
                    const relatedTarget = e.relatedTarget;
                    const tooltip = metricTooltip.currentTooltip;

                    // Si el mouse va al tooltip, no ocultar
                    if (tooltip && tooltip.contains(relatedTarget)) {
                        return;
                    }

                    // Ocultar inmediatamente
                    metricTooltip.hide();
                });
            });
        };

        const getRiskColor = (risk) => {
            if (risk >= 75) return '#DC2626';
            if (risk >= 50) return '#F97316';
            if (risk >= 30) return '#F59E0B';
            if (risk >= 15) return '#3B82F6';
            return '#10B981';
        };

        // Color del viento según dirección (rosa de los vientos)
        // Norte = rojo cálido, Sur = celeste frío
        const getWindColor = (degrees) => {
            const d = ((degrees % 360) + 360) % 360;

            if (d <= 45 || d > 315) {
                const t = d <= 45 ? d / 45 : (360 - d) / 45;
                return interpolateColor('#EF4444', '#F97316', t);
            } else if (d <= 135) {
                const t = (d - 45) / 90;
                return interpolateColor('#F97316', '#38BDF8', t);
            } else if (d <= 225) {
                const t = (d - 135) / 90;
                return interpolateColor('#38BDF8', '#14B8A6', t);
            } else {
                const t = (d - 225) / 90;
                return interpolateColor('#14B8A6', '#EF4444', t);
            }
        };

        const interpolateColor = (c1Hex, c2Hex, t) => {
            const c1 = parseInt(c1Hex.slice(1), 16);
            const c2 = parseInt(c2Hex.slice(1), 16);
            const r = Math.round(((c1 >> 16) & 255) + (((c2 >> 16) & 255) - ((c1 >> 16) & 255)) * t);
            const g = Math.round(((c1 >> 8) & 255) + (((c2 >> 8) & 255) - ((c1 >> 8) & 255)) * t);
            const b = Math.round((c1 & 255) + ((c2 & 255) - (c1 & 255)) * t);
            return `rgb(${r}, ${g}, ${b})`;
        };

        const getWindDirection = (degrees) => {
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
            return dirs[Math.round(degrees / 22.5) % 16];
        };

        // ============ WINDY MAP LAYER CHANGE ============
        const changeWindyLayer = (layer) => {
            const iframe = document.getElementById('windy-iframe');
            const layers = { wind: 'wind', rain: 'rain', temp: 'temp' };
            const baseUrl = 'https://embed.windy.com/embed2.html?lat=-31.4&lon=-64.2&detailLat=-31.4&detailLon=-64.2&zoom=5&level=surface&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C';
            iframe.src = baseUrl + '&overlay=' + layers[layer];

            // Toggle active button
            document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        };

        // ============ TIMELINE SLIDER ============
        const updateTimeline = (value) => {
            const hourLabel = document.getElementById('timeline-hour');
            const forecastItems = document.querySelectorAll('.forecast-item');
            const forecastContainer = document.getElementById('timeline-forecast');
            const progressBar = document.getElementById('timeline-progress');
            const labels = document.querySelectorAll('.timeline-labels span');

            // Usar animación de anime.js si está disponible
            if (window.AnimeUtils && window.AnimeUtils.animateTimelineUpdate && hourLabel && progressBar) {
                window.AnimeUtils.animateTimelineUpdate(value, {
                    hourLabel,
                    progressBar,
                    forecastItems: Array.from(forecastItems),
                    labels: Array.from(labels)
                });

                // Scroll to active item (mantener funcionalidad)
                const activeItem = forecastContainer?.querySelector(`[data-hour="${value}"]`);
                if (activeItem && forecastContainer) {
                    activeItem.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                }
            } else {
                // Fallback al método anterior
                const progress = (value / 23) * 100;
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }

                if (hourLabel) {
                    hourLabel.textContent = value == 0 ? 'Ahora' : '+' + value + 'h';
                }

                if (labels.length) {
                    labels.forEach((label, i) => {
                        const thresholds = [0, 6, 12, 23];
                        const isActive = value >= thresholds[i] && (i === 3 || value < thresholds[i + 1]);
                        label.classList.toggle('active', isActive);
                    });
                }

                forecastItems.forEach(item => {
                    const itemHour = parseInt(item.dataset.hour);
                    item.classList.toggle('active', itemHour == value);
                });

                const activeItem = forecastContainer?.querySelector(`[data-hour="${value}"]`);
                if (activeItem && forecastContainer) {
                    activeItem.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                }
            }
        };

        // ============ PROFILE SELECTION ============
        const selectProfile = async (profile) => {
            currentProfile = profile;
            if (weatherData) {
                await renderDashboard(weatherData);
            }
        };

        // ============ MODERN LOADER ANIMATION ============
        const loaderMessages = [
            "Conectando...",
            "Obteniendo datos...",
            "Listo"
        ];

        const loaderCodeLines = [
            { num: 1, code: '<span class="loader-variable">forecast</span> <span class="loader-operator">=</span> <span class="loader-function">get_forecast</span><span class="loader-bracket">(</span>' },
            { num: 2, code: '    <span class="loader-variable">lat</span><span class="loader-operator">=</span><span class="loader-string">-31.42</span>, <span class="loader-variable">lon</span><span class="loader-operator">=</span><span class="loader-string">-64.18</span>  <span class="loader-comment"># Córdoba</span>' },
            { num: 3, code: '<span class="loader-bracket">)</span>' }
        ];

        const animateLoader = () => {
            const codeContainer = document.getElementById('loader-code');
            const messageEl = document.getElementById('loader-message');
            if (!codeContainer || !messageEl) return;

            // Función helper para crear elementos de línea
            const createLineElement = (line, index) => {
                const lineEl = document.createElement('div');
                lineEl.className = 'loader-code-line';
                const lineNumber = createSafeElement('span', { className: 'loader-line-number' }, line.num.toString());
                const codeContent = createSafeElement('span', { className: 'loader-code-content' });

                // Parsear HTML del código de forma segura
                const codeParser = new DOMParser();
                const codeDoc = codeParser.parseFromString(
                    line.code + (index === loaderCodeLines.length - 1 ? '<span class="loader-cursor"></span>' : ''),
                    'text/html'
                );
                if (codeDoc.body.firstChild) {
                    codeContent.appendChild(codeDoc.body.firstChild);
                }
                lineEl.appendChild(lineNumber);
                lineEl.appendChild(codeContent);

                return lineEl;
            };

            // Usar utilidad de anime.js si está disponible
            if (window.AnimeUtils && window.AnimeUtils.animateCodeLoader) {
                window.AnimeUtils.animateCodeLoader(
                    codeContainer,
                    messageEl,
                    loaderCodeLines,
                    loaderMessages,
                    createLineElement
                );
            } else {
                // Fallback al método anterior
                let lineIndex = 0;
                let messageIndex = 0;

                const addLine = () => {
                    if (lineIndex >= loaderCodeLines.length) return;

                    const line = loaderCodeLines[lineIndex];
                    const lineEl = createLineElement(line, lineIndex);
                    lineEl.style.animationDelay = `${lineIndex * 0.15}s`;
                    codeContainer.appendChild(lineEl);

                    requestAnimationFrame(() => lineEl.classList.add('visible'));

                    lineIndex++;
                    if (lineIndex < loaderCodeLines.length) {
                        setTimeout(addLine, 150);
                    }
                };

                const updateMessage = () => {
                    if (messageIndex >= loaderMessages.length) return;
                    messageEl.textContent = loaderMessages[messageIndex];
                    messageIndex++;
                    if (messageIndex < loaderMessages.length) {
                        setTimeout(updateMessage, 250);
                    }
                };

                addLine();
                updateMessage();
            }
        };

        // ============ SELECTOR DE UBICACIÓN ============
        let locationSelectorInitialized = false;
        let locationClickHandler = null;
        let documentClickHandler = null;
        let dropdownClickHandler = null;

        const initLocationSelector = () => {
            const locationElement = document.getElementById('header-location');
            const dropdown = document.getElementById('location-dropdown');
            const cityElement = document.getElementById('location-city');
            const coordsElement = document.getElementById('location-coords');

            // Si los elementos no existen, salir
            if (!locationElement || !dropdown || !cityElement || !coordsElement) {
                console.warn('[LocationSelector] Elementos no encontrados, reintentando...');
                return;
            }

            // Renderizar opciones del dropdown
            const renderLocationOptions = () => {
                dropdown.innerHTML = CONFIG.locations.map(loc => {
                    const isActive = CONFIG.location.name === loc.name;
                    return `
                        <div class="location-option ${isActive ? 'active' : ''}" data-location='${JSON.stringify(loc)}'>
                            <div class="location-option-content">
                                <span class="location-option-city">${loc.name}</span>
                                <span class="location-option-region">${loc.region}</span>
                                <span class="location-option-coords">${loc.coords}</span>
                            </div>
                            <div class="location-option-check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>
                    `;
                }).join('');
            };

            // Actualizar visual del header
            const updateLocationDisplay = () => {
                if (cityElement && coordsElement) {
                    cityElement.textContent = `${CONFIG.location.name}, ${CONFIG.location.region}`;
                    coordsElement.textContent = CONFIG.locations.find(l => l.name === CONFIG.location.name)?.coords || '';
                }
            };

            // Cambiar ubicación
            const changeLocation = async (newLocation) => {
                if (CONFIG.location.name === newLocation.name) {
                    return; // Ya está seleccionada
                }

                // Cerrar dropdown
                locationElement.classList.remove('active');
                dropdown.classList.remove('show');

                // Mostrar loader con transición usando anime.js
                const app = document.getElementById('app');

                if (window.AnimeUtils && window.AnimeUtils.animateLocationChange) {
                    // Usar animación coordinada
                    const timeline = window.AnimeUtils.animateLocationChange(app, async () => {
                        // Callback ejecutado durante fade out
                        // Actualizar configuración
                        CONFIG.location = { ...newLocation };

                        // Limpiar cache para forzar recarga con nueva ubicación
                        clearCache();

                        // Actualizar visual
                        updateLocationDisplay();

                        // Actualizar mapa de Windy
                        updateWindyMapLocation(newLocation.lat, newLocation.lon);

                        // Recargar datos meteorológicos (forzar refresh)
                        try {
                            const data = await fetchWeatherData(true); // forceRefresh = true
                            await renderDashboard(data);

                            // Actualizar solo el display después de renderizar
                            setTimeout(() => {
                                updateLocationDisplay();
                                renderLocationOptions();
                            }, 100);
                        } catch (error) {
                            console.error('Error al cargar datos de la nueva ubicación:', error);
                            // Mostrar mensaje de error al usuario
                            const errorMsg = document.createElement('div');
                            errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #DC2626; color: white; padding: 1rem; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                            errorMsg.textContent = 'Error al cargar datos de la nueva ubicación';
                            document.body.appendChild(errorMsg);
                            setTimeout(() => errorMsg.remove(), 5000);
                        }
                    });
                } else {
                    // Fallback al método anterior
                    app.style.opacity = '0';
                    app.style.transition = 'opacity 0.3s ease';

                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Actualizar configuración
                    CONFIG.location = { ...newLocation };

                    // Limpiar cache para forzar recarga con nueva ubicación
                    clearCache();

                    // Actualizar visual
                    updateLocationDisplay();

                    // Actualizar mapa de Windy
                    updateWindyMapLocation(newLocation.lat, newLocation.lon);

                    // Recargar datos meteorológicos (forzar refresh)
                    try {
                        const data = await fetchWeatherData(true); // forceRefresh = true
                        renderDashboard(data);

                        // Actualizar solo el display después de renderizar (sin reinicializar listeners)
                        setTimeout(() => {
                            updateLocationDisplay();
                            renderLocationOptions();
                        }, 100);

                        // Fade in
                        app.style.opacity = '1';
                    } catch (error) {
                        console.error('Error al cargar datos de la nueva ubicación:', error);
                        app.style.opacity = '1';
                        // Mostrar mensaje de error al usuario
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #DC2626; color: white; padding: 1rem; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                        errorMsg.textContent = 'Error al cargar datos de la nueva ubicación';
                        document.body.appendChild(errorMsg);
                        setTimeout(() => errorMsg.remove(), 5000);
                    }
                }
            };

            // Actualizar mapa de Windy
            const updateWindyMapLocation = (lat, lon) => {
                const iframe = document.getElementById('windy-iframe');
                if (iframe) {
                    const baseUrl = `https://embed.windy.com/embed2.html?lat=${lat.toFixed(1)}&lon=${lon.toFixed(1)}&detailLat=${lat.toFixed(1)}&detailLon=${lon.toFixed(1)}&zoom=5&level=surface&overlay=wind&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C`;
                    iframe.src = baseUrl;
                }
            };

            // Solo agregar event listeners si no están inicializados
            if (!locationSelectorInitialized) {
                // Toggle dropdown
                locationClickHandler = (e) => {
                    e.stopPropagation();
                    const isActive = locationElement.classList.contains('active');

                    if (isActive) {
                        locationElement.classList.remove('active');
                        dropdown.classList.remove('show');
                    } else {
                        locationElement.classList.add('active');
                        dropdown.classList.add('show');
                        renderLocationOptions();
                    }
                };
                locationElement.addEventListener('click', locationClickHandler);

                // Cerrar dropdown al hacer click fuera
                documentClickHandler = (e) => {
                    if (!locationElement.contains(e.target)) {
                        locationElement.classList.remove('active');
                        dropdown.classList.remove('show');
                    }
                };
                document.addEventListener('click', documentClickHandler);

                // Manejar selección de ubicación
                dropdownClickHandler = (e) => {
                    const option = e.target.closest('.location-option');
                    if (option) {
                        const locationData = JSON.parse(option.dataset.location);
                        changeLocation(locationData);
                    }
                };
                dropdown.addEventListener('click', dropdownClickHandler);

                locationSelectorInitialized = true;
            }

            // Inicializar visual
            updateLocationDisplay();
        };

        // ============ TIMER MANAGEMENT ============
        const timers = {
            clockInterval: null,
            refreshInterval: null,
            alertTimeouts: new Map(),

            clearAll() {
                if (this.clockInterval) {
                    clearInterval(this.clockInterval);
                    this.clockInterval = null;
                }
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
                this.alertTimeouts.forEach(timeout => clearTimeout(timeout));
                this.alertTimeouts.clear();
            }
        };

        // ============ INITIALIZE EVENT LISTENERS ============
        const initializeEventListeners = () => {
            // Inicializar botones de capas de Windy
            document.querySelectorAll('.layer-btn').forEach(btn => {
                // Remover listeners anteriores si existen
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);

                // Agregar nuevo listener
                const layer = newBtn.getAttribute('onclick')?.match(/changeWindyLayer\('(\w+)'\)/)?.[1];
                if (layer) {
                    newBtn.removeAttribute('onclick');
                    newBtn.addEventListener('click', (e) => {
                        changeWindyLayer(layer);
                        document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                        newBtn.classList.add('active');
                    });
                }
            });

            // Inicializar botones de perfiles
            document.querySelectorAll('[onclick*="selectProfile"]').forEach(btn => {
                const onclickAttr = btn.getAttribute('onclick');
                const profileMatch = onclickAttr?.match(/selectProfile\('(\w+)'\)/);
                const linkMatch = onclickAttr?.match(/window\.location\.href='([^']+)'/);

                if (profileMatch) {
                    btn.removeAttribute('onclick');
                    btn.addEventListener('click', () => selectProfile(profileMatch[1]));
                } else if (linkMatch) {
                    btn.removeAttribute('onclick');
                    btn.addEventListener('click', () => {
                        window.location.href = linkMatch[1];
                    });
                }
            });
        };

        // ============ INIT ============
        const init = async () => {
            // Limpiar timers anteriores si existen
            timers.clearAll();

            // Inicializar panel de alertas (Fase 3)
            updateClock();
            timers.clockInterval = setInterval(updateClock, 1000);

            // Iniciar animación del loader
            animateLoader();

            try {
                console.log('[Init] Iniciando carga de datos...');
                const data = await fetchWeatherData();
                console.log('[Init] Datos obtenidos:', data);

                // Validar que los datos tengan la estructura esperada
                if (!data || !data.current || !data.hourly) {
                    throw new Error('Datos incompletos recibidos de Open-Meteo');
                }

                // Delay mínimo para transición suave (reducido de 950ms a 300ms)
                await new Promise(resolve => setTimeout(resolve, 300));

                console.log('[Init] Renderizando dashboard...');
                try {
                    renderDashboard(data);
                    console.log('[Init] Dashboard renderizado correctamente');
                    // Inicializar event listeners después del render inicial
                    setTimeout(initializeEventListeners, 100);
                } catch (renderError) {
                    console.error('[Init] Error en renderDashboard:', renderError);
                    throw renderError;
                }

                // Inicializar selector de ubicación después de renderizar
                // Pequeño delay para asegurar que el DOM esté listo
                setTimeout(() => {
                    try {
                        initLocationSelector();
                        // Inicializar event listeners después del render
                        initializeEventListeners();
                    } catch (locationError) {
                        console.warn('[Init] Error inicializando selector de ubicación:', locationError);
                    }
                }, 100);

                // Auto-refresh con cleanup
                timers.refreshInterval = setInterval(async () => {
                    try {
                        const newData = await fetchWeatherData();
                        await renderDashboard(newData);
                        // Reinicializar event listeners después de cada render
                        setTimeout(initializeEventListeners, 100);
                    } catch (refreshError) {
                        console.error('[Auto-refresh] Error:', refreshError);
                    }
                }, CONFIG.refreshInterval);
            } catch (error) {
                console.error('[Init] Error crítico:', error);
                console.error('[Init] Stack trace:', error.stack);
                const app = document.getElementById('app');
                if (app) {
                    // Limpiar contenido anterior
                    while (app.firstChild) {
                        app.removeChild(app.firstChild);
                    }

                    const errorCard = createSafeElement('div', {
                        className: 'card',
                        style: 'grid-column: 1 / -1; text-align: center; padding: 3rem;'
                    });
                    errorCard.appendChild(createSafeElement('div', { style: 'font-size: 3rem; margin-bottom: 1rem;' }, '⚠️'));
                    errorCard.appendChild(createSafeElement('h2', { style: 'margin-bottom: 0.5rem;' }, 'Error de Conexión'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-400); margin-bottom: 1rem;' }, 'No se pudo conectar con la API meteorológica.'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-500); font-size: 0.875rem; margin-bottom: 1rem;' }, `Error: ${escapeHtml(error.message || 'Error desconocido')}`));

                    const retryBtn = createSafeElement('button', {
                        style: 'margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--windy-cyan); border: none; border-radius: 8px; color: #000; font-weight: 600; cursor: pointer;'
                    }, 'Reintentar');
                    retryBtn.addEventListener('click', () => location.reload());
                    errorCard.appendChild(retryBtn);

                    app.appendChild(errorCard);
                }
            }
        };

        // Make selectProfile global
        window.selectProfile = selectProfile;

        // ============ THEME TOGGLE ============
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;

        // Check for saved theme preference or default to dark
        const currentTheme = localStorage.getItem('theme') || 'dark';
        if (currentTheme === 'light') {
            body.classList.add('light');
        }

        function switchTheme() {
            body.classList.toggle('light');
            const isLight = body.classList.contains('light');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const isLight = body.classList.contains('light');

            if (!document.startViewTransition) {
                switchTheme();
                // Mejorar transición con anime.js si está disponible
                if (window.AnimeUtils && window.AnimeUtils.enhanceThemeTransition) {
                    window.AnimeUtils.enhanceThemeTransition(!isLight);
                }
                return;
            }

            document.startViewTransition(() => {
                switchTheme();
                // Mejorar transición con anime.js si está disponible
                if (window.AnimeUtils && window.AnimeUtils.enhanceThemeTransition) {
                    window.AnimeUtils.enhanceThemeTransition(!isLight);
                }
            });
        });

        // Start
        init();
    </script>
</body>

</html>