<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
    <meta name="theme-color" content="#001B3C">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Dashboard del tiempo SkyPulse: condiciones actuales, Ã­ndice de riesgo meteorolÃ³gico y mapa interactivo Windy.">
    <title>SkyPulse Panel - Riesgo MeteorolÃ³gico en Tiempo Real</title>
    <link rel="icon" type="image/png" href="assets/images/logos/Logo.png">
    <link rel="apple-touch-icon" href="assets/images/logos/Logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" as="style">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="dashboard.css">
</head>

<body>
    <button class="theme-toggle" id="themeToggle" aria-label="Cambiar tema" style="position:fixed;z-index:9999;right:1.5rem;bottom:1.5rem;width:48px;height:48px;border-radius:9999px;background:rgba(0,209,255,0.15);border:1px solid rgba(0,209,255,0.3);display:flex;align-items:center;justify-content:center;cursor:pointer;">
        <svg class="sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="5" />
            <line x1="12" y1="1" x2="12" y2="3" />
            <line x1="12" y1="21" x2="12" y2="23" />
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
            <line x1="1" y1="12" x2="3" y2="12" />
            <line x1="21" y1="12" x2="23" y2="12" />
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
        </svg>
        <svg class="moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
        </svg>
    </button>

    <header class="header">
        <div class="header-content">
            <div class="logo">
                <img src="assets/images/logos/Logo.png" alt="SkyPulse" class="logo-img">
                <div class="logo-text">
                    <h1>SkyPulse</h1>
                    <span>Panel de Riesgo MeteorolÃ³gico</span>
                </div>
            </div>
            <div class="header-location" id="header-location" title="Cambiar ubicaciÃ³n de monitoreo">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" />
                    <circle cx="12" cy="10" r="3" />
                </svg>
                <div class="header-location-text">
                    <span class="header-location-city" id="location-city">CÃ³rdoba, Argentina</span>
                    <span class="header-location-coords" id="location-coords">-31.42Â°N, -64.19Â°W</span>
                </div>
                <svg class="chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="width: 12px; height: 12px; margin-left: 4px;">
                    <polyline points="6 9 12 15 18 9" />
                </svg>
                <div class="location-dropdown" id="location-dropdown">
                    <!-- Se llena dinÃ¡micamente con JavaScript -->
                </div>
            </div>
            <div class="header-right">
                <div class="time-display">
                    <div class="label">Ãšltima actualizaciÃ³n</div>
                    <div class="time" id="current-time">Cargando...</div>
                    <div class="data-age" id="data-age" aria-live="polite">â€”</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Alert Stack Container (Fixed Position) -->
    <div class="alert-stack-container" id="alert-stack"></div>

    <main class="main-container" id="app">
        <div class="dashboard-skeleton" aria-busy="true" aria-live="polite">
            <div class="skeleton-main">
                <div class="skeleton-block skeleton-metrics">
                    <div class="skeleton skeleton-header"></div>
                    <div class="skeleton-metrics-grid">
                        <div class="skeleton-metric"><div class="skeleton skeleton-icon"></div><div class="skeleton skeleton-value"></div><div class="skeleton skeleton-label"></div></div>
                        <div class="skeleton-metric"><div class="skeleton skeleton-icon"></div><div class="skeleton skeleton-value"></div><div class="skeleton skeleton-label"></div></div>
                        <div class="skeleton-metric"><div class="skeleton skeleton-icon"></div><div class="skeleton skeleton-value"></div><div class="skeleton skeleton-label"></div></div>
                        <div class="skeleton-metric"><div class="skeleton skeleton-icon"></div><div class="skeleton skeleton-value"></div><div class="skeleton skeleton-label"></div></div>
                        <div class="skeleton-metric"><div class="skeleton skeleton-icon"></div><div class="skeleton skeleton-value"></div><div class="skeleton skeleton-label"></div></div>
                    </div>
                </div>
                <div class="skeleton-block skeleton-alert">
                    <div class="skeleton skeleton-icon"></div>
                    <div class="skeleton-content">
                        <div class="skeleton skeleton-line short"></div>
                        <div class="skeleton skeleton-line medium"></div>
                    </div>
                </div>
                <div class="skeleton-block skeleton-risk">
                    <div class="skeleton skeleton-gauge"></div>
                    <div class="skeleton skeleton-category"></div>
                    <div class="skeleton-risk-bars">
                        <div class="skeleton-risk-bar"><span class="skeleton skeleton-label"></span><div class="skeleton skeleton-bar"></div></div>
                        <div class="skeleton-risk-bar"><span class="skeleton skeleton-label"></span><div class="skeleton skeleton-bar"></div></div>
                        <div class="skeleton-risk-bar"><span class="skeleton skeleton-label"></span><div class="skeleton skeleton-bar"></div></div>
                    </div>
                </div>
                <p class="skeleton-status" id="loader-message">Cargando datos meteorolÃ³gicos...</p>
            </div>
            <div class="skeleton-sidebar">
                <div class="skeleton-block skeleton-map skeleton"></div>
                <div class="skeleton-block skeleton-timeline">
                    <div class="skeleton skeleton-header"></div>
                    <div class="skeleton skeleton-slider"></div>
                    <div class="skeleton-items">
                        <div class="skeleton skeleton-item"></div>
                        <div class="skeleton skeleton-item"></div>
                        <div class="skeleton skeleton-item"></div>
                        <div class="skeleton skeleton-item"></div>
                        <div class="skeleton skeleton-item"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Cliente API SkyPulse (mantenido para compatibilidad) -->
    <!-- Anime.js para animaciones avanzadas -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
    <!-- Utilidades de animaciÃ³n SkyPulse -->
    <script src="js/anime-utils.js"></script>
    <script src="js/api-client.js"></script>

    <!-- Nuevos mÃ³dulos Frontend-Only -->
    <script src="open-meteo-client.js"></script>
    <script src="meteosource-client.js"></script>
    <script src="alert-engine.js"></script>

    <script>
        // ============ CONFIGURACIÃ“N ============
        const CONFIG = {
            location: {
                name: 'CÃ³rdoba',
                region: 'CÃ³rdoba',
                lat: -31.4201,
                lon: -64.1888
            },
            locations: [
                {
                    name: 'CÃ³rdoba',
                    region: 'CÃ³rdoba',
                    lat: -31.4201,
                    lon: -64.1888,
                    coords: '-31.42Â°N, -64.19Â°W'
                },
                {
                    name: 'Resistencia',
                    region: 'Chaco',
                    lat: -27.4512,
                    lon: -58.9866,
                    coords: '-27.45Â°N, -58.99Â°W'
                },
                {
                    name: 'Mendoza',
                    region: 'Mendoza',
                    lat: -32.8895,
                    lon: -68.8458,
                    coords: '-32.89Â°N, -68.85Â°W'
                },
                {
                    name: 'Bs As (CABA)',
                    region: 'Buenos Aires (AEP)',
                    lat: -34.5592,
                    lon: -58.4156,
                    coords: '-34.56Â°N, -58.42Â°W'
                }
            ],
            refreshInterval: 300000, // 5 minutos
            // ============ CONFIGURACIÃ“N BACKEND ============
            // URL del backend (Render) - Habilitar cuando backend estÃ© activo
            // Para habilitar: descomentar la lÃ­nea siguiente
            // Para desarrollo local, usar localhost. Para producciÃ³n, usar Render
            backendUrl: 'https://skypulsear-api.onrender.com',  // Backend en Render
            apiKey: "skypulse-wrf-smn-aws",  // API key para acceso al sistema de modelos predictivos WRF-SMN (AWS S3)
            // Fuente de datos preferida: 'auto' (backend primero, luego Open-Meteo), 'backend', 'open-meteo'
            preferredSource: 'auto',
            // API Keys para fuentes meteorolÃ³gicas
            // Open-Meteo: No requiere API key (gratuito, sin lÃ­mites)
            // Windy: Requerida para fallback (opcional)
            // Meteosource: Requerida para alertas (opcional, puede usar Open-Meteo)
            windyApiKey: null, // âš ï¸ Opcional: Para fallback si Open-Meteo falla
            meteosourceApiKey: null, // âš ï¸ Opcional: Para alertas (puede usar Open-Meteo)
            // M3.2: Badge categorÃ­a de vuelo VFR/MVFR/IFR/LIFR (solo con backend)
            showFlightCategoryBadge: true
        };

        // Rehidratar ubicaciÃ³n desde localStorage (si existe)
        try {
            const storedLocation = localStorage.getItem('skypulse_location');
            if (storedLocation) {
                const loc = JSON.parse(storedLocation);
                if (loc && typeof loc.lat === 'number' && typeof loc.lon === 'number' && loc.name) {
                    const inList = CONFIG.locations.find(locItem => locItem.name === loc.name && locItem.lat === loc.lat && locItem.lon === loc.lon);
                    CONFIG.location = inList ? { ...inList } : { name: loc.name, region: loc.region || '', lat: loc.lat, lon: loc.lon };
                }
            }
        } catch (e) {
            console.warn('[Config] Error rehidratando ubicaciÃ³n:', e);
        }

        // Rehidratar fuente preferida desde localStorage
        try {
            const storedSource = localStorage.getItem('skypulse_preferred_source');
            if (storedSource === 'backend' || storedSource === 'open-meteo' || storedSource === 'auto') {
                CONFIG.preferredSource = storedSource;
            }
        } catch (e) {
            console.warn('[Config] Error rehidratando fuente preferida:', e);
        }

        // ============ INICIALIZACIÃ“N FRONTEND-ONLY ============
        // Open-Meteo como fuente principal (gratuito, sin API key)
        // Windy como fallback (opcional, requiere API key)
        // Meteosource para alertas (opcional, puede usar Open-Meteo)

        // Intentar obtener API keys desde mÃºltiples fuentes
        let windyApiKey = CONFIG.windyApiKey;
        let meteosourceApiKey = CONFIG.meteosourceApiKey;

        // Windy API Key
        if (!windyApiKey && typeof window !== 'undefined' && window.WINDY_API_KEY) {
            windyApiKey = window.WINDY_API_KEY;
            console.log('[SkyPulse] Windy API key obtenida desde window.WINDY_API_KEY');
        }

        // Meteosource API Key
        if (!meteosourceApiKey && typeof window !== 'undefined' && window.METEOSOURCE_API_KEY) {
            meteosourceApiKey = window.METEOSOURCE_API_KEY;
            console.log('[SkyPulse] Meteosource API key obtenida desde window.METEOSOURCE_API_KEY');
        }

        // Inicializar cliente Open-Meteo (principal) con fallback a Windy
        let openMeteoClient = null;
        let meteosourceClient = null;
        let alertEngine = null;
        let alertRules = null;

        // FunciÃ³n para inicializar clientes (sincrÃ³nica para evitar race conditions)
        const initializeClients = () => {
            try {
                // Inicializar Open-Meteo (principal) con fallback a Windy
                openMeteoClient = new OpenMeteoClient(windyApiKey);
                console.log('[SkyPulse] âœ… Cliente Open-Meteo inicializado' + (windyApiKey ? ' (con fallback Windy)' : ' (sin fallback)'));
            } catch (error) {
                console.error('[SkyPulse] Error inicializando cliente Open-Meteo:', error);
            }

            // Inicializar Meteosource (opcional, para alertas)
            if (meteosourceApiKey) {
                try {
                    meteosourceClient = new MeteosourceClient(meteosourceApiKey);
                    console.log('[SkyPulse] âœ… Cliente Meteosource inicializado (para alertas)');
                } catch (error) {
                    console.error('[SkyPulse] Error inicializando cliente Meteosource:', error);
                }
            } else {
                console.log('[SkyPulse] âš ï¸ Meteosource no configurado, usando Open-Meteo para alertas');
            }
        };

        // Inicializar clientes inmediatamente (sincrÃ³nico)
        initializeClients();

        // Cargar reglas de alertas de forma asÃ­ncrona (manejo 404: reglas por defecto)
        (async () => {
            try {
                const rulesResponse = await fetch('alert-rules.json');
                if (!rulesResponse.ok) {
                    if (rulesResponse.status === 404) {
                        alertRules = {};
                        console.warn('[SkyPulse] alert-rules.json no encontrado (404), usando reglas por defecto');
                    } else {
                        throw new Error(`HTTP ${rulesResponse.status}: ${rulesResponse.statusText}`);
                    }
                } else {
                    alertRules = await rulesResponse.json();
                }
                alertEngine = new AlertEngine(alertRules);
                console.log('[SkyPulse] Motor de alertas inicializado');
            } catch (error) {
                console.error('[SkyPulse] Error cargando reglas de alertas:', error);
                alertRules = {};
                try {
                    alertEngine = new AlertEngine(alertRules);
                } catch (_) {}
            }
        })();

        // ============ CLIENTE API BACKEND ============
        // Habilitar cuando backend estÃ© activo
        let api = null;
        if (CONFIG.backendUrl) {
            try {
                // Verificar que la API key estÃ© configurada
                if (!CONFIG.apiKey) {
                    console.error('[SkyPulse] âŒ API key no configurada en CONFIG.apiKey');
                } else {
                    console.log('[SkyPulse] ðŸ”‘ API key configurada:', CONFIG.apiKey.substring(0, 10) + '...');
                }
                api = new SkyPulseAPI(CONFIG.backendUrl, CONFIG.apiKey);
                console.log('[SkyPulse] âœ… Cliente API backend inicializado:', CONFIG.backendUrl);
                console.log('[SkyPulse] ðŸ”‘ API key en cliente:', api.apiKey ? api.apiKey.substring(0, 10) + '...' : 'NO CONFIGURADA');
            } catch (error) {
                console.warn('[SkyPulse] âš ï¸ Error inicializando cliente API backend:', error);
            }
        } else {
            console.log('[SkyPulse] âš ï¸ Backend URL no configurado, usando cÃ¡lculo local');
        }

        // ============ CACHE SYSTEM (TTL 30 min) con localStorage ============
        const CACHE_TTL = 30 * 60 * 1000; // 30 minutos en ms
        const CACHE_KEY = 'skypulse_weather_cache';
        // v2: invalida cache anterior donde wind_speed_10m podÃ­a estar en m/s sin convertir a km/h
        const CACHE_SCHEMA_VERSION = 2;
        const dashboardCache = {
            data: null,
            timestamp: null,
            locationKey: null // Clave para validar que el cache corresponde a la ubicaciÃ³n actual
        };

        // Cargar cache desde localStorage al inicio (con versionado y validaciÃ³n)
        try {
            const storedCache = localStorage.getItem(CACHE_KEY);
            if (storedCache) {
                const parsed = JSON.parse(storedCache);
                const validVersion = parsed.version === CACHE_SCHEMA_VERSION;
                const validData = parsed.data && (typeof parsed.data.current === 'object' || typeof parsed.data.frontend === 'object');
                if (validVersion && validData) {
                    dashboardCache.data = parsed.data;
                    dashboardCache.timestamp = parsed.timestamp;
                    dashboardCache.locationKey = parsed.locationKey;
                    console.log('[Cache] Cache cargado desde localStorage');
                } else {
                    localStorage.removeItem(CACHE_KEY);
                }
            }
        } catch (e) {
            console.warn('[Cache] Error cargando cache desde localStorage:', e);
            try { localStorage.removeItem(CACHE_KEY); } catch (_) {}
        }

        const getFromCache = () => {
            // Primero verificar cache en memoria
            if (dashboardCache.data) {
                // Verificar que el cache corresponde a la ubicaciÃ³n actual
                if (dashboardCache.locationKey !== `${CONFIG.location.lat}-${CONFIG.location.lon}`) {
                    console.log('[Cache] UbicaciÃ³n cambiÃ³, invalidando cache');
                    dashboardCache.data = null;
                    dashboardCache.timestamp = null;
                    dashboardCache.locationKey = null;
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }
                const now = Date.now();
                if (now - dashboardCache.timestamp > CACHE_TTL) {
                    console.log('[Cache] Cache expirado');
                    dashboardCache.data = null;
                    dashboardCache.timestamp = null;
                    dashboardCache.locationKey = null;
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }
                return dashboardCache.data;
            }

            // Si no hay en memoria, intentar desde localStorage (con versionado y validaciÃ³n)
            try {
                const storedCache = localStorage.getItem(CACHE_KEY);
                if (storedCache) {
                    const parsed = JSON.parse(storedCache);
                    const validVersion = parsed.version === CACHE_SCHEMA_VERSION;
                    const validData = parsed.data && (typeof parsed.data.current === 'object' || typeof parsed.data.frontend === 'object');
                    if (!validVersion || !validData) {
                        localStorage.removeItem(CACHE_KEY);
                        return null;
                    }
                    const locationKey = `${CONFIG.location.lat}-${CONFIG.location.lon}`;

                    if (parsed.locationKey === locationKey) {
                        const now = Date.now();
                        if (now - parsed.timestamp <= CACHE_TTL) {
                            // Restaurar en memoria
                            dashboardCache.data = parsed.data;
                            dashboardCache.timestamp = parsed.timestamp;
                            dashboardCache.locationKey = parsed.locationKey;
                            console.log('[Cache] Cache restaurado desde localStorage');
                            return parsed.data;
                        } else {
                            localStorage.removeItem(CACHE_KEY);
                        }
                    }
                }
            } catch (e) {
                console.warn('[Cache] Error leyendo localStorage:', e);
            }

            return null;
        };

        const setToCache = (data) => {
            dashboardCache.data = data;
            dashboardCache.timestamp = Date.now();
            dashboardCache.locationKey = `${CONFIG.location.lat}-${CONFIG.location.lon}`;

            // Guardar tambiÃ©n en localStorage (con versionado)
            try {
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    version: CACHE_SCHEMA_VERSION,
                    data: data,
                    timestamp: dashboardCache.timestamp,
                    locationKey: dashboardCache.locationKey
                }));
                console.log('[Cache] Cache guardado en localStorage');
            } catch (e) {
                console.warn('[Cache] Error guardando en localStorage:', e);
            }
        };

        const clearCache = () => {
            dashboardCache.data = null;
            dashboardCache.timestamp = null;
            dashboardCache.locationKey = null;
            try { localStorage.removeItem(CACHE_KEY); } catch (e) { console.warn('[Cache] Error limpiando localStorage:', e); }
        };

        const getCacheAge = () => {
            if (!dashboardCache.timestamp) return null;
            return Math.floor((Date.now() - dashboardCache.timestamp) / 60000);
        };

        // Un solo perfil: general (selector de perfil eliminado)
        const PROFILE_FIXED = 'general';
        const GENERAL_WEIGHTS = { temp: 0.25, wind: 0.25, precip: 0.25, pattern: 0.25 };

        let weatherData = null;

        // ============ UTILIDADES ============

        // ============ HELPER FUNCTIONS - SEGURIDAD ============
        /**
         * Escapa HTML para prevenir XSS
         * @param {string} text - Texto a escapar
         * @returns {string} Texto escapado
         */
        const escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        /**
         * Crea un elemento de forma segura
         * @param {string} tag - Nombre del tag
         * @param {Object} attributes - Atributos del elemento
         * @param {string|Node|Array} content - Contenido (texto, nodo o array de nodos)
         * @returns {HTMLElement} Elemento creado
         */
        const createSafeElement = (tag, attributes = {}, content = null) => {
            const element = document.createElement(tag);

            // Agregar atributos
            for (const [key, value] of Object.entries(attributes)) {
                if (key === 'className') {
                    element.className = value;
                } else if (key === 'dataset') {
                    for (const [dataKey, dataValue] of Object.entries(value)) {
                        element.dataset[dataKey] = dataValue;
                    }
                } else if (key.startsWith('on')) {
                    // No permitir event handlers inline
                    console.warn(`Event handler inline detectado: ${key}. Usar addEventListener en su lugar.`);
                } else {
                    element.setAttribute(key, value);
                }
            }

            // Agregar contenido
            if (content !== null) {
                if (typeof content === 'string') {
                    element.textContent = content;
                } else if (content instanceof Node) {
                    element.appendChild(content);
                } else if (Array.isArray(content)) {
                    content.forEach(item => {
                        if (item instanceof Node) {
                            element.appendChild(item);
                        } else if (typeof item === 'string') {
                            element.appendChild(document.createTextNode(item));
                        }
                    });
                }
            }

            return element;
        };

        /**
         * Crea SVG de forma segura desde string
         * @param {string} svgString - String del SVG
         * @returns {DocumentFragment} Fragmento con el SVG
         */
        const createSafeSVG = (svgString) => {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;
            const fragment = document.createDocumentFragment();
            fragment.appendChild(svgElement);
            return fragment;
        };
        const formatTime = (date) => date.toLocaleTimeString('es-AR', {
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });

        const updateClock = () => {
            const now = new Date();
            const timeEl = document.getElementById('current-time');
            if (timeEl) {
                timeEl.textContent = now.toLocaleString('es-AR', {
                    day: 'numeric', month: 'short', year: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
            }
            const ageEl = document.getElementById('data-age');
            if (ageEl) {
                const ageMin = getCacheAge();
                if (ageMin === null) {
                    ageEl.textContent = 'â€”';
                } else if (ageMin < 1) {
                    ageEl.textContent = 'Datos en vivo';
                } else {
                    ageEl.textContent = `Actualizado hace ${ageMin} min`;
                }
            }
        };

        // ============ UTILIDADES SOLARES ============
        const formatSolarTime = (isoString) => {
            if (!isoString) return '--:--';
            const date = new Date(isoString);
            return date.toLocaleTimeString('es-AR', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
        };

        const calculateDayDuration = (sunrise, sunset) => {
            if (!sunrise || !sunset) return '--:--';
            const start = new Date(sunrise);
            const end = new Date(sunset);
            const diff = end - start;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        };

        const getUVCategory = (uvIndex) => {
            if (!uvIndex && uvIndex !== 0) return { label: 'N/A', class: 'low' };
            if (uvIndex >= 11) return { label: 'Extremo', class: 'extreme' };
            if (uvIndex >= 8) return { label: 'Muy Alto', class: 'very-high' };
            if (uvIndex >= 6) return { label: 'Alto', class: 'high' };
            if (uvIndex >= 3) return { label: 'Moderado', class: 'moderate' };
            return { label: 'Bajo', class: 'low' };
        };

        // ============ FETCH DATOS METEOROLÃ“GICOS ============
        // ============ FRONTEND-ONLY: Meteosource + AlertEngine ============

        /**
         * Obtiene datos meteorolÃ³gicos actuales desde Open-Meteo (frontend-only).
         * Backend pausado temporalmente.
         */
        const fetchCurrentWeather = async () => {
            // Esta funciÃ³n ya no se usa directamente, se obtiene desde Open-Meteo en fetchWeatherData
            // Mantenida para compatibilidad
            return null;
        };

        /**
         * Obtiene pronÃ³stico futuro desde Open-Meteo (frontend-only).
         * Backend pausado - migrando a WRF-SMN desde AWS S3.
         */
        const fetchForecast = async (hours = 24) => {
            // Esta funciÃ³n ya no se usa directamente, se obtiene desde Open-Meteo en fetchWeatherData
            // Mantenida para compatibilidad
            // FUTURO: Usar WRF-SMN desde AWS S3 cuando estÃ© implementado
            return { forecast: [], hours: hours, sources: ['open_meteo'] };
        };

        /**
         * Calcula risk score (frontend-only, calculado localmente).
         * Backend pausado - toda la lÃ³gica estÃ¡ en calculateRisks().
         * 
         * NOTA: Esta funciÃ³n es solo para compatibilidad. El cÃ¡lculo real se hace en calculateRisks().
         */
        const fetchRiskScore = async (profile, hoursAhead = 6) => {
            // Risk score se calcula localmente en calculateRisks() (lÃ­nea ~4185)
            // Retornar estructura bÃ¡sica para compatibilidad
            return {
                score: 0, // Se calcularÃ¡ despuÃ©s con calculateRisks()
                level: 'normal',
                apparent_temperature: null,
                details: {}
            };
        };

        /**
         * Obtiene alertas usando AlertEngine con datos de Meteosource (frontend-only).
         * Backend pausado temporalmente.
         */
        const fetchAlerts = async (hours = 24) => {
            // Retornar alerta normal por defecto (sin errores)
            const defaultAlert = {
                alerts: [{
                    level: 0,
                    level_name: 'Normal',
                    phenomenon: 'condiciones estables',
                    description: 'Sin fenÃ³menos meteorolÃ³gicos significativos.',
                    time_window: 'PrÃ³ximas 24-72 horas',
                    recommendation: 'Sin acciÃ³n requerida.'
                }],
                max_level: 0,
                max_level_name: 'Normal'
            };

            // Si no tenemos AlertEngine, retornar alerta normal
            if (!alertEngine || !alertRules) {
                console.log('[AlertEngine] Motor no inicializado, usando alerta por defecto');
                return defaultAlert;
            }

            const { lat, lon } = CONFIG.location;

            try {
                // Obtener pronÃ³stico horario (prioridad: Meteosource > Open-Meteo)
                let hourlyData;
                try {
                    // Timeout 18s para redes lentas; al vencer resolvemos con null (no reject) para no pausar el depurador
                    const ALERT_FETCH_TIMEOUT_MS = 18000;
                    const timeoutPromise = new Promise((resolve) =>
                        setTimeout(() => { console.warn('[AlertEngine] Timeout obteniendo pronÃ³stico horario'); resolve(null); }, ALERT_FETCH_TIMEOUT_MS)
                    );
                    // Intentar Meteosource primero (si estÃ¡ disponible)
                    if (meteosourceClient) {
                        hourlyData = await Promise.race([
                            meteosourceClient.getHourlyForecast(lat, lon, hours),
                            timeoutPromise
                        ]);
                        if (hourlyData) console.log('[AlertEngine] Datos obtenidos desde Meteosource');
                    }
                    // Fallback a Open-Meteo
                    else if (openMeteoClient) {
                        hourlyData = await Promise.race([
                            openMeteoClient.getHourlyForecast(lat, lon, hours, 'ecmwf_ifs04'),
                            timeoutPromise
                        ]);
                        if (hourlyData) console.log('[AlertEngine] Datos obtenidos desde Open-Meteo');
                    } else {
                        console.warn('[AlertEngine] No hay cliente disponible');
                        return defaultAlert;
                    }
                } catch (fetchError) {
                    console.warn('[AlertEngine] Error obteniendo datos:', fetchError.message);
                    return defaultAlert;
                }

                if (!hourlyData || hourlyData.length === 0) {
                    console.warn('[AlertEngine] No se obtuvieron datos de pronÃ³stico');
                    return defaultAlert;
                }

                // Evaluar alertas con el motor
                const alerts = alertEngine.evaluateForecast(hourlyData, hours);

                if (!alerts || alerts.length === 0) {
                    return defaultAlert;
                }

                // Convertir a formato compatible con cÃ³digo existente
                const maxLevel = alertEngine.getMaxLevel(alerts);
                const maxLevelName = (alertRules.alert_levels && alertRules.alert_levels[maxLevel.toString()])
                    ? alertRules.alert_levels[maxLevel.toString()].name
                    : 'Normal';

                return {
                    alerts: alerts.map(alert => ({
                        level: alert.level || 0,
                        level_name: alert.levelName || 'Normal',
                        phenomenon: alert.phenomenon || 'condiciones estables',
                        description: alert.description || 'Sin fenÃ³menos meteorolÃ³gicos significativos.',
                        time_window: alert.timeWindow || 'PrÃ³ximas 24-72 horas',
                        recommendation: alert.recommendation || 'Sin acciÃ³n requerida.'
                    })),
                    max_level: maxLevel || 0,
                    max_level_name: maxLevelName
                };
            } catch (error) {
                console.error('[AlertEngine] Error generando alertas:', error);
                // Retornar alerta normal si falla (no lanzar error)
                return defaultAlert;
            }
        };

        /**
         * Obtiene todos los datos necesarios desde Open-Meteo (frontend-only).
         * Backend pausado - migrando a WRF-SMN desde AWS S3.
         * 
         * Estado actual:
         * - Datos meteorolÃ³gicos: Open-Meteo (gratuito) con fallback a Windy
         * - Alertas: AlertEngine con Open-Meteo o Meteosource (si estÃ¡ configurado)
         * - Risk scoring: calculateRisks() en frontend (completamente funcional)
         * 
         * NOTA: Open-Meteo no es ideal para CÃ³rdoba, Argentina, pero es la soluciÃ³n
         * temporal hasta configurar NetCDF para WRF-SMN.
         * 
         * PrÃ³ximo paso: Integrar WRF-SMN desde AWS S3 para mejor precisiÃ³n en tormentas
         */
        const fetchWeatherData = async (forceRefresh = false) => {
            // Verificar cache primero
            if (!forceRefresh) {
                const cached = getFromCache();
                if (cached) {
                    const age = getCacheAge();
                    console.log(`[Cache] Usando datos cacheados (${age} min)`);
                    return cached;
                }
            }

            // FunciÃ³n helper para crear datos de ejemplo
            const createExampleData = () => {
                const { lat, lon } = CONFIG.location;
                const now = new Date();
                return {
                    current: {
                        temperature_2m: 22,
                        apparent_temperature: 23,
                        relative_humidity_2m: 65,
                        wind_speed_10m: 15,
                        wind_direction_10m: 180,
                        wind_gusts_10m: 20,
                        precipitation: 0,
                        weather_code: 0,
                        cloud_cover: 30,
                        surface_pressure: 1013,
                        uv_index: 5,
                        time: now.toISOString()
                    },
                    hourly: {
                        time: Array.from({ length: 24 }, (_, i) => {
                            const date = new Date(now);
                            date.setHours(now.getHours() + i);
                            return date.toISOString();
                        }),
                        temperature_2m: Array(24).fill(22),
                        apparent_temperature: Array(24).fill(23),
                        precipitation_probability: Array(24).fill(0),
                        precipitation: Array(24).fill(0),
                        weather_code: Array(24).fill(0),
                        wind_speed_10m: Array(24).fill(15)
                    },
                    daily: {
                        sunrise: [new Date(now.setHours(6, 0, 0, 0)).toISOString()],
                        sunset: [new Date(now.setHours(20, 0, 0, 0)).toISOString()],
                        uv_index_max: [5]
                    },
                    frontend: {
                        riskScore: {
                            score: 0,
                            level: 'normal',
                            apparent_temperature: 23,
                            details: {}
                        },
                        alerts: {
                            alerts: [{
                                level: 0,
                                level_name: 'Normal',
                                phenomenon: 'Sin conexiÃ³n',
                                description: 'No se pudo conectar con la API. Mostrando datos de ejemplo.',
                                time_window: 'Modo offline',
                                recommendation: 'Verifica tu conexiÃ³n a internet y recarga la pÃ¡gina.'
                            }],
                            max_level: 0,
                            max_level_name: 'Normal'
                        },
                        source: 'offline_example',
                        meteoSource: 'offline_example'
                    }
                };
            };

            const { lat, lon } = CONFIG.location;

            // ============ PRIORIDAD 1: BACKEND API ============
            // Intentar backend solo si la fuente preferida no es explÃ­citamente Open-Meteo
            const useBackend = (CONFIG.preferredSource === 'backend' || CONFIG.preferredSource === 'auto') && api && CONFIG.backendUrl;
            if (useBackend) {
                try {
                    console.log(`[Backend] Intentando obtener datos meteorolÃ³gicos para (${lat}, ${lon})...`);

                    // Obtener datos actuales y pronÃ³stico desde el backend
                    const [backendCurrentResponse, forecast] = await Promise.all([
                        api.getCurrentWeather(lat, lon).catch((err) => {
                            console.warn('[Backend] Error obteniendo datos actuales:', err.message);
                            throw err;
                        }),
                        api.getForecast(lat, lon, 48).catch((err) => {
                            console.warn('[Backend] Error obteniendo pronÃ³stico:', err.message);
                            throw err;
                        })
                    ]);

                    // Backend devuelve { current: { ... } }; forecast = { forecast: [ ... ] }. Defender contra respuestas malformadas.
                    const c = backendCurrentResponse.current || backendCurrentResponse;
                    const forecastList = Array.isArray(forecast?.forecast) ? forecast.forecast : [];

                    console.log('[Backend] âœ… Datos obtenidos correctamente desde el backend:', {
                        current: c.temperature ?? c.temperature_2m,
                        forecast: forecastList.length,
                        meteo_source_display: backendCurrentResponse.meteo_source_display || backendCurrentResponse.source || 'fused'
                    });

                    // Usar valores de la API en las unidades del dashboard (API devuelve wind_speed_kmh; fallback m/s * 3.6)
                    const backendWindKmh = (typeof c.wind_speed_kmh === 'number' ? c.wind_speed_kmh : null)
                        ?? (typeof (c.wind_speed ?? c.wind_speed_10m) === 'number' ? (c.wind_speed ?? c.wind_speed_10m ?? 0) * 3.6 : 0);
                    const backendWindKmhNum = typeof backendWindKmh === 'number' ? backendWindKmh : 0;
                    const forecastWindKmh = (f) => (typeof f.wind_speed_kmh === 'number' ? f.wind_speed_kmh : (typeof f.wind_speed === 'number' ? f.wind_speed * 3.6 : 0));
                    const backendData = {
                        current: {
                            temperature_2m: c.temperature ?? c.temperature_2m ?? 0,
                            apparent_temperature: c.apparent_temperature ?? c.temperature ?? c.temperature_2m ?? 0,
                            relative_humidity_2m: c.humidity ?? c.relative_humidity_2m ?? 0,
                            wind_speed_10m: backendWindKmhNum,
                            wind_direction_10m: c.wind_direction_10m ?? c.wind_direction_deg ?? c.wind_direction ?? 0,
                            wind_gusts_10m: backendWindKmhNum * 1.2,
                            precipitation: c.precipitation ?? 0,
                            weather_code: c.weather_code ?? 0,
                            cloud_cover: c.cloud_cover ?? 0,
                            surface_pressure: c.pressure ? c.pressure * 100 : 1013,
                            uv_index: 5,
                            time: c.timestamp ?? c.time ?? new Date().toISOString()
                        },
                        hourly: {
                            time: forecastList.map(f => f.timestamp),
                            temperature_2m: forecastList.map(f => f.temperature),
                            apparent_temperature: forecastList.map(f => f.temperature),
                            precipitation_probability: forecastList.map(() => 0),
                            precipitation: forecastList.map(f => f.precipitation || 0),
                            weather_code: forecastList.map(() => 0),
                            wind_speed_10m: forecastList.map(forecastWindKmh)
                        },
                        daily: {
                            sunrise: [],
                            sunset: [],
                            uv_index_max: []
                        }
                    };

                    // Procesar alertas desde el backend
                    const alerts = await api.getAlerts(lat, lon, 24).catch(() => ({
                        alerts: [{ level: 0, level_name: 'Normal', phenomenon: 'condiciones estables', description: 'Sin fenÃ³menos meteorolÃ³gicos significativos.', time_window: 'PrÃ³ximas 24-72 horas', recommendation: 'Sin acciÃ³n requerida.' }],
                        max_level: 0,
                        max_level_name: 'Normal'
                    }));

                    // M3.2: categorÃ­a de vuelo VFR/MVFR/IFR/LIFR (solo si toggle activo)
                    let flightCategory = null;
                    if (CONFIG.showFlightCategoryBadge) {
                        flightCategory = await api.getFlightCategory(lat, lon).catch(() => null);
                    }

                    const data = {
                        current: backendData.current,
                        hourly: backendData.hourly,
                        daily: backendData.daily,
                        frontend: {
                            riskScore: { score: 0, level: 'normal', apparent_temperature: backendData.current.apparent_temperature, details: {} },
                            alerts: alerts,
                            source: 'backend',
                            meteoSource: backendCurrentResponse.source || 'fused',
                            meteoSourceDisplay: backendCurrentResponse.meteo_source_display || null,
                            flightCategory: flightCategory
                        }
                    };

                    setToCache(data);
                    return data;

                } catch (backendError) {
                    const errorMsg = backendError.message || String(backendError);

                    // Si el error es 503 (Service Unavailable), significa que el backend no tiene fuentes configuradas
                    if (errorMsg.includes('503') || errorMsg.includes('Service Unavailable')) {
                        console.warn('[Backend] âš ï¸ Backend no tiene fuentes de datos configuradas (503)');
                        console.warn('[Backend] El backend necesita API keys configuradas (WINDY_POINT_FORECAST_API_KEY, etc.)');
                        console.warn('[Backend] Usando Open-Meteo como fallback...');
                    } else {
                        console.warn('[Backend] âš ï¸ Error obteniendo datos del backend, usando fallback a Open-Meteo:', backendError);
                    }
                    // Continuar con Open-Meteo como fallback
                }
            }

            // ============ PRIORIDAD 2: OPEN-METEO (FALLBACK) ============
            // Intentar usar OpenMeteoClient (con fallback a Windy automÃ¡tico)
            if (!openMeteoClient) {
                console.error('[Open-Meteo] âŒ Cliente no inicializado, intentando reinicializar...');
                // Intentar reinicializar
                try {
                    openMeteoClient = new OpenMeteoClient(windyApiKey);
                    console.log('[Open-Meteo] âœ… Cliente reinicializado');
                } catch (initError) {
                    console.error('[Open-Meteo] âŒ Error al reinicializar cliente:', initError);
                    console.warn('[Open-Meteo] Usando datos de ejemplo como Ãºltimo recurso');
                    return createExampleData();
                }
            }

            try {
                console.log(`[Open-Meteo] Obteniendo datos para (${lat}, ${lon})...`);

                // Obtener datos actuales, pronÃ³stico horario y diario (solar) desde Open-Meteo
                const [currentData, hourlyForecast, dailyData] = await Promise.all([
                    openMeteoClient.getCurrentWeather(lat, lon, 'ecmwf_ifs04').catch((err) => {
                        console.warn('[Open-Meteo] ECMWF fallÃ³, intentando GFS:', err.message);
                        return openMeteoClient.getCurrentWeather(lat, lon, 'gfs_seamless');
                    }),
                    openMeteoClient.getHourlyForecast(lat, lon, 48, 'ecmwf_ifs04').catch((err) => {
                        console.warn('[Open-Meteo] ECMWF forecast fallÃ³, intentando GFS:', err.message);
                        return openMeteoClient.getHourlyForecast(lat, lon, 48, 'gfs_seamless');
                    }),
                    openMeteoClient.getDailyForecast(lat, lon).catch((err) => {
                        console.warn('[Open-Meteo] Datos diarios (solar) no disponibles:', err.message);
                        return { sunrise: [], sunset: [], uv_index_max: [] };
                    })
                ]);

                // Asegurar que hourlyForecast es array (evitar TypeError si la fuente devuelve otra cosa)
                const hourlyList = Array.isArray(hourlyForecast) ? hourlyForecast : [];
                console.log('[Open-Meteo] âœ… Datos obtenidos correctamente:', {
                    current: currentData.temperature,
                    hourly: hourlyList.length
                });

                // Open-Meteo devuelve viento en m/s; el dashboard y calculateRisks usan km/h
                const omWindKmh = typeof currentData.wind_speed === 'number' ? currentData.wind_speed * 3.6 : 0;
                // Convertir a formato compatible con cÃ³digo existente
                const uvCurrent = currentData.uv_index != null ? currentData.uv_index : (dailyData.uv_index_max && dailyData.uv_index_max[0] != null ? dailyData.uv_index_max[0] : undefined);
                const openMeteoData = {
                    current: {
                        temperature_2m: currentData.temperature,
                        apparent_temperature: currentData.temperature, // AproximaciÃ³n
                        relative_humidity_2m: currentData.humidity,
                        wind_speed_10m: omWindKmh,
                        wind_direction_10m: currentData.wind_direction,
                        wind_gusts_10m: omWindKmh * 1.2, // AproximaciÃ³n
                        precipitation: currentData.precipitation,
                        weather_code: currentData.weather_code,
                        cloud_cover: currentData.cloud_cover,
                        surface_pressure: currentData.pressure ? currentData.pressure * 100 : 1013, // Convertir hPa a Pa
                        uv_index: uvCurrent,
                        time: currentData.timestamp
                    },
                    hourly: {
                        time: hourlyList.map(item => item.date),
                        temperature_2m: hourlyList.map(item => item.temperature),
                        apparent_temperature: hourlyList.map(item => item.temperature), // AproximaciÃ³n
                        precipitation_probability: hourlyList.map(() => 0), // No disponible
                        precipitation: hourlyList.map(item => item.precipitation_mm || 0),
                        weather_code: hourlyList.map(item => item.weather_code),
                        wind_speed_10m: hourlyList.map(item => typeof item.wind_speed === 'number' ? item.wind_speed * 3.6 : 0)
                    },
                    daily: {
                        sunrise: dailyData.sunrise || [],
                        sunset: dailyData.sunset || [],
                        uv_index_max: dailyData.uv_index_max || []
                    }
                };

                // Procesar alertas (usar Open-Meteo si Meteosource no estÃ¡ disponible)
                const alerts = await fetchAlerts(24).catch(() => ({
                    alerts: [{ level: 0, level_name: 'Normal', phenomenon: 'condiciones estables', description: 'Sin fenÃ³menos meteorolÃ³gicos significativos.', time_window: 'PrÃ³ximas 24-72 horas', recommendation: 'Sin acciÃ³n requerida.' }],
                    max_level: 0,
                    max_level_name: 'Normal'
                }));

                const data = {
                    current: openMeteoData.current,
                    hourly: openMeteoData.hourly,
                    daily: openMeteoData.daily,
                    frontend: {
                        riskScore: { score: 0, level: 'normal', apparent_temperature: openMeteoData.current.apparent_temperature, details: {} },
                        alerts: alerts,
                        source: currentData.source || 'open-meteo',
                        meteoSource: 'open-meteo'
                    }
                };

                setToCache(data);
                return data;

            } catch (error) {
                // Cualquier error - usar fallback INMEDIATAMENTE
                console.error('[Open-Meteo] âŒ Error obteniendo datos:', error);
                console.error('[Open-Meteo] Stack:', error.stack);

                const cached = getFromCache();
                if (cached) {
                    console.log('[Open-Meteo] âš ï¸ Usando cache como fallback');
                    return cached;
                }

                // Ãšltimo recurso: datos de ejemplo
                console.warn('[Open-Meteo] âš ï¸ Usando datos de ejemplo como Ãºltimo recurso');
                console.warn('[Open-Meteo] Esto indica un problema de conexiÃ³n o configuraciÃ³n');
                return createExampleData();
            }
        };

        /**
         * Fallback a Open-Meteo (YA NO SE USA - Open-Meteo es la fuente principal ahora).
         * Backend pausado temporalmente.
         */
        // const fetchWeatherDataFallback = async () => {
        //     // Esta funciÃ³n ya no se usa, Open-Meteo es la fuente principal
        //     // Mantenida comentada para referencia
        // };

        // ============ CÃLCULO DE RIESGOS ============
        /**
         * Calcula el riesgo de patrones meteorolÃ³gicos.
         * Por ahora retorna 0 (sin detecciÃ³n compleja de patrones en frontend).
         * El backend tiene PatternDetector completo, frontend solo fallback bÃ¡sico.
         */
        const calculatePatternRisk = (data, profile) => {
            // TODO: Implementar detecciÃ³n bÃ¡sica de patrones si es necesario
            // Por ahora, retornar 0 para coincidir con estructura del backend
            return 0;
        };

        const calculateRisks = (data) => {
            const current = data.current;
            const hourly = data.hourly;
            const weights = GENERAL_WEIGHTS;

            // Riesgo por temperatura (usa sensaciÃ³n tÃ©rmica si es mayor)
            const realTemp = current.temperature_2m;
            const feelsLike = current.apparent_temperature || realTemp;
            const temp = Math.max(realTemp, feelsLike); // Usar la mÃ¡s alta para calor
            const coldTemp = Math.min(realTemp, feelsLike); // Usar la mÃ¡s baja para frÃ­o

            let tempRisk = 0;
            // Calor extremo (basado en sensaciÃ³n tÃ©rmica)
            if (temp >= 40) tempRisk = 100;
            else if (temp >= 38) tempRisk = 85 + (temp - 38) * 7.5; // 85-100%
            else if (temp >= 35) tempRisk = 60 + (temp - 35) * 8.3; // 60-85%
            else if (temp >= 32) tempRisk = 35 + (temp - 32) * 8.3; // 35-60%
            else if (temp >= 28) tempRisk = 10 + (temp - 28) * 6.25; // 10-35%
            // FrÃ­o (basado en sensaciÃ³n tÃ©rmica)
            else if (coldTemp <= -5) tempRisk = 100;
            else if (coldTemp <= 0) tempRisk = 70 + (0 - coldTemp) * 6; // 70-100%
            else if (coldTemp <= 5) tempRisk = 40 + (5 - coldTemp) * 6; // 40-70%
            else if (coldTemp <= 10) tempRisk = 15 + (10 - coldTemp) * 5; // 15-40%

            // Riesgo por viento
            const wind = current.wind_speed_10m;
            let windRisk = 0;
            if (wind > 60) windRisk = 100;
            else if (wind > 40) windRisk = 60 + (wind - 40) * 2;
            else if (wind > 25) windRisk = 20 + (wind - 25) * 2.67;
            else if (wind > 15) windRisk = (wind - 15) * 2;

            // Riesgo por precipitaciÃ³n
            // Considerar precipitaciÃ³n actual y pronosticada en las prÃ³ximas 6 horas
            const precip = current.precipitation || 0;
            const precipProb = (hourly && hourly.precipitation_probability && Array.isArray(hourly.precipitation_probability)) ?
                Math.max(...hourly.precipitation_probability.slice(0, 6)) : 0;

            // PrecipitaciÃ³n pronosticada en las prÃ³ximas 6 horas
            const futurePrecip = (hourly && hourly.precipitation && Array.isArray(hourly.precipitation)) ?
                Math.max(...hourly.precipitation.slice(0, 6)) : 0;

            // Weather codes que indican lluvia (61-67: lluvia, 80-82: chubascos, 95-99: tormentas)
            const futureWeatherCodes = (hourly && hourly.weather_code && Array.isArray(hourly.weather_code)) ?
                hourly.weather_code.slice(0, 6) : [];
            const hasRainInNextHours = futureWeatherCodes.some(code =>
                code != null && ((code >= 61 && code <= 67) || (code >= 80 && code <= 82) || (code >= 95 && code <= 99))
            );

            // Calcular riesgo basado en mÃºltiples factores
            let precipRisk = 0;

            // Si hay lluvia actual
            if (precip > 0) {
                precipRisk = Math.min(100, precip * 20); // 1mm = 20%, 5mm = 100%
            }

            // Si hay lluvia pronosticada en las prÃ³ximas horas
            if (futurePrecip > 0) {
                const futureRisk = Math.min(100, futurePrecip * 15); // 1mm = 15%, ~6.7mm = 100%
                precipRisk = Math.max(precipRisk, futureRisk);
            }

            // Si el weather_code indica lluvia en las prÃ³ximas horas
            if (hasRainInNextHours) {
                // Asegurar mÃ­nimo riesgo si hay lluvia pronosticada
                const codeRisk = Math.max(30, precipProb * 0.5); // MÃ­nimo 30% si hay lluvia pronosticada
                precipRisk = Math.max(precipRisk, codeRisk);
            }

            // Considerar probabilidad de precipitaciÃ³n
            if (precipProb > 0) {
                const probRisk = precipProb * 0.8; // Probabilidad directa
                precipRisk = Math.max(precipRisk, probRisk);
            }

            precipRisk = Math.min(100, precipRisk);

            // Riesgo por tormenta elÃ©ctrica (weather_code 95-99)
            // Considerar weather codes actuales Y futuros (prÃ³ximas 6 horas)
            const currentWeatherCode = current.weather_code || 0;

            // Combinar todos los weather codes a evaluar (evitar redeclarar futureWeatherCodes)
            const allWeatherCodes = [currentWeatherCode, ...futureWeatherCodes].filter(code => code != null);

            let stormRisk = 0;
            // Buscar el mÃ¡ximo riesgo de tormenta en los prÃ³ximos 6 horas
            for (const code of allWeatherCodes) {
                if (code >= 99) {
                    stormRisk = 100; // Tormenta severa con granizo - mÃ¡ximo riesgo
                    break; // No hay nada mÃ¡s alto
                } else if (code >= 96 && stormRisk < 90) {
                    stormRisk = 90; // Tormenta con granizo
                } else if (code >= 95 && stormRisk < 80) {
                    stormRisk = 80; // Tormenta elÃ©ctrica
                } else if (code >= 80 && stormRisk < 40) {
                    stormRisk = 40; // Chubascos fuertes
                } else if (code >= 61 && code <= 67 && stormRisk < 15) {
                    stormRisk = 15; // Lluvia (61-67: lluvia segÃºn WMO)
                }
            }

            // Riesgo por granizo (weather_code 96-99 + condiciones propicias)
            let hailRisk = 0;
            // Buscar el mÃ¡ximo riesgo de granizo en los prÃ³ximos 6 horas
            for (const code of allWeatherCodes) {
                if (code >= 99) {
                    hailRisk = 100; // Granizo severo - mÃ¡ximo riesgo
                    break; // No hay nada mÃ¡s alto
                } else if (code >= 96 && hailRisk < 85) {
                    hailRisk = 85; // Granizo confirmado
                } else if (code === 77 && hailRisk < 40) {
                    hailRisk = 40; // Granizo ligero (77: nieve granulada/granizo)
                }
            }

            // Condiciones propicias para granizo: calor + tormenta pronosticada
            if (hailRisk === 0) {
                const hasStormInFuture = futureWeatherCodes.some(code => code != null && code >= 95);
                if (hasStormInFuture) {
                    if (temp >= 30) hailRisk = 50; // Alta probabilidad
                    else if (temp >= 28) hailRisk = 25; // Probabilidad moderada
                }
            }

            // Score combinado: promedio ponderado (normalizado a 100%)
            // Calcular pattern_risk bÃ¡sico (sin detecciÃ³n compleja de patrones)
            const patternRisk = calculatePatternRisk(data, null);

            // Pesos fijos para storm/hail (como backend: 0.2 cada uno)
            const stormWeight = 0.2;
            const hailWeight = 0.2;

            const weightedScore =
                tempRisk * weights.temp +
                windRisk * weights.wind +
                precipRisk * weights.precip +
                patternRisk * weights.pattern +  // âœ… Agregar pattern_risk
                stormRisk * stormWeight +       // âœ… Peso fijo 0.2
                hailRisk * hailWeight;          // âœ… Peso fijo 0.2

            // MÃ¡ximo riesgo individual (cualquier factor crÃ­tico eleva el Ã­ndice)
            const maxRisk = Math.max(tempRisk, windRisk, precipRisk, stormRisk, hailRisk, patternRisk);

            // Combinar: 60% promedio ponderado + 40% mÃ¡ximo individual
            // Esto asegura que una ola de calor sola suba el Ã­ndice
            const combinedScore = (weightedScore * 0.6) + (maxRisk * 0.4);

            // Convertir de 0-100 a 0-5 (con 1 decimal)
            const score = Math.min(5, Math.round((combinedScore / 100) * 5 * 10) / 10);
            // Asegurar que el score sea un nÃºmero con 1 decimal
            const formattedScore = parseFloat(score.toFixed(1));

            // Debug: Log de cÃ¡lculo para diagnÃ³stico
            console.log('[RiskScore] CÃ¡lculo detallado:', {
                tempRisk,
                windRisk,
                precipRisk,
                stormRisk,
                hailRisk,
                patternRisk,
                weightedScore: weightedScore.toFixed(2),
                maxRisk,
                combinedScore: combinedScore.toFixed(2),
                score: formattedScore
            });

            return {
                score: formattedScore, // Score formateado con 1 decimal
                tempRisk: Math.round(tempRisk),
                windRisk: Math.round(windRisk),
                precipRisk: Math.round(precipRisk),
                stormRisk: Math.round(stormRisk),
                hailRisk: Math.round(hailRisk),
                patternRisk: Math.round(patternRisk), // âœ… Agregar patternRisk
                maxRisk: Math.round(maxRisk)
            };
        };

        const getCategory = (score) => {
            // Escala 0-5 consistente con niveles de alerta
            if (score >= 4) return { name: 'CrÃ­tico', class: 'extreme', color: '#DC2626', level: 4 };
            if (score >= 3) return { name: 'Alerta', class: 'very-high', color: '#F97316', level: 3 };
            if (score >= 2) return { name: 'PrecauciÃ³n', class: 'moderate', color: '#F59E0B', level: 2 };
            if (score >= 1) return { name: 'AtenciÃ³n', class: 'low', color: '#3B82F6', level: 1 };
            return { name: 'Normal', class: 'very-low', color: '#10B981', level: 0 };
        };

        // ============ ICONOS DE ALERTA SVG ============
        const ALERT_ICONS = {
            // Nivel 0 - Normal (checkmark)
            0: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
            // Nivel 1 - AtenciÃ³n (info)
            1: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>',
            // Nivel 2 - PrecauciÃ³n (warning triangle)
            2: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
            // Nivel 3 - Alerta (alert octagon)
            3: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>',
            // Nivel 4 - CrÃ­tico (shield alert)
            4: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'
        };

        // ============ ALERTAS ============
        /**
         * Genera alerta basada en el risk score para mantener consistencia.
         * 
         * IMPORTANTE: El alert banner usa el mismo score que el risk score card
         * para evitar inconsistencias (ej: score 1.4 = ATENCIÃ“N, pero alerta nivel 3).
         * 
         * Las alertas del backend (con anticipaciÃ³n) se muestran en el alert stack,
         * no en el alert banner principal.
         */
        const generateAlert = (risks, data) => {
            // SIEMPRE usar el score para el alert banner principal
            // Esto garantiza consistencia con el risk score card
            const score = risks.score;

            let level, levelName, title, description, timeWindow;

            // Escala 0-5 - USAR SOLO EL SCORE
            // Esto garantiza que alert-banner y risk-score-card usen el mismo nivel
            if (score >= 4) {
                level = 4;
                levelName = 'CrÃ­tico';
                title = 'CondiciÃ³n peligrosa confirmada';
                description = 'Evitar actividades al aire libre. Buscar refugio seguro.';
                timeWindow = 'PrÃ³ximas 0-3 horas';
            } else if (score >= 3) {
                level = 3;
                levelName = 'Alerta';
                title = 'Riesgo alto detectado';
                description = 'Se recomienda modificar o evitar actividades sensibles al clima.';
                timeWindow = 'PrÃ³ximas 3-12 horas';
            } else if (score >= 2) {
                level = 2;
                levelName = 'PrecauciÃ³n';
                title = 'Riesgo moderado';
                description = 'Posibles interrupciones segÃºn actividad. Evaluar planes.';
                timeWindow = 'PrÃ³ximas 12-24 horas';
            } else if (score >= 1) {
                level = 1;
                levelName = 'AtenciÃ³n';
                title = 'Escenario en evoluciÃ³n';
                description = 'Condiciones a monitorear. Sin acciÃ³n requerida por ahora.';
                timeWindow = 'PrÃ³ximas 24-48 horas';
            } else {
                level = 0;
                levelName = 'Normal';
                title = 'Condiciones estables';
                description = 'Sin impacto operativo esperado.';
                timeWindow = 'PrÃ³ximas 24-72 horas';
            }

            return { level, levelName, icon: ALERT_ICONS[level], title, description, timeWindow };
        };

        // ============ ALERT STACK MANAGEMENT ============
        const alertStack = {
            cards: [],
            maxVisible: 5,

            add(alert, risks, data) {
                // Solo agregar alertas nivel 3-4 al stack
                if (alert.level < 3) return;

                const cardId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const card = {
                    id: cardId,
                    alert,
                    risks,
                    data,
                    timestamp: Date.now()
                };

                this.cards.push(card);
                this.render();

                // Auto-dismiss segÃºn nivel
                if (alert.level === 3) {
                    const timeoutId = setTimeout(() => this.remove(cardId), 15000); // 15s para nivel 3
                    timers.alertTimeouts.set(cardId, timeoutId);
                }
                // Nivel 4 no se auto-dismiss (manual)
            },

            remove(cardId) {
                const card = document.getElementById(cardId);
                if (card) {
                    // Limpiar timeout si existe
                    if (timers.alertTimeouts.has(cardId)) {
                        clearTimeout(timers.alertTimeouts.get(cardId));
                        timers.alertTimeouts.delete(cardId);
                    }

                    // Usar animaciÃ³n de anime.js
                    if (window.AnimeUtils && window.AnimeUtils.animateAlertOut) {
                        window.AnimeUtils.animateAlertOut(card, () => {
                            this.cards = this.cards.filter(c => c.id !== cardId);
                            this.render();
                        });
                    } else {
                        // Fallback al mÃ©todo anterior
                        card.classList.add('fade-out');
                        setTimeout(() => {
                            this.cards = this.cards.filter(c => c.id !== cardId);
                            this.render();
                        }, 200);
                    }
                }
            },

            render() {
                const container = document.getElementById('alert-stack');
                if (!container) return;

                // Limitar a maxVisible
                const visibleCards = this.cards.slice(-this.maxVisible);

                // Limpiar contenedor de forma segura
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }

                if (visibleCards.length === 0) {
                    return;
                }

                // Crear elementos de forma segura
                visibleCards.forEach(card => {
                    const { alert, risks } = card;
                    const impactText = alert.level === 4
                        ? 'Impacto crÃ­tico inminente'
                        : 'Alta probabilidad de impacto';

                    // Crear card principal
                    const cardElement = createSafeElement('div', {
                        className: `alert-floating-card level-${alert.level}`,
                        id: card.id
                    });

                    // BotÃ³n cerrar
                    const closeBtn = createSafeElement('button', {
                        className: 'alert-floating-close',
                        'aria-label': 'Cerrar alerta'
                    });
                    closeBtn.addEventListener('click', () => this.remove(card.id));

                    // SVG de cerrar
                    const closeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    closeSvg.setAttribute('viewBox', '0 0 24 24');
                    closeSvg.setAttribute('fill', 'none');
                    closeSvg.setAttribute('stroke', 'currentColor');
                    closeSvg.setAttribute('stroke-width', '2');
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', '18');
                    line1.setAttribute('y1', '6');
                    line1.setAttribute('x2', '6');
                    line1.setAttribute('y2', '18');
                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', '6');
                    line2.setAttribute('y1', '6');
                    line2.setAttribute('x2', '18');
                    line2.setAttribute('y2', '18');
                    closeSvg.appendChild(line1);
                    closeSvg.appendChild(line2);
                    closeBtn.appendChild(closeSvg);
                    cardElement.appendChild(closeBtn);

                    // Header
                    const header = createSafeElement('div', { className: 'alert-floating-header' });
                    const iconDiv = createSafeElement('div', { className: 'alert-floating-icon' });
                    // Icono como HTML (ya viene sanitizado del backend)
                    const iconParser = new DOMParser();
                    const iconDoc = iconParser.parseFromString(alert.icon, 'text/html');
                    if (iconDoc.body.firstChild) {
                        iconDiv.appendChild(iconDoc.body.firstChild);
                    }
                    header.appendChild(iconDiv);

                    const contentDiv = createSafeElement('div', { className: 'alert-floating-content' });
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-level' }, `Nivel ${alert.level} â€¢ ${escapeHtml(alert.levelName)}`));
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-title' }, escapeHtml(alert.title)));
                    contentDiv.appendChild(createSafeElement('div', { className: 'alert-floating-description' }, escapeHtml(alert.description)));
                    header.appendChild(contentDiv);
                    cardElement.appendChild(header);

                    // Meta
                    const meta = createSafeElement('div', { className: 'alert-floating-meta' });
                    const timeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    timeSvg.setAttribute('viewBox', '0 0 24 24');
                    timeSvg.setAttribute('fill', 'none');
                    timeSvg.setAttribute('stroke', 'currentColor');
                    timeSvg.setAttribute('stroke-width', '2');
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', '12');
                    circle.setAttribute('cy', '12');
                    circle.setAttribute('r', '10');
                    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    polyline.setAttribute('points', '12 6 12 12 16 14');
                    timeSvg.appendChild(circle);
                    timeSvg.appendChild(polyline);
                    meta.appendChild(timeSvg);
                    meta.appendChild(createSafeElement('span', {}, escapeHtml(alert.timeWindow)));
                    const impactSpan = createSafeElement('span', { style: 'margin-left: auto; color: var(--alert-color);' }, escapeHtml(impactText));
                    meta.appendChild(impactSpan);
                    cardElement.appendChild(meta);

                    // Actions (CTA primario primero: Entendido, luego Ver detalles)
                    const actions = createSafeElement('div', { className: 'alert-floating-actions' });
                    if (alert.level === 4) {
                        const acknowledgeBtn = createSafeElement('button', { className: 'alert-floating-btn primary' }, 'Entendido');
                        acknowledgeBtn.addEventListener('click', () => this.acknowledge(card.id));
                        actions.appendChild(acknowledgeBtn);
                    }
                    const detailsBtn = createSafeElement('button', { className: 'alert-floating-btn' }, 'Ver detalles');
                    detailsBtn.addEventListener('click', () => this.expandDetails(card.id));
                    actions.appendChild(detailsBtn);
                    cardElement.appendChild(actions);

                    container.appendChild(cardElement);

                    // Animar entrada de la alerta
                    if (window.AnimeUtils && window.AnimeUtils.animateAlertIn) {
                        const cardIndex = visibleCards.findIndex(c => c.id === card.id);
                        window.AnimeUtils.animateAlertIn(cardElement, cardIndex);
                    }
                });
            },

            expandDetails(cardId) {
                const card = this.cards.find(c => c.id === cardId);
                if (!card) return;

                // Por ahora solo log, en Fase 2 se puede expandir con mÃ¡s info
                console.log('Expandir detalles de alerta:', card);
                // TODO: Implementar modal o expansiÃ³n de detalles
            },

            acknowledge(cardId) {
                // Marcar como leÃ­da pero mantener visible
                console.log('Alerta reconocida:', cardId);
                // TODO: Guardar en localStorage para no mostrar de nuevo
            }
        };

        // ============ METRIC TOOLTIP SYSTEM (Fase 2) ============
        const metricTooltip = {
            currentTooltip: null,
            hideTimeout: null,

            show(metricCard, metricType, data, risks) {
                // Ocultar tooltip anterior
                this.hide();

                // Crear tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'metric-tooltip';
                tooltip.id = 'metric-tooltip';

                // Generar contenido segÃºn tipo de mÃ©trica
                const content = this.generateContent(metricType, data, risks);
                if (content) {
                    tooltip.appendChild(content);
                }

                // Agregar al DOM temporalmente para medir
                document.body.appendChild(tooltip);

                // Obtener dimensiones del tooltip
                const tooltipRect = tooltip.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;

                // Determinar posiciÃ³n considerando viewport y tamaÃ±o del tooltip
                const rect = metricCard.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const isMobile = viewportWidth < 768;

                // Espacio mÃ­nimo requerido (mÃ¡s pequeÃ±o en mÃ³vil)
                const minSpace = isMobile ? 16 : 24;
                const tooltipMargin = isMobile ? 12 : 16;

                let position = 'top';

                // En mÃ³vil, preferir bottom o top segÃºn espacio disponible
                if (isMobile) {
                    const spaceAbove = rect.top;
                    const spaceBelow = viewportHeight - rect.bottom;

                    if (spaceBelow >= tooltipHeight + tooltipMargin) {
                        position = 'bottom';
                    } else if (spaceAbove >= tooltipHeight + tooltipMargin) {
                        position = 'top';
                    } else {
                        // Si no cabe arriba ni abajo, usar bottom y ajustar despuÃ©s
                        position = 'bottom';
                    }
                } else {
                    // Desktop: lÃ³gica original mejorada
                    if (rect.top < 200) {
                        position = 'bottom';
                    } else if (rect.right > viewportWidth - (tooltipWidth + tooltipMargin)) {
                        position = 'left';
                    } else if (rect.left < (tooltipWidth + tooltipMargin)) {
                        position = 'right';
                    } else {
                        position = 'top';
                    }
                }

                tooltip.classList.add(position);

                // Posicionar con ajuste dinÃ¡mico
                this.positionTooltip(tooltip, metricCard, position, isMobile);

                // Mostrar con animaciÃ³n usando anime.js
                if (window.AnimeUtils && window.AnimeUtils.animateTooltipIn) {
                    window.AnimeUtils.animateTooltipIn(tooltip, position);
                } else {
                    // Fallback al mÃ©todo anterior
                    setTimeout(() => tooltip.classList.add('visible'), 10);
                }

                // Event listeners para mantener tooltip visible cuando el mouse estÃ¡ sobre Ã©l
                tooltip.addEventListener('mouseenter', () => {
                    // Cancelar timeout de auto-close cuando el mouse entra al tooltip
                    if (this.hideTimeout) {
                        clearTimeout(this.hideTimeout);
                        this.hideTimeout = null;
                    }
                });

                tooltip.addEventListener('mouseleave', () => {
                    // Ocultar inmediatamente cuando el mouse sale del tooltip
                    this.hide();
                });

                this.currentTooltip = tooltip;

                // Auto-close despuÃ©s de 5s si no hay hover (solo si el mouse no estÃ¡ sobre la card ni el tooltip)
                // Este timeout se cancela cuando el mouse sale de la card o del tooltip
                this.hideTimeout = setTimeout(() => {
                    // Verificar que el tooltip aÃºn existe antes de ocultarlo
                    if (this.currentTooltip && document.body.contains(this.currentTooltip)) {
                        this.hide();
                    }
                }, 5000);
            },

            generateContent(metricType, data, risks) {
                const current = data.current;
                const hourly = data.hourly || [];
                const now = new Date();

                let icon, title, value, comparison, trend, range, insight;

                switch (metricType) {
                    case 'temperature':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>';
                        title = 'Temperatura';
                        value = `${current.temperature_2m}Â°C`;

                        // Simplificado: solo estado y recomendaciÃ³n
                        if (current.temperature_2m > 30) {
                            comparison = 'Temperatura elevada';
                            insight = 'HidrataciÃ³n recomendada.';
                        } else if (current.temperature_2m < 15) {
                            comparison = 'Temperatura fresca';
                            insight = 'Abrigo recomendado.';
                        } else {
                            comparison = 'Temperatura agradable';
                            insight = 'Ideal para actividades al aire libre.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'apparent_temperature':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg>';
                        title = 'SensaciÃ³n TÃ©rmica';
                        value = `${current.apparent_temperature}Â°C`;
                        const tempDiff = current.apparent_temperature - current.temperature_2m;
                        if (Math.abs(tempDiff) > 2) {
                            comparison = tempDiff > 0 ? `+${tempDiff.toFixed(1)}Â°C vs real` : `${tempDiff.toFixed(1)}Â°C vs real`;
                            insight = tempDiff > 2 ? 'MÃ¡s cÃ¡lida por viento/humedad' : 'MÃ¡s frÃ­a por viento';
                        } else {
                            comparison = 'Similar a temperatura real';
                            insight = 'Sin efecto significativo del viento/humedad';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'wind':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2M9.6 4.6A2.5 2.5 0 1 1 11 8H2M12.6 19.4A2.5 2.5 0 1 0 14 16H2"/></svg>';
                        title = 'Viento';
                        value = `${Math.round(current.wind_speed_10m)} km/h`;
                        const windDir = getWindDirectionLabel(current.wind_direction_10m);
                        comparison = `Del ${windDir}`;
                        if (current.wind_speed_10m > 30) {
                            insight = 'Viento fuerte. PrecauciÃ³n en actividades al aire libre.';
                        } else if (current.wind_speed_10m < 10) {
                            insight = 'Viento favorable para vuelo visual (VFR).';
                        } else {
                            insight = 'Condiciones de viento normales.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    case 'humidity':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"/></svg>';
                        title = 'Humedad Relativa';
                        value = `${current.relative_humidity_2m}%`;
                        // Simplificado: solo mostrar estado y recomendaciÃ³n
                        if (current.relative_humidity_2m > 80) {
                            comparison = 'Alta humedad';
                            insight = 'SensaciÃ³n de bochorno posible.';
                        } else if (current.relative_humidity_2m < 30) {
                            comparison = 'Baja humedad';
                            insight = 'HidrataciÃ³n importante.';
                        } else {
                            comparison = 'Humedad normal';
                            insight = 'Rango confortable (40-60%).';
                        }
                        trend = 'neutral'; // Eliminamos la flecha confusa
                        range = null; // Eliminamos secciÃ³n redundante
                        break;

                    case 'cloud_cover':
                        icon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>';
                        title = 'Nubosidad';
                        value = `${current.cloud_cover}%`;
                        if (current.cloud_cover > 75) {
                            comparison = 'Cielo nublado';
                            insight = 'Posible lluvia.';
                        } else if (current.cloud_cover < 25) {
                            comparison = 'Cielo despejado';
                            insight = 'Buenas condiciones.';
                        } else {
                            comparison = 'Cielo parcialmente nublado';
                            insight = 'Nubosidad variable.';
                        }
                        trend = 'neutral';
                        range = null;
                        break;

                    default:
                        return null;
                }

                // VersiÃ³n simplificada: solo header, estado y recomendaciÃ³n
                const fragment = document.createDocumentFragment();

                // Header
                const header = createSafeElement('div', { className: 'metric-tooltip-header' });
                const iconDiv = createSafeElement('div', { className: 'metric-tooltip-icon' });
                // Icono como HTML (parsear si es string)
                if (typeof icon === 'string') {
                    const iconParser = new DOMParser();
                    const iconDoc = iconParser.parseFromString(icon, 'text/html');
                    if (iconDoc.body.firstChild) {
                        iconDiv.appendChild(iconDoc.body.firstChild);
                    }
                } else {
                    iconDiv.appendChild(icon);
                }
                header.appendChild(iconDiv);

                const titleDiv = createSafeElement('div', { className: 'metric-tooltip-title' });
                titleDiv.appendChild(createSafeElement('h4', {}, escapeHtml(title)));
                titleDiv.appendChild(createSafeElement('div', { className: 'metric-tooltip-value' }, escapeHtml(value)));
                header.appendChild(titleDiv);
                fragment.appendChild(header);

                // Body
                const body = createSafeElement('div', { className: 'metric-tooltip-body' });
                const item = createSafeElement('div', { className: 'metric-tooltip-item' });
                const itemContent = createSafeElement('div', { className: 'metric-tooltip-item-content' });
                itemContent.appendChild(createSafeElement('div', { className: 'metric-tooltip-item-label' }, 'Estado'));
                itemContent.appendChild(createSafeElement('div', { className: 'metric-tooltip-item-value' }, escapeHtml(comparison)));
                item.appendChild(itemContent);
                body.appendChild(item);

                const insightDiv = createSafeElement('div', { className: 'metric-tooltip-insight' }, escapeHtml(insight));
                body.appendChild(insightDiv);
                fragment.appendChild(body);

                return fragment;
            },

            positionTooltip(tooltip, metricCard, position, isMobile = false) {
                // En mÃ³vil, usar posiciÃ³n fija en la parte inferior
                if (isMobile) {
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = '16px';
                    tooltip.style.right = '16px';
                    tooltip.style.top = 'auto';
                    tooltip.style.bottom = '16px';
                    tooltip.style.transform = 'none';
                    tooltip.style.margin = '0';
                    tooltip.style.width = 'calc(100vw - 32px)';
                    tooltip.style.maxWidth = 'calc(100vw - 32px)';
                    return;
                }

                const cardRect = metricCard.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                const scrollY = window.scrollY;
                const scrollX = window.scrollX;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Calcular posiciÃ³n base
                let left, top, transform;
                const spacing = 16;

                switch (position) {
                    case 'top':
                        left = cardRect.left + scrollX + (cardRect.width / 2);
                        top = cardRect.top + scrollY - spacing;
                        transform = 'translateX(-50%) translateY(-100%)';
                        break;
                    case 'bottom':
                        left = cardRect.left + scrollX + (cardRect.width / 2);
                        top = cardRect.bottom + scrollY + spacing;
                        transform = 'translateX(-50%) translateY(0)';
                        break;
                    case 'right':
                        left = cardRect.right + scrollX + spacing;
                        top = cardRect.top + scrollY + (cardRect.height / 2);
                        transform = 'translateY(-50%) translateX(0)';
                        break;
                    case 'left':
                        left = cardRect.left + scrollX - spacing;
                        top = cardRect.top + scrollY + (cardRect.height / 2);
                        transform = 'translateX(-100%) translateY(-50%)';
                        break;
                }

                // Ajustar si se sale del viewport (especialmente en mÃ³vil)
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;
                const margin = isMobile ? 8 : 16;

                // Ajuste horizontal
                if (position === 'top' || position === 'bottom') {
                    const leftOffset = left - scrollX;
                    if (leftOffset - (tooltipWidth / 2) < margin) {
                        // Se sale por la izquierda
                        left = scrollX + margin + (tooltipWidth / 2);
                        transform = transform.replace('translateX(-50%)', 'translateX(-50%)');
                    } else if (leftOffset + (tooltipWidth / 2) > viewportWidth - margin) {
                        // Se sale por la derecha
                        left = scrollX + viewportWidth - margin - (tooltipWidth / 2);
                        transform = transform.replace('translateX(-50%)', 'translateX(-50%)');
                    }
                } else if (position === 'right') {
                    const rightEdge = left - scrollX + tooltipWidth;
                    if (rightEdge > viewportWidth - margin) {
                        // Cambiar a left si no cabe a la derecha
                        left = cardRect.left + scrollX - spacing;
                        transform = 'translateX(-100%) translateY(-50%)';
                    }
                } else if (position === 'left') {
                    const leftEdge = left - scrollX - tooltipWidth;
                    if (leftEdge < margin) {
                        // Cambiar a right si no cabe a la izquierda
                        left = cardRect.right + scrollX + spacing;
                        transform = 'translateY(-50%) translateX(0)';
                    }
                }

                // Ajuste vertical
                if (position === 'top') {
                    const topEdge = top - scrollY - tooltipHeight;
                    if (topEdge < margin) {
                        // Cambiar a bottom si no cabe arriba
                        top = cardRect.bottom + scrollY + spacing;
                        transform = 'translateX(-50%) translateY(0)';
                    }
                } else if (position === 'bottom') {
                    const bottomEdge = top - scrollY + tooltipHeight;
                    if (bottomEdge > viewportHeight - margin) {
                        // Ajustar hacia arriba
                        top = cardRect.top + scrollY - spacing;
                        transform = 'translateX(-50%) translateY(-100%)';
                    }
                }

                tooltip.style.position = 'absolute';
                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
                tooltip.style.transform = transform;
                tooltip.style.margin = '0';
            },

            hide() {
                // Cancelar cualquier timeout pendiente
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = null;
                }

                if (!this.currentTooltip) return;

                const tooltip = this.currentTooltip;
                // Limpiar referencia inmediatamente para evitar mÃºltiples llamadas
                this.currentTooltip = null;

                // Remover clase visible inmediatamente
                tooltip.classList.remove('visible');

                // Usar animaciÃ³n de anime.js
                if (window.AnimeUtils && window.AnimeUtils.animateTooltipOut) {
                    const animation = window.AnimeUtils.animateTooltipOut(tooltip);
                    // Si la animaciÃ³n no se iniciÃ³, eliminar directamente
                    if (!animation) {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }
                } else {
                    // Fallback al mÃ©todo anterior
                    setTimeout(() => {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }, 200);
                }
            }
        };

        // ============ RECOMENDACIONES ============
        const getRecommendation = (category, risks) => {
            if (category.class === 'very-low') {
                return 'Condiciones favorables. Disfrute su actividad.';
            }

            if (category.class === 'low') {
                return 'Condiciones aceptables. Monitoree actualizaciones meteorolÃ³gicas.';
            }

            const factors = [];
            if (risks.tempRisk > 30) factors.push('temperatura');
            if (risks.windRisk > 30) factors.push('viento');
            if (risks.precipRisk > 30) factors.push('precipitaciÃ³n');
            if (risks.stormRisk > 30) factors.push('tormentas elÃ©ctricas');
            if (risks.hailRisk > 30) factors.push('granizo');

            const factorsText = factors.length > 0 ? factors.join(', ') : 'condiciones meteorolÃ³gicas';

            if (category.class === 'extreme' || category.class === 'very-high') {
                return `Riesgo ${category.name.toLowerCase()}. Evitar actividad al aire libre. Priorizar seguridad.`;
            }

            return `PrecauciÃ³n por ${factorsText}. Evaluar necesidad de salir.`;
        };

        // ============ WEATHER ICON ============
        const getWeatherIcon = (code) => {
            if (code >= 95) return 'â›ˆï¸';
            if (code >= 80) return 'ðŸŒ§ï¸';
            if (code >= 71) return 'ðŸŒ¨ï¸';
            if (code >= 61) return 'ðŸŒ§ï¸';
            if (code >= 51) return 'ðŸŒ¦ï¸';
            if (code >= 45) return 'ðŸŒ«ï¸';
            if (code >= 3) return 'â˜ï¸';
            if (code >= 2) return 'â›…';
            if (code >= 1) return 'ðŸŒ¤ï¸';
            return 'â˜€ï¸';
        };

        // ============ FORMAT SOURCE NAMES ============
        /**
         * Formatea nombres de fuentes meteorolÃ³gicas para mostrar al usuario.
         * Convierte cÃ³digos tÃ©cnicos a nombres legibles.
         */
        const formatSourceNames = (sources) => {
            if (!Array.isArray(sources) || sources.length === 0) return 'Open-Meteo';

            const sourceMap = {
                'meteosource': 'Meteosource',
                'meteosource_wrf': 'Meteosource WRF',
                'windy_ecmwf': 'Windy ECMWF',
                'windy_gfs': 'Windy GFS',
                'windy_icon': 'Windy ICON',
                'wrf_smn': 'WRF-SMN',
                'local_stations': 'Estaciones Locales',
                'fused': 'FusiÃ³n Multi-Modelo',
                'open_meteo': 'Open-Meteo'
            };

            const formatted = sources.map(s => sourceMap[s.toLowerCase()] || s).filter(Boolean);

            if (formatted.length === 0) return 'Open-Meteo';
            if (formatted.length === 1) return formatted[0];
            if (formatted.length <= 3) return formatted.join(' + ');
            return `${formatted.slice(0, 2).join(' + ')} + ${formatted.length - 2} mÃ¡s`;
        };

        // ============ OBTENER RISK SCORE DEL BACKEND ============
        /**
         * Intenta obtener el risk score del backend.
         * Retorna null si el backend no estÃ¡ disponible o falla.
         */
        const fetchRiskScoreFromBackend = async (hoursAhead = 6) => {
            try {
                if (!api) {
                    console.log('[Backend] API client no inicializado, usando fallback local');
                    return null;
                }

                const { lat, lon } = CONFIG.location;
                console.log(`[Backend] Obteniendo risk score (perfil general) en (${lat}, ${lon})`);

                const response = await api.calculateRiskScore(lat, lon, PROFILE_FIXED, hoursAhead);

                // Mapear respuesta del backend al formato del frontend
                // Backend retorna scores en escala 0-5, frontend espera 0-100 para barras
                return {
                    score: response.score,  // Ya viene en escala 0-5
                    tempRisk: Math.round((response.temperature_risk || 0) * 20),  // Backend: 0-5, Frontend: 0-100
                    windRisk: Math.round((response.wind_risk || 0) * 20),
                    precipRisk: Math.round((response.precipitation_risk || 0) * 20),
                    stormRisk: Math.round((response.storm_risk || 0) * 20),
                    hailRisk: Math.round((response.hail_risk || 0) * 20),
                    patternRisk: Math.round((response.pattern_risk || 0) * 20),  // âœ… Incluir pattern_risk
                    maxRisk: Math.max(
                        (response.temperature_risk || 0) * 20,
                        (response.wind_risk || 0) * 20,
                        (response.precipitation_risk || 0) * 20,
                        (response.storm_risk || 0) * 20,
                        (response.hail_risk || 0) * 20,
                        (response.pattern_risk || 0) * 20
                    )
                };
            } catch (error) {
                console.warn('[Backend] Error obteniendo risk score, usando fallback local:', error);
                return null; // Retornar null para usar fallback
            }
        };

        // Helpers de render (P3 auditorÃ­a): reducen duplicaciÃ³n en el template
        const RISK_FACTOR_ICONS = {
            temp: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>',
            wind: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>',
            rain: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M16 14v6"/><path d="M8 14v6"/><path d="M12 16v6"/></svg>',
            storm: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>',
            hail: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="5" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/><circle cx="12" cy="19" r="1"/></svg>'
        };
        const renderRiskFactor = (name, percent, iconKey) => {
            const icon = RISK_FACTOR_ICONS[iconKey] || '';
            const color = getRiskColor(percent);
            return `<div class="risk-factor">
                                <span class="risk-factor-name">${icon} ${escapeHtml(name)}</span>
                                <div class="risk-factor-bar">
                                    <div class="risk-factor-fill" style="width: ${percent}%; background: ${color};"></div>
                                </div>
                                <span class="risk-factor-value">${percent}%</span>
                            </div>`;
        };

        const renderMetricCard = (opts) => {
            const dataMetric = opts.dataMetric || '';
            const value = opts.value != null && opts.value !== '' ? opts.value : 'â€”';
            const unit = opts.unit || '';
            const label = opts.label || '';
            const iconHtml = opts.iconHtml || '';
            const iconClass = opts.iconClass ? ' ' + opts.iconClass.trim() : '';
            const iconStyle = opts.iconStyle ? opts.iconStyle : '';
            const extraClass = opts.extraClass ? ' ' + opts.extraClass.trim() : '';
            const styleAttr = iconStyle ? ` style="${iconStyle.replace(/"/g, '&quot;')}"` : '';
            return `<div class="metric-card${extraClass}" data-metric="${escapeHtml(dataMetric)}">
                                <div class="metric-icon${iconClass}"${styleAttr}>${iconHtml}</div>
                                <div class="metric-value">${escapeHtml(String(value))}<span class="metric-unit">${escapeHtml(unit)}</span></div>
                                <div class="metric-label">${escapeHtml(label)}</div>
                            </div>`;
        };

        // ============ RENDER DASHBOARD ============
        const renderDashboard = async (data) => {
            try {
                // Validar datos mÃ­nimos requeridos
                if (!data || !data.current) {
                    throw new Error('Datos incompletos: falta data.current');
                }
                if (!data.hourly) {
                    console.warn('[Render] data.hourly no disponible, usando array vacÃ­o');
                    data.hourly = { time: [], temperature_2m: [], precipitation: [], weather_code: [], wind_speed_10m: [], precipitation_probability: [] };
                }

                weatherData = data;

                // ============ OBTENER RISK SCORE (BACKEND O FRONTEND) ============
                // Con Open-Meteo: siempre calcular risk localmente a partir de los mismos datos mostrados.
                // Con Windy+WRF (backend): usar risk del backend (misma fuente).
                let risks, category, alert;
                const useOpenMeteoForRisk = CONFIG.preferredSource === 'open-meteo' || data.frontend?.source === 'open-meteo';

                if (useOpenMeteoForRisk) {
                    risks = calculateRisks(data);
                    console.log('[Frontend] Risk score calculado desde datos Open-Meteo:', risks.score);
                } else if (api && CONFIG.backendUrl) {
                    const backendRiskScore = await fetchRiskScoreFromBackend(6);
                    if (backendRiskScore) {
                        risks = backendRiskScore;
                        console.log('[Backend] âœ… Risk score obtenido del backend:', risks.score);
                    } else {
                        risks = calculateRisks(data);
                        console.log('[Frontend] âš ï¸ Risk score calculado localmente (fallback):', risks.score);
                    }
                } else {
                    risks = calculateRisks(data);
                    if (data.frontend && data.frontend.source === 'offline_example') {
                        console.warn('[Frontend] âš ï¸ ATENCIÃ“N: Usando datos de ejemplo. Score puede no ser preciso.');
                    }
                    console.log('[Frontend] Risk score calculado localmente:', {
                        score: risks.score,
                        source: data.frontend?.source || 'unknown',
                        temp: data.current?.temperature_2m,
                        wind: data.current?.wind_speed_10m,
                        precip: data.current?.precipitation
                    });
                }

                category = getCategory(risks.score);
                alert = generateAlert(risks, data);

                const recommendation = getRecommendation(category, risks);
                const current = data.current;
                const hourly = data.hourly || [];

                // ============ FRONTEND-ONLY: Agregar alertas desde AlertEngine ============
                // Usar alertas del frontend (AlertEngine con Meteosource) si estÃ¡n disponibles
                if (data.frontend && data.frontend.alerts && data.frontend.alerts.alerts && data.frontend.alerts.alerts.length > 0) {
                    const frontendAlerts = data.frontend.alerts.alerts;
                    // Agregar solo alertas de nivel 3-4 al stack
                    const highLevelAlerts = frontendAlerts.filter(a => a.level >= 3);
                    highLevelAlerts.forEach(frontendAlert => {
                        const alertForStack = {
                            level: frontendAlert.level,
                            levelName: frontendAlert.level_name,
                            icon: ALERT_ICONS[frontendAlert.level],
                            title: frontendAlert.phenomenon || `Alerta nivel ${frontendAlert.level}`,
                            description: frontendAlert.description,
                            timeWindow: frontendAlert.time_window
                        };
                        alertStack.add(alertForStack, risks, data);
                    });
                    console.log(`[Frontend] ${highLevelAlerts.length} alertas de nivel alto agregadas al stack`);
                } else if (alert.level >= 3) {
                    // Si no hay alertas del backend, usar la alerta principal
                    alertStack.add(alert, risks, data);
                }

                const circumference = 2 * Math.PI * 85;
                const offset = circumference - (risks.score / 5) * circumference;

                // Timeline hour index
                let timelineHour = 0;

                // ============ BANNER DE ADVERTENCIA (si usa datos de ejemplo) ============
                const isUsingExampleData = data.frontend && data.frontend.source === 'offline_example';
                const sourceLabel = (() => {
                    const display = data.frontend?.meteoSourceDisplay;
                    // Ignorar meteoSourceDisplay si dice "Open-Meteo" pero meteoSource es backend/fused
                    const actualSource = data.frontend?.meteoSource ?? data.frontend?.source;
                    const isBackend = actualSource === 'fused' || actualSource === 'backend';
                    if (display && typeof display === 'string' && !isBackend) return display;
                    if (isBackend) return display && display !== 'Open-Meteo' ? display : 'Windy + WRF-SMN';
                    if (actualSource === 'open-meteo') return 'Open-Meteo';
                    if (actualSource === 'offline_example') return 'Ejemplo';
                    return (typeof actualSource === 'string' ? actualSource.replace(/_/g, ' ') : 'â€”');
                })();
                const backendAvailable = !!(CONFIG.backendUrl && CONFIG.apiKey);
                const currentSource = CONFIG.preferredSource || 'auto';
                const dataSourceWarning = isUsingExampleData ? `
                        <div class="data-source-warning" role="alert" aria-live="polite">
                            <div class="warning-icon">âš ï¸</div>
                            <div class="warning-content">
                                <strong>Modo Offline</strong>
                                <p>No se pudo conectar con la API meteorolÃ³gica. Se estÃ¡n mostrando datos de ejemplo. El score de riesgo puede no ser preciso.</p>
                            </div>
                            <button class="warning-close" onclick="this.parentElement.remove()" aria-label="Cerrar advertencia">Ã—</button>
                        </div>
                    ` : '';

                const app = document.getElementById('app');
                app.innerHTML = `
                ${dataSourceWarning}
                <!-- Main Grid (Content + Sidebar) - primero: Condiciones Actuales y Banner -->
                <div class="main-grid">
                <!-- Main Content -->
                <div class="main-content">
                    <!-- Weather Metrics (Compact for mobile) -->
                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Condiciones Actuales</span>
                            <span class="source-badge ${isUsingExampleData ? 'source-badge-warning' : ''}" title="${isUsingExampleData ? 'Datos de ejemplo - No hay conexiÃ³n con la API' : 'Datos en tiempo real'}">
                                ${isUsingExampleData ? 'âš ï¸ Ejemplo' : 'En vivo'}<span class="source-log" aria-hidden="true">Â· ${sourceLabel}</span>
                            </span>
                            ${(CONFIG.showFlightCategoryBadge && data.frontend?.flightCategory?.category) ? `
                            <span class="flight-category-badge flight-category-${(data.frontend.flightCategory.category || '').toLowerCase()}" title="CategorÃ­a de vuelo OMM/OHMC Â· Vis: ${data.frontend.flightCategory.visibility_km ?? 'â€”'} km Â· Techo: ${data.frontend.flightCategory.ceiling_m ?? 'â€”'} m">
                                ${data.frontend.flightCategory.category}
                            </span>
                            ` : ''}
                            <div class="source-select-wrap" aria-label="SelecciÃ³n de fuente de datos">
                                <label for="source-select">Fuente:</label>
                                <select id="source-select" class="source-selector" onchange="window.selectSource(this.value)">
                                    <option value="auto" ${currentSource === 'auto' ? 'selected' : ''}>AutomÃ¡tico</option>
                                    ${backendAvailable ? `<option value="backend" ${currentSource === 'backend' ? 'selected' : ''}>Windy + WRF</option>` : ''}
                                    <option value="open-meteo" ${currentSource === 'open-meteo' ? 'selected' : ''}>Open-Meteo</option>
                                </select>
                            </div>
                        </div>
                        <div class="metrics-grid">
                            ${renderMetricCard({
                                dataMetric: 'temperature',
                                value: current.temperature_2m != null ? current.temperature_2m : 'â€”',
                                unit: 'Â°C',
                                label: 'Temperatura',
                                iconHtml: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>'
                            })}
                            ${renderMetricCard({
                                dataMetric: 'apparent_temperature',
                                value: current.apparent_temperature != null ? current.apparent_temperature : 'â€”',
                                unit: 'Â°C',
                                label: 'SensaciÃ³n',
                                iconHtml: (current.apparent_temperature != null && current.temperature_2m != null && current.apparent_temperature > current.temperature_2m) ? '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>',
                                extraClass: (current.apparent_temperature != null && current.temperature_2m != null && current.apparent_temperature >= current.temperature_2m + 2) ? 'metric-warning-hot' : (current.apparent_temperature != null && current.temperature_2m != null && current.apparent_temperature <= current.temperature_2m - 2) ? 'metric-warning-cold' : ''
                            })}
                            ${renderMetricCard({
                                dataMetric: 'wind',
                                value: current.wind_speed_10m != null && !Number.isNaN(Number(current.wind_speed_10m)) ? Math.round(Number(current.wind_speed_10m)) : 'â€”',
                                unit: 'km/h',
                                label: 'del ' + getWindDirectionLabel(current.wind_direction_10m),
                                iconHtml: '',
                                iconClass: 'wind-direction',
                                iconStyle: '--wind-color: ' + (typeof current.wind_direction_10m === 'number' ? getWindColor(current.wind_direction_10m) : 'var(--windy-cyan)')
                            })}
                            ${renderMetricCard({
                                dataMetric: 'humidity',
                                value: current.relative_humidity_2m != null ? current.relative_humidity_2m : 'â€”',
                                unit: '%',
                                label: 'Humedad',
                                iconHtml: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"/></svg>'
                            })}
                            ${renderMetricCard({
                                dataMetric: 'cloud_cover',
                                value: current.cloud_cover != null ? current.cloud_cover : 'â€”',
                                unit: '%',
                                label: 'Nubosidad',
                                iconHtml: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>'
                            })}
                        </div>
                    </div>

                    <!-- Alert Banner (2) -->
                    <div class="alert-banner level-${alert.level}">
                        <div class="alert-icon">${alert.icon}</div>
                        <div class="alert-content">
                            <div class="alert-level">Nivel ${alert.level} â€¢ ${alert.levelName}</div>
                            <div class="alert-title">${alert.title}</div>
                            <div class="alert-description">${alert.description}</div>
                        </div>
                        <div class="alert-meta">
                            <div class="alert-time-window"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>${alert.timeWindow}</div>
                        </div>
                        <div class="alert-scale">
                            <div class="alert-scale-bar">
                                <div class="alert-scale-segment seg-0 ${0 <= alert.level ? 'active' : 'inactive'} ${0 === alert.level ? 'current' : ''}"></div>
                                <div class="alert-scale-segment seg-1 ${1 <= alert.level ? 'active' : 'inactive'} ${1 === alert.level ? 'current' : ''}"></div>
                                <div class="alert-scale-segment seg-2 ${2 <= alert.level ? 'active' : 'inactive'} ${2 === alert.level ? 'current' : ''}"></div>
                                <div class="alert-scale-segment seg-3 ${3 <= alert.level ? 'active' : 'inactive'} ${3 === alert.level ? 'current' : ''}"></div>
                                <div class="alert-scale-segment seg-4 ${4 <= alert.level ? 'active' : 'inactive'} ${4 === alert.level ? 'current' : ''}"></div>
                            </div>
                            <div class="alert-scale-labels">
                                <span class="${alert.level === 0 ? 'active' : ''}">Normal</span>
                                <span class="${alert.level === 1 ? 'active' : ''}">AtenciÃ³n</span>
                                <span class="${alert.level === 2 ? 'active' : ''}">PrecauciÃ³n</span>
                                <span class="${alert.level === 3 ? 'active' : ''}">Alerta</span>
                                <span class="${alert.level === 4 ? 'active' : ''}">CrÃ­tico</span>
                            </div>
                        </div>
                    </div>

                    <!-- RecomendaciÃ³n (3) -->
                    <div class="card recommendation-card">
                        <div class="card-header">
                            <span class="card-title">RecomendaciÃ³n</span>
                        </div>
                        <p class="recommendation-text">${recommendation}</p>
                    </div>

                    <!-- Ãndice de Riesgo (5) -->
                    <div class="card risk-score-card" role="region" aria-labelledby="risk-card-title">
                        <div class="card-header">
                            <span id="risk-card-title" class="card-title">Ãndice de Riesgo</span>
                        </div>
                        <div class="risk-gauge">
                            <svg viewBox="0 0 200 200" aria-label="Ãndice de riesgo ${risks.score.toFixed(1)} de 5">
                                <circle class="risk-gauge-bg" cx="100" cy="100" r="85"></circle>
                                <circle class="risk-gauge-fill" cx="100" cy="100" r="85"
                                    stroke="${category.color}"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${offset}">
                                </circle>
                            </svg>
                            <div class="risk-score-value">
                                <div class="risk-score-number">${risks.score.toFixed(1)}</div>
                                <div class="risk-score-label">de 5</div>
                            </div>
                        </div>
                        <div class="risk-category ${category.class}">${category.name}</div>
                        
                        <div class="risk-factors">
                            ${renderRiskFactor('Temperatura', risks.tempRisk, 'temp')}
                            ${renderRiskFactor('Viento', risks.windRisk, 'wind')}
                            ${renderRiskFactor('Lluvia', risks.precipRisk, 'rain')}
                            ${renderRiskFactor('Rayos', risks.stormRisk, 'storm')}
                            ${renderRiskFactor('Granizo', risks.hailRisk, 'hail')}
                        </div>
                    </div>
                </div>

                <!-- Sidebar: Map + Timeline -->
                <div class="sidebar">
                    <!-- Windy Map Embed -->
                    <div class="windy-map-card">
                        <div class="windy-map-header">
                            <span class="windy-map-title"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg> Mapa en Vivo</span>
                            <div class="windy-layer-toggle">
                                <button class="layer-btn" onclick="changeWindyLayer('wind')" title="Viento" aria-label="Ver capa de viento"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg></button>
                                <button class="layer-btn active" onclick="changeWindyLayer('rain')" title="Lluvia" aria-label="Ver capa de lluvia"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M16 14v6"/><path d="M8 14v6"/><path d="M12 16v6"/></svg></button>
                                <button class="layer-btn" onclick="changeWindyLayer('temp')" title="Temperatura" aria-label="Ver capa de temperatura"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg></button>
                            </div>
                        </div>
                        <div class="windy-map-container">
                            <iframe id="windy-iframe"
                                title="Mapa del tiempo Windy - condiciones y capas meteorolÃ³gicas"
                                src="https://embed.windy.com/embed2.html?lat=${CONFIG.location.lat.toFixed(1)}&lon=${CONFIG.location.lon.toFixed(1)}&detailLat=${CONFIG.location.lat.toFixed(1)}&detailLon=${CONFIG.location.lon.toFixed(1)}&zoom=5&level=surface&overlay=rain&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C"
                                allowfullscreen
                                loading="lazy"
                                referrerpolicy="no-referrer-when-downgrade"
                                sandbox="allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox">
                            </iframe>
                        </div>
                    </div>

                    <!-- Timeline Slider -->
                    <div class="timeline-card">
                        <div class="timeline-header">
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <span class="timeline-title"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg> Timeline</span>
                                <span style="font-size: 0.65rem; color: var(--gray-400); font-weight: 400; line-height: 1.2;">
                                    PronÃ³stico meteorolÃ³gico por hora
                                    ${(() => {
                        let sources = [];
                        // Frontend-only: usar fuente desde data.frontend
                        if (data.frontend && data.frontend.source) {
                            sources = [data.frontend.source];
                        } else {
                            sources = ['open_meteo']; // Fuente por defecto
                        }
                        const sourceText = sources.length > 0 ? formatSourceNames(sources) : 'Open-Meteo';
                        return `â€¢ Modelo: ${sourceText}`;
                    })()}
                                </span >
                            </div >
            <span class="timeline-current" id="timeline-hour">Ahora</span>
                        </div >
                        <div class="timeline-slider-container">
                            <div class="timeline-slider-track">
                                <div class="timeline-slider-progress" id="timeline-progress" style="width: 0%"></div>
                        </div>
                        <input type="range" class="timeline-slider" id="timeline-slider" 
                               min="0" max="23" value="0" 
                                   aria-label="Seleccionar hora del pronÃ³stico"
                                   aria-valuemin="0" aria-valuemax="23" aria-valuenow="0"
                               oninput="updateTimeline(this.value)">
                        </div>
                        <div class="timeline-labels">
                            ${(() => {
                        // FunciÃ³n para formatear hora en formato hh hs
                        const formatTimelineLabel = (timeString) => {
                            if (!timeString) return '-- hs';
                            try {
                                const date = new Date(timeString);
                                const hour = date.toLocaleTimeString('es-AR', {
                                    hour: '2-digit',
                                    hour12: false
                                });
                                return hour + ' hs';
                            } catch {
                                return '-- hs';
                            }
                        };

                        // Calcular horas para las etiquetas
                        if (!hourly || !hourly.time || !Array.isArray(hourly.time) || hourly.time.length === 0) {
                            return '<span>Ahora</span><span>-- hs</span><span>-- hs</span><span>-- hs</span>';
                        }

                        const now = new Date();
                        const currentTime = now.getTime();
                        // Buscar la primera hora que sea >= a la hora actual (puede ser del dÃ­a siguiente)
                        const startIndex = hourly.time.findIndex(t => {
                            if (!t) return false;
                            try {
                                const date = new Date(t);
                                return date.getTime() >= currentTime;
                            } catch {
                                return false;
                            }
                        });
                        const safeStartIndex = startIndex >= 0 ? startIndex : 0;

                        // Obtener horas para +6hs, +12hs, +24hs
                        const hour6 = safeStartIndex + 6 < hourly.time.length ? hourly.time[safeStartIndex + 6] : null;
                        const hour12 = safeStartIndex + 12 < hourly.time.length ? hourly.time[safeStartIndex + 12] : null;
                        const hour24 = safeStartIndex + 23 < hourly.time.length ? hourly.time[safeStartIndex + 23] : null;

                        return `
                        <span>Ahora</span>
                        <span>${hour6 ? formatTimelineLabel(hour6) : '--:--'}</span>
                        <span>${hour12 ? formatTimelineLabel(hour12) : '--:--'}</span>
                        <span>${hour24 ? formatTimelineLabel(hour24) : '--:--'}</span>
                    `;
                    })()}
                        </div>
                        <div class="timeline-forecast" id="timeline-forecast">
                            ${(() => {
                        // Validar que hourly existe y tiene datos
                        if (!hourly || !hourly.time || !Array.isArray(hourly.time) || hourly.time.length === 0) {
                            return '<div style="padding: 1rem; text-align: center; color: var(--gray-400);">No hay datos disponibles</div>';
                        }

                        // Encontrar Ã­ndice de la hora actual
                        const now = new Date();
                        const currentTime = now.getTime();
                        // Buscar la primera hora que sea >= a la hora actual (puede ser del dÃ­a siguiente)
                        const startIndex = hourly.time.findIndex(t => {
                            if (!t) return false;
                            try {
                                const date = new Date(t);
                                return date.getTime() >= currentTime;
                            } catch {
                                return false;
                            }
                        });
                        const safeStartIndex = startIndex >= 0 ? startIndex : 0;

                        return Array.from({ length: 24 }, (_, i) => {
                            const idx = safeStartIndex + i;
                            if (idx >= hourly.time.length || !hourly.time[idx]) return '';

                            // Validar que los datos existen antes de acceder
                            const temp = hourly.temperature_2m && hourly.temperature_2m[idx] !== undefined
                                ? hourly.temperature_2m[idx]
                                : null;
                            const wind = hourly.wind_speed_10m && hourly.wind_speed_10m[idx] !== undefined
                                ? hourly.wind_speed_10m[idx]
                                : null;
                            const weatherCode = hourly.weather_code && hourly.weather_code[idx] !== undefined
                                ? hourly.weather_code[idx]
                                : 0;

                            if (temp === null && wind === null) return '';

                            // Formatear hora real en formato hh hs
                            const formatTimelineTime = (timeString) => {
                                if (!timeString) return '-- hs';
                                try {
                                    const date = new Date(timeString);
                                    const hour = date.toLocaleTimeString('es-AR', {
                                        hour: '2-digit',
                                        hour12: false
                                    });
                                    return hour + ' hs';
                                } catch {
                                    return '-- hs';
                                }
                            };

                            const timeString = hourly.time[idx];
                            const formattedTime = i === 0 ? 'Ahora' : formatTimelineTime(timeString);

                            return `
                                        <div class="forecast-item ${i === 0 ? 'active' : ''}" data-hour="${i}" title="${(() => {
                                    let sources = [];
                                    // Frontend-only: usar fuente desde data.frontend
                                    if (data.frontend && data.frontend.source) {
                                        sources = [data.frontend.source];
                                    } else {
                                        sources = ['open_meteo']; // Fuente por defecto
                                    }
                                    const sourceText = sources.length > 0 ? formatSourceNames(sources) : 'Open-Meteo';
                                    const timeLabel = i === 0 ? 'Condiciones actuales' : formatTimelineTime(timeString);
                                    return `PronÃ³stico meteorolÃ³gico: ${timeLabel} â€¢ Modelo: ${sourceText}`;
                                })()}">
                                            <div class="forecast-time">${formattedTime}</div>
                                            <div class="forecast-icon">${getWeatherIcon(weatherCode)}</div>
                                            <div class="forecast-temp">${temp !== null ? Math.round(temp) : '--'}Â°</div>
                                            <div class="forecast-wind">${wind !== null ? Math.round(wind) : '--'} km/h</div>
                                        </div>
        `;
                        }).join('');
                    })()}
                        </div>
                    </div>

                </div>
                </div> <!-- End main-grid -->

                <!-- InformaciÃ³n Solar (debajo del grid: primero Condiciones + Banner) -->
                ${data.daily ? `
                <div class="card solar-card">
                    <div class="card-header">
                        <span class="card-title">InformaciÃ³n Solar</span>
                    </div>
                    <div class="solar-grid">
                        <div class="solar-item">
                            <div class="solar-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="4"/>
                                    <path d="M12 2v2"/>
                                    <path d="M12 20v2"/>
                                    <path d="m4.93 4.93 1.41 1.41"/>
                                    <path d="m17.66 17.66 1.41 1.41"/>
                                    <path d="M2 12h2"/>
                                    <path d="M20 12h2"/>
                                    <path d="m6.34 17.66-1.41 1.41"/>
                                    <path d="m19.07 4.93-1.41 1.41"/>
                                </svg>
                            </div>
                            <div class="solar-value">${formatSolarTime(data.daily.sunrise?.[0])}</div>
                            <div class="solar-label">Amanecer</div>
                        </div>
                        <div class="solar-item">
                            <div class="solar-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>
                                    <path d="M20 3v4"/>
                                    <path d="M22 5h-4"/>
                                    <path d="M17 21a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/>
                                    <path d="M19 21v-4"/>
                                    <path d="M21 19h-4"/>
                                </svg>
                            </div>
                            <div class="solar-value">${formatSolarTime(data.daily.sunset?.[0])}</div>
                            <div class="solar-label">Atardecer</div>
                        </div>
                        <div class="solar-item">
                            <div class="solar-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="5"/>
                                    <line x1="12" y1="1" x2="12" y2="3"/>
                                    <line x1="12" y1="21" x2="12" y2="23"/>
                                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                                    <line x1="1" y1="12" x2="3" y2="12"/>
                                    <line x1="21" y1="12" x2="23" y2="12"/>
                                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                                </svg>
                            </div>
                            <div class="solar-value">${calculateDayDuration(data.daily.sunrise?.[0], data.daily.sunset?.[0])}</div>
                            <div class="solar-label">DuraciÃ³n del DÃ­a</div>
                        </div>
                        <div class="solar-item">
                            <div class="solar-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="4"/>
                                    <path d="M12 2v2"/>
                                    <path d="M12 20v2"/>
                                    <path d="m4.93 4.93 1.41 1.41"/>
                                    <path d="m17.66 17.66 1.41 1.41"/>
                                    <path d="M2 12h2"/>
                                    <path d="M20 12h2"/>
                                    <path d="m6.34 17.66-1.41 1.41"/>
                                    <path d="m19.07 4.93-1.41 1.41"/>
                                    <path d="M12 6v2"/>
                                    <path d="M12 16v2"/>
                                </svg>
                            </div>
                            <div class="solar-value">
                                ${data.current.uv_index !== undefined ?
                        `${Math.round(data.current.uv_index)} <span class="uv-badge ${getUVCategory(data.current.uv_index).class}">${getUVCategory(data.current.uv_index).label}</span>` :
                        (data.daily.uv_index_max?.[0] !== undefined ?
                            `${Math.round(data.daily.uv_index_max[0])} <span class="uv-badge ${getUVCategory(data.daily.uv_index_max[0]).class}">${getUVCategory(data.daily.uv_index_max[0]).label}</span>` :
                            '--')
                    }
                            </div>
                            <div class="solar-label">Ãndice UV</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Footer Profesional -->
                <footer class="footer">
                    <div class="footer-content">
                        <div class="footer-brand">
                            <img src="assets/images/logos/Logo.png" alt="SkyPulse" class="footer-logo">
                            <div class="footer-brand-text">
                                <div class="footer-brand-name">SkyPulse</div>
                                <div class="footer-brand-tagline">El clima traducido a riesgo real</div>
                            </div>
                        </div>
                        
                        <div class="footer-links">
                            <a href="dashboard.html" class="footer-link">Panel</a>
                        </div>
                        
                        <div class="footer-divider"></div>
                        
                        <div class="disclaimer">
                            âš ï¸ InterpretaciÃ³n operativa. Para decisiones crÃ­ticas, consulte fuentes oficiales.
                        </div>
                        
                        <a href="investigacion-tecnica.html" class="footer-research-badge" target="_blank">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                                <polyline points="14 2 14 8 20 8" />
                                <line x1="16" y1="13" x2="8" y2="13" />
                                <line x1="16" y1="17" x2="8" y2="17" />
                                <polyline points="10 9 9 9 8 9" />
                            </svg>
                            InvestigaciÃ³n TÃ©cnica y Datos Oficiales
                        </a>
                        
                        <div class="footer-copyright">
                            Â© 2025 SkyPulse. Todos los derechos reservados.
                        </div>
                    </div>
                </footer>
            `;

                // Inicializar event listeners para metric tooltips (Fase 2)
                initializeMetricTooltips(data, risks);

                // Animar risk gauge y barras de factores
                if (window.AnimeUtils && window.AnimeUtils.animateRiskGauge) {
                    const riskFactors = [
                        { name: 'temp', value: risks.tempRisk },
                        { name: 'wind', value: risks.windRisk },
                        { name: 'precip', value: risks.precipRisk },
                        { name: 'storm', value: risks.stormRisk },
                        { name: 'hail', value: risks.hailRisk }
                    ];

                    // Convertir score de 0-5 a 0-100 para el gauge (el nÃºmero se mostrarÃ¡ correctamente en la funciÃ³n)
                    const riskScorePercent = (risks.score / 5) * 100;

                    // Esperar un frame para que el DOM estÃ© listo
                    requestAnimationFrame(() => {
                        window.AnimeUtils.animateRiskGauge(riskScorePercent, riskFactors, {
                            gaugeSelector: '.risk-gauge-fill',
                            numberSelector: '.risk-score-number',
                            barSelector: '.risk-factor-fill',
                            // Pasar el score original (0-5) para mostrarlo correctamente
                            originalScore: risks.score
                        });
                    });
                }
            } catch (renderError) {
                console.error('[RenderDashboard] Error renderizando:', renderError);
                console.error('[RenderDashboard] Stack:', renderError.stack);
                const app = document.getElementById('app');
                if (app) {
                    // Limpiar contenido anterior
                    while (app.firstChild) {
                        app.removeChild(app.firstChild);
                    }

                    const errorCard = createSafeElement('div', {
                        className: 'card',
                        style: 'grid-column: 1 / -1; text-align: center; padding: 3rem;'
                    });
                    errorCard.appendChild(createSafeElement('div', { style: 'font-size: 3rem; margin-bottom: 1rem;' }, 'âš ï¸'));
                    errorCard.appendChild(createSafeElement('h2', { style: 'margin-bottom: 0.5rem;' }, 'Error al Renderizar'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-400); margin-bottom: 0.5rem;' }, `Error: ${escapeHtml(renderError.message || 'Error desconocido')}`));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-500); font-size: 0.875rem; margin-bottom: 1rem;' }, 'Toque Recargar para reintentar.'));

                    const reloadBtn = createSafeElement('button', {
                        style: 'margin-top: 0.5rem; padding: 0.75rem 1.5rem; background: var(--windy-cyan); border: none; border-radius: 8px; color: #000; font-weight: 600; cursor: pointer;'
                    }, 'Recargar');
                    reloadBtn.setAttribute('aria-label', 'Recargar para reintentar');
                    reloadBtn.addEventListener('click', () => location.reload());
                    errorCard.appendChild(reloadBtn);

                    app.appendChild(errorCard);
                }
                throw renderError; // Re-lanzar para que init() lo capture
            }
        };

        // ============ INITIALIZE METRIC TOOLTIPS ============
        const initializeMetricTooltips = (data, risks) => {
            const metricCards = document.querySelectorAll('.metric-card[data-metric]');

            metricCards.forEach(card => {
                const metricType = card.getAttribute('data-metric');

                // Event listeners para hover
                card.addEventListener('mouseenter', (e) => {
                    // Cancelar cualquier timeout de ocultaciÃ³n pendiente
                    if (metricTooltip.hideTimeout) {
                        clearTimeout(metricTooltip.hideTimeout);
                        metricTooltip.hideTimeout = null;
                    }
                    metricTooltip.show(card, metricType, data, risks);
                });

                card.addEventListener('mouseleave', (e) => {
                    // Ocultar tooltip cuando el mouse sale de la card
                    // Usar un pequeÃ±o delay para permitir que el mouse pase al tooltip
                    const relatedTarget = e.relatedTarget;
                    const tooltip = metricTooltip.currentTooltip;

                    // Si el mouse va al tooltip, no ocultar
                    if (tooltip && tooltip.contains(relatedTarget)) {
                        return;
                    }

                    // Ocultar inmediatamente
                    metricTooltip.hide();
                });
            });
        };

        const getRiskColor = (risk) => {
            if (risk >= 75) return '#DC2626';
            if (risk >= 50) return '#F97316';
            if (risk >= 30) return '#F59E0B';
            if (risk >= 15) return '#3B82F6';
            return '#10B981';
        };

        // Color del viento segÃºn direcciÃ³n (rosa de los vientos)
        // Norte = rojo cÃ¡lido, Sur = celeste frÃ­o
        const getWindColor = (degrees) => {
            const d = ((degrees % 360) + 360) % 360;

            if (d <= 45 || d > 315) {
                const t = d <= 45 ? d / 45 : (360 - d) / 45;
                return interpolateColor('#EF4444', '#F97316', t);
            } else if (d <= 135) {
                const t = (d - 45) / 90;
                return interpolateColor('#F97316', '#38BDF8', t);
            } else if (d <= 225) {
                const t = (d - 135) / 90;
                return interpolateColor('#38BDF8', '#14B8A6', t);
            } else {
                const t = (d - 225) / 90;
                return interpolateColor('#14B8A6', '#EF4444', t);
            }
        };

        const interpolateColor = (c1Hex, c2Hex, t) => {
            const c1 = parseInt(c1Hex.slice(1), 16);
            const c2 = parseInt(c2Hex.slice(1), 16);
            const r = Math.round(((c1 >> 16) & 255) + (((c2 >> 16) & 255) - ((c1 >> 16) & 255)) * t);
            const g = Math.round(((c1 >> 8) & 255) + (((c2 >> 8) & 255) - ((c1 >> 8) & 255)) * t);
            const b = Math.round((c1 & 255) + ((c2 & 255) - (c1 & 255)) * t);
            return `rgb(${r}, ${g}, ${b})`;
        };

        const getWindDirection = (degrees) => {
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
            return dirs[Math.round(degrees / 22.5) % 16];
        };

        /** Acepta grados (nÃºmero) o cardinal (string) y devuelve etiqueta para mostrar */
        const getWindDirectionLabel = (val) => {
            if (val == null) return 'â€”';
            if (typeof val === 'string') return val;
            return getWindDirection(Number(val));
        };

        // ============ WINDY MAP LAYER CHANGE ============
        const changeWindyLayer = (layer, evt) => {
            try {
                const iframe = document.getElementById('windy-iframe');
                if (!iframe) {
                    console.warn('[Windy] Iframe no encontrado');
                    return;
                }
                const layers = { wind: 'wind', rain: 'rain', temp: 'temp' };
                const overlay = layers[layer];
                if (!overlay) {
                    console.warn('[Windy] Capa desconocida:', layer);
                    return;
                }
                const currentLat = CONFIG.location.lat.toFixed(1);
                const currentLon = CONFIG.location.lon.toFixed(1);
                const baseUrl = `https://embed.windy.com/embed2.html?lat=${currentLat}&lon=${currentLon}&detailLat=${currentLat}&detailLon=${currentLon}&zoom=5&level=surface&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C`;
                iframe.src = baseUrl + '&overlay=' + overlay;

                document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
                const target = (evt && evt.currentTarget) || (typeof event !== 'undefined' && event.target);
                if (target && target.classList && target.classList.contains('layer-btn')) {
                    target.classList.add('active');
                }
            } catch (error) {
                console.error('[Windy] Error cambiando capa:', error);
            }
        };
        window.changeWindyLayer = changeWindyLayer;

        // ============ TIMELINE SLIDER ============
        const updateTimeline = (value) => {
            const hourLabel = document.getElementById('timeline-hour');
            const forecastItems = document.querySelectorAll('.forecast-item');
            const forecastContainer = document.getElementById('timeline-forecast');
            const progressBar = document.getElementById('timeline-progress');
            const labels = document.querySelectorAll('.timeline-labels span');

            // Usar animaciÃ³n de anime.js si estÃ¡ disponible
            if (window.AnimeUtils && window.AnimeUtils.animateTimelineUpdate && hourLabel && progressBar) {
                window.AnimeUtils.animateTimelineUpdate(value, {
                    hourLabel,
                    progressBar,
                    forecastItems: Array.from(forecastItems),
                    labels: Array.from(labels)
                });

                // Scroll to active item (mantener funcionalidad)
                const activeItem = forecastContainer?.querySelector(`[data-hour="${value}"]`);
                if (activeItem && forecastContainer) {
                    activeItem.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                }
            } else {
                // Fallback al mÃ©todo anterior
                const progress = (value / 23) * 100;
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }

                if (hourLabel) {
                    hourLabel.textContent = value == 0 ? 'Ahora' : '+' + value + 'h';
                }

                if (labels.length) {
                    labels.forEach((label, i) => {
                        const thresholds = [0, 6, 12, 23];
                        const isActive = value >= thresholds[i] && (i === 3 || value < thresholds[i + 1]);
                        label.classList.toggle('active', isActive);
                    });
                }

                forecastItems.forEach(item => {
                    const itemHour = parseInt(item.dataset.hour);
                    item.classList.toggle('active', itemHour == value);
                });

                const activeItem = forecastContainer?.querySelector(`[data-hour="${value}"]`);
                if (activeItem && forecastContainer) {
                    activeItem.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                }
            }
        };

        // ============ MODERN LOADER ANIMATION ============
        const loaderMessages = [
            "Conectando...",
            "Obteniendo datos...",
            "Listo"
        ];

        const loaderCodeLines = [
            { num: 1, code: '<span class="loader-variable">forecast</span> <span class="loader-operator">=</span> <span class="loader-function">get_forecast</span><span class="loader-bracket">(</span>' },
            { num: 2, code: '    <span class="loader-variable">lat</span><span class="loader-operator">=</span><span class="loader-string">-31.42</span>, <span class="loader-variable">lon</span><span class="loader-operator">=</span><span class="loader-string">-64.18</span>  <span class="loader-comment"># CÃ³rdoba</span>' },
            { num: 3, code: '<span class="loader-bracket">)</span>' }
        ];

        const animateLoader = () => {
            const codeContainer = document.getElementById('loader-code');
            const messageEl = document.getElementById('loader-message');
            if (!codeContainer || !messageEl) return;

            // FunciÃ³n helper para crear elementos de lÃ­nea
            const createLineElement = (line, index) => {
                const lineEl = document.createElement('div');
                lineEl.className = 'loader-code-line';
                const lineNumber = createSafeElement('span', { className: 'loader-line-number' }, line.num.toString());
                const codeContent = createSafeElement('span', { className: 'loader-code-content' });

                // Parsear HTML del cÃ³digo de forma segura
                const codeParser = new DOMParser();
                const codeDoc = codeParser.parseFromString(
                    line.code + (index === loaderCodeLines.length - 1 ? '<span class="loader-cursor"></span>' : ''),
                    'text/html'
                );
                if (codeDoc.body.firstChild) {
                    codeContent.appendChild(codeDoc.body.firstChild);
                }
                lineEl.appendChild(lineNumber);
                lineEl.appendChild(codeContent);

                return lineEl;
            };

            // Usar utilidad de anime.js si estÃ¡ disponible (solo anima cÃ³digo; mensajes los controla init por fases reales)
            if (window.AnimeUtils && window.AnimeUtils.animateCodeLoader) {
                window.AnimeUtils.animateCodeLoader(
                    codeContainer,
                    messageEl,
                    loaderCodeLines,
                    [], // mensajes vacÃ­os: init actualiza #loader-message por fases
                    createLineElement
                );
            } else {
                // Fallback al mÃ©todo anterior (solo lÃ­neas de cÃ³digo; mensajes los controla init)
                let lineIndex = 0;

                const addLine = () => {
                    if (lineIndex >= loaderCodeLines.length) return;

                    const line = loaderCodeLines[lineIndex];
                    const lineEl = createLineElement(line, lineIndex);
                    lineEl.style.animationDelay = `${lineIndex * 0.15}s`;
                    codeContainer.appendChild(lineEl);

                    requestAnimationFrame(() => lineEl.classList.add('visible'));

                    lineIndex++;
                    if (lineIndex < loaderCodeLines.length) {
                        setTimeout(addLine, 150);
                    }
                };

                // Mensajes los controla init por fases reales; no actualizar aquÃ­
                addLine();
            }
        };

        // ============ SELECTOR DE UBICACIÃ“N ============
        let locationSelectorInitialized = false;
        let locationClickHandler = null;
        let documentClickHandler = null;
        let dropdownClickHandler = null;

        const initLocationSelector = () => {
            const locationElement = document.getElementById('header-location');
            const dropdown = document.getElementById('location-dropdown');
            const cityElement = document.getElementById('location-city');
            const coordsElement = document.getElementById('location-coords');

            // Si los elementos no existen, salir
            if (!locationElement || !dropdown || !cityElement || !coordsElement) {
                console.warn('[LocationSelector] Elementos no encontrados, reintentando...');
                return;
            }

            // Renderizar opciones del dropdown
            const renderLocationOptions = () => {
                dropdown.innerHTML = CONFIG.locations.map(loc => {
                    const isActive = CONFIG.location.name === loc.name;
                    return `
                        <div class="location-option ${isActive ? 'active' : ''}" data-location='${JSON.stringify(loc)}'>
                            <div class="location-option-content">
                                <span class="location-option-city">${loc.name}</span>
                                <span class="location-option-region">${loc.region}</span>
                                <span class="location-option-coords">${loc.coords}</span>
                            </div>
                            <div class="location-option-check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>
                    `;
                }).join('');
            };

            // Actualizar visual del header
            const updateLocationDisplay = () => {
                if (cityElement && coordsElement) {
                    cityElement.textContent = `${CONFIG.location.name}, ${CONFIG.location.region}`;
                    coordsElement.textContent = CONFIG.locations.find(l => l.name === CONFIG.location.name)?.coords || '';
                }
            };

            // Estado de carga del selector de ubicaciÃ³n (evitar multi-click)
            const setLocationLoading = (loading) => {
                if (locationElement) {
                    locationElement.style.pointerEvents = loading ? 'none' : '';
                    locationElement.setAttribute('aria-busy', loading ? 'true' : 'false');
                }
                if (cityElement && loading) {
                    cityElement.textContent = 'Cargando...';
                }
                if (!loading) {
                    updateLocationDisplay();
                }
            };

            // Mostrar error de ubicaciÃ³n con CTA Reintentar (y detecciÃ³n 404)
            const showLocationError = (error) => {
                const is404 = (error && error.message && error.message.includes('404')) || (error && error.status === 404);
                const mainText = is404
                    ? 'Recurso no encontrado (404). No se pudo cargar el pronÃ³stico para esta ubicaciÃ³n.'
                    : 'Error al cargar datos de la nueva ubicaciÃ³n.';
                const container = createSafeElement('div', {
                    style: 'position: fixed; top: 20px; right: 20px; background: #DC2626; color: white; padding: 1rem 1.25rem; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 320px;'
                });
                container.setAttribute('role', 'alert');
                container.setAttribute('aria-live', 'polite');
                const msg = createSafeElement('p', { style: 'margin: 0 0 0.5rem 0; font-size: 0.9rem;' }, mainText);
                const hint = createSafeElement('p', { style: 'margin: 0 0 0.75rem 0; font-size: 0.8rem; opacity: 0.95;' }, 'Toque Reintentar para esta ubicaciÃ³n.');
                const retryBtn = createSafeElement('button', {
                    style: 'padding: 0.5rem 1rem; background: rgba(255,255,255,0.25); border: 1px solid rgba(255,255,255,0.5); border-radius: 6px; color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem;'
                }, 'Reintentar');
                retryBtn.setAttribute('aria-label', 'Reintentar cargar pronÃ³stico para esta ubicaciÃ³n');
                retryBtn.addEventListener('click', async () => {
                    retryBtn.disabled = true;
                    retryBtn.textContent = 'Reintentando...';
                    try {
                        const data = await fetchWeatherData(true);
                        await renderDashboard(data);
                        setTimeout(() => {
                            updateLocationDisplay();
                            renderLocationOptions();
                        }, 100);
                        container.remove();
                    } catch (err) {
                        console.error('Error al reintentar:', err);
                        retryBtn.disabled = false;
                        retryBtn.textContent = 'Reintentar';
                        msg.textContent = (err.message && err.message.includes('404'))
                            ? 'Recurso no encontrado (404). No se pudo cargar el pronÃ³stico para esta ubicaciÃ³n.'
                            : 'Error al cargar datos de la nueva ubicaciÃ³n.';
                    }
                });
                container.appendChild(msg);
                container.appendChild(hint);
                container.appendChild(retryBtn);
                document.body.appendChild(container);
            };

            // Cambiar ubicaciÃ³n
            const changeLocation = async (newLocation) => {
                if (CONFIG.location.name === newLocation.name) {
                    return; // Ya estÃ¡ seleccionada
                }

                // Cerrar dropdown
                locationElement.classList.remove('active');
                dropdown.classList.remove('show');

                // Mostrar loader con transiciÃ³n usando anime.js
                const app = document.getElementById('app');

                if (window.AnimeUtils && window.AnimeUtils.animateLocationChange) {
                    setLocationLoading(true);
                    // Usar animaciÃ³n coordinada
                    const timeline = window.AnimeUtils.animateLocationChange(app, async () => {
                        // Callback ejecutado durante fade out
                        // Actualizar configuraciÃ³n
                        CONFIG.location = { ...newLocation };
                        try { localStorage.setItem('skypulse_location', JSON.stringify(CONFIG.location)); } catch (_) {}

                        // Limpiar cache para forzar recarga con nueva ubicaciÃ³n
                        clearCache();

                        // Actualizar visual
                        updateLocationDisplay();

                        // Actualizar mapa de Windy
                        updateWindyMapLocation(newLocation.lat, newLocation.lon);

                        // Recargar datos meteorolÃ³gicos (forzar refresh)
                        try {
                            const data = await fetchWeatherData(true); // forceRefresh = true
                            await renderDashboard(data);

                            // Actualizar solo el display despuÃ©s de renderizar
                            setTimeout(() => {
                                updateLocationDisplay();
                                renderLocationOptions();
                            }, 100);
                            setLocationLoading(false);
                        } catch (error) {
                            console.error('Error al cargar datos de la nueva ubicaciÃ³n:', error);
                            setLocationLoading(false);
                            showLocationError(error);
                        }
                    });
                } else {
                    // Fallback al mÃ©todo anterior
                    setLocationLoading(true);
                    app.style.opacity = '0';
                    app.style.transition = 'opacity 0.3s ease';

                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Actualizar configuraciÃ³n
                    CONFIG.location = { ...newLocation };
                    try { localStorage.setItem('skypulse_location', JSON.stringify(CONFIG.location)); } catch (_) {}

                    // Limpiar cache para forzar recarga con nueva ubicaciÃ³n
                    clearCache();

                    // Actualizar visual
                    updateLocationDisplay();

                    // Actualizar mapa de Windy
                    updateWindyMapLocation(newLocation.lat, newLocation.lon);

                    // Recargar datos meteorolÃ³gicos (forzar refresh)
                    try {
                        const data = await fetchWeatherData(true); // forceRefresh = true
                        renderDashboard(data);

                        // Actualizar solo el display despuÃ©s de renderizar (sin reinicializar listeners)
                        setTimeout(() => {
                            updateLocationDisplay();
                            renderLocationOptions();
                        }, 100);

                        // Fade in
                        app.style.opacity = '1';
                        setLocationLoading(false);
                    } catch (error) {
                        console.error('Error al cargar datos de la nueva ubicaciÃ³n:', error);
                        app.style.opacity = '1';
                        setLocationLoading(false);
                        showLocationError(error);
                    }
                }
            };

            // Actualizar mapa de Windy
            const updateWindyMapLocation = (lat, lon) => {
                try {
                    const iframe = document.getElementById('windy-iframe');
                    if (!iframe) {
                        console.warn('[Windy] Iframe no encontrado para actualizar ubicaciÃ³n');
                        return;
                    }
                    const baseUrl = `https://embed.windy.com/embed2.html?lat=${lat.toFixed(1)}&lon=${lon.toFixed(1)}&detailLat=${lat.toFixed(1)}&detailLon=${lon.toFixed(1)}&zoom=5&level=surface&overlay=rain&product=ecmwf&menu=&message=true&marker=&calendar=now&pressure=&type=map&location=coordinates&metricWind=km%2Fh&metricTemp=%C2%B0C`;
                    iframe.src = baseUrl;
                    console.log('[Windy] Mapa actualizado a:', lat.toFixed(1), lon.toFixed(1));
                } catch (error) {
                    console.error('[Windy] Error actualizando ubicaciÃ³n del mapa:', error);
                }
            };

            // Solo agregar event listeners si no estÃ¡n inicializados
            if (!locationSelectorInitialized) {
                // Toggle dropdown
                locationClickHandler = (e) => {
                    e.stopPropagation();
                    const isActive = locationElement.classList.contains('active');

                    if (isActive) {
                        locationElement.classList.remove('active');
                        dropdown.classList.remove('show');
                    } else {
                        locationElement.classList.add('active');
                        dropdown.classList.add('show');
                        renderLocationOptions();
                    }
                };
                locationElement.addEventListener('click', locationClickHandler);

                // Cerrar dropdown al hacer click fuera
                documentClickHandler = (e) => {
                    if (!locationElement.contains(e.target)) {
                        locationElement.classList.remove('active');
                        dropdown.classList.remove('show');
                    }
                };
                document.addEventListener('click', documentClickHandler);

                // Manejar selecciÃ³n de ubicaciÃ³n
                dropdownClickHandler = (e) => {
                    const option = e.target.closest('.location-option');
                    if (option) {
                        const locationData = JSON.parse(option.dataset.location);
                        changeLocation(locationData);
                    }
                };
                dropdown.addEventListener('click', dropdownClickHandler);

                locationSelectorInitialized = true;
            }

            // Inicializar visual
            updateLocationDisplay();
        };

        // ============ TIMER MANAGEMENT ============
        const timers = {
            clockInterval: null,
            refreshInterval: null,
            alertTimeouts: new Map(),

            clearAll() {
                if (this.clockInterval) {
                    clearInterval(this.clockInterval);
                    this.clockInterval = null;
                }
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
                this.alertTimeouts.forEach(timeout => clearTimeout(timeout));
                this.alertTimeouts.clear();
            }
        };

        // ============ INITIALIZE EVENT LISTENERS ============
        const initializeEventListeners = () => {
            // Inicializar botones de capas de Windy
            document.querySelectorAll('.layer-btn').forEach(btn => {
                // Remover listeners anteriores si existen
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);

                // Agregar nuevo listener
                const layer = newBtn.getAttribute('onclick')?.match(/changeWindyLayer\('(\w+)'\)/)?.[1];
                if (layer) {
                    newBtn.removeAttribute('onclick');
                    newBtn.addEventListener('click', (e) => {
                        changeWindyLayer(layer, e);
                    });
                }
            });

        };

        // CTA: cambiar fuente de datos y recargar
        window.selectSource = function (value) {
            if (value !== 'auto' && value !== 'backend' && value !== 'open-meteo') return;
            CONFIG.preferredSource = value;
            try {
                localStorage.setItem('skypulse_preferred_source', value);
            } catch (_) {}
            fetchWeatherData(true).then(function (data) {
                if (data && data.current) renderDashboard(data);
            }).catch(function (err) {
                console.warn('[Source] Error al recargar tras cambio de fuente:', err);
            });
        };

        // ============ INIT ============
        const init = async () => {
            // Limpiar timers anteriores si existen
            timers.clearAll();

            // Inicializar panel de alertas (Fase 3)
            updateClock();
            timers.clockInterval = setInterval(updateClock, 1000);

            // Iniciar animaciÃ³n del loader
            animateLoader();

            try {
                console.log('[Init] Iniciando carga de datos...');
                // Fase 1: Conectando
                const loaderMsg = document.getElementById('loader-message');
                const loaderBar = document.querySelector('.loader-progress-bar');
                if (loaderMsg) loaderMsg.textContent = 'Conectando...';
                if (loaderBar) loaderBar.style.width = '25%';

                const data = await fetchWeatherData();
                console.log('[Init] Datos obtenidos:', data);

                // Fase 2: Obteniendo datos
                if (loaderMsg) loaderMsg.textContent = 'Obteniendo datos...';
                if (loaderBar) loaderBar.style.width = '50%';

                // Fase 3: Renderizando
                if (loaderMsg) loaderMsg.textContent = 'Renderizando...';
                if (loaderBar) loaderBar.style.width = '75%';

                // Validar que los datos tengan la estructura esperada
                if (!data || !data.current || !data.hourly) {
                    throw new Error('Datos incompletos recibidos de Open-Meteo');
                }

                // Delay mÃ­nimo para transiciÃ³n suave (reducido de 950ms a 300ms)
                await new Promise(resolve => setTimeout(resolve, 300));

                console.log('[Init] Renderizando dashboard...');
                if (loaderMsg) loaderMsg.textContent = 'Listo';
                if (loaderBar) loaderBar.style.width = '100%';
                try {
                    renderDashboard(data);
                    updateClock(); // Actualizar hora y antigÃ¼edad de datos de inmediato
                    console.log('[Init] Dashboard renderizado correctamente');
                    // Inicializar event listeners despuÃ©s del render inicial
                    setTimeout(initializeEventListeners, 100);
                } catch (renderError) {
                    console.error('[Init] Error en renderDashboard:', renderError);
                    throw renderError;
                }

                // Inicializar selector de ubicaciÃ³n despuÃ©s de renderizar
                // PequeÃ±o delay para asegurar que el DOM estÃ© listo
                setTimeout(() => {
                    try {
                        initLocationSelector();
                        // Inicializar event listeners despuÃ©s del render
                        initializeEventListeners();
                    } catch (locationError) {
                        console.warn('[Init] Error inicializando selector de ubicaciÃ³n:', locationError);
                    }
                }, 100);

                // Auto-refresh con cleanup
                timers.refreshInterval = setInterval(async () => {
                    try {
                        const newData = await fetchWeatherData();
                        await renderDashboard(newData);
                        // Reinicializar event listeners despuÃ©s de cada render
                        setTimeout(initializeEventListeners, 100);
                    } catch (refreshError) {
                        console.error('[Auto-refresh] Error:', refreshError);
                    }
                }, CONFIG.refreshInterval);
            } catch (error) {
                console.error('[Init] Error crÃ­tico:', error);
                console.error('[Init] Stack trace:', error.stack);
                const app = document.getElementById('app');
                if (app) {
                    // Limpiar contenido anterior
                    while (app.firstChild) {
                        app.removeChild(app.firstChild);
                    }

                    const is404 = (error.message && error.message.includes('404')) || (error.status === 404);
                    const mainMessage = is404
                        ? 'Recurso no encontrado (404). No se pudo cargar el pronÃ³stico.'
                        : 'No se pudo cargar el pronÃ³stico.';
                    const errorCard = createSafeElement('div', {
                        className: 'card',
                        style: 'grid-column: 1 / -1; text-align: center; padding: 3rem;'
                    });
                    errorCard.setAttribute('role', 'alert');
                    errorCard.setAttribute('aria-live', 'polite');
                    errorCard.appendChild(createSafeElement('div', { style: 'font-size: 3rem; margin-bottom: 1rem;' }, 'âš ï¸'));
                    errorCard.appendChild(createSafeElement('h2', { style: 'margin-bottom: 0.5rem;' }, 'Error de ConexiÃ³n'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-400); margin-bottom: 0.5rem;' }, mainMessage));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-500); font-size: 0.875rem; margin-bottom: 1rem;' }, 'Toque Reintentar para volver a intentar.'));
                    errorCard.appendChild(createSafeElement('p', { style: 'color: var(--gray-500); font-size: 0.75rem; margin-bottom: 1rem;' }, `Error: ${escapeHtml(error.message || 'Error desconocido')}`));

                    const retryBtn = createSafeElement('button', {
                        style: 'margin-top: 0.5rem; padding: 0.75rem 1.5rem; background: var(--windy-cyan); border: none; border-radius: 8px; color: #000; font-weight: 600; cursor: pointer;'
                    }, 'Reintentar');
                    retryBtn.setAttribute('aria-label', 'Reintentar cargar pronÃ³stico');
                    retryBtn.addEventListener('click', () => {
                        retryBtn.disabled = true;
                        retryBtn.textContent = 'Reintentando...';
                        location.reload();
                    });
                    errorCard.appendChild(retryBtn);

                    app.appendChild(errorCard);
                }
            }
        };

        // ============ THEME TOGGLE ============
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;

        // Check for saved theme preference or default to dark
        const currentTheme = localStorage.getItem('theme') || 'dark';
        if (currentTheme === 'light') {
            body.classList.add('light');
        }

        function switchTheme() {
            body.classList.toggle('light');
            const isLight = body.classList.contains('light');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const isLight = body.classList.contains('light');

            if (!document.startViewTransition) {
                switchTheme();
                // Mejorar transiciÃ³n con anime.js si estÃ¡ disponible
                if (window.AnimeUtils && window.AnimeUtils.enhanceThemeTransition) {
                    window.AnimeUtils.enhanceThemeTransition(!isLight);
                }
                return;
            }

            document.startViewTransition(() => {
                switchTheme();
                // Mejorar transiciÃ³n con anime.js si estÃ¡ disponible
                if (window.AnimeUtils && window.AnimeUtils.enhanceThemeTransition) {
                    window.AnimeUtils.enhanceThemeTransition(!isLight);
                }
            });
        });

        // Start
        init();
    </script>
</body>

</html>
